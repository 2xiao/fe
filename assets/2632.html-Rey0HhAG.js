import{_ as l,r as p,o as i,c as r,a as n,b as s,d as a,w as e,f as u,e as d}from"./app-mXo2sCT-.js";const k={},g={id:"_2632-柯里化-🔒",tabindex:"-1"},h=n("a",{class:"header-anchor",href:"#_2632-柯里化-🔒","aria-hidden":"true"},"#",-1),m={href:"https://2xiao.github.io/leetcode-js/problem/2632.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://leetcode.cn/problems/curry",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"力扣",-1),v={href:"https://leetcode.com/problems/curry",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"LeetCode",-1),x=n("h2",{id:"题目",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#题目","aria-hidden":"true"},"#"),s(" 题目")],-1),y=n("h2",{id:"解题思路",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#解题思路","aria-hidden":"true"},"#"),s(" 解题思路")],-1),w={href:"https://en.wikipedia.org/wiki/Currying",target:"_blank",rel:"noopener noreferrer"},N=n("code",null,"f(a, b, c)",-1),j=n("code",null,"f(a)(b)(c)",-1),q=d(`<h4 id="柯里化的目的是什么" tabindex="-1"><a class="header-anchor" href="#柯里化的目的是什么" aria-hidden="true">#</a> 柯里化的目的是什么？</h4><p>可以从一个实际中的例子中，了解柯里化的好处。</p><p>例如，有一个用于格式化和输出信息的日志（logging）函数 <code>log(date, importance, message)</code>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">date<span class="token punctuation">,</span> importance<span class="token punctuation">,</span> message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>date<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>date<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] [</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>importance<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将它柯里化：</p><p><code>log = _.curry(log);</code></p><p>柯里化之后，<code>log</code> 仍正常运行：</p><p><code>log(new Date(), &quot;DEBUG&quot;, &quot;some debug&quot;); // log(a, b, c)</code></p><p>但是也能以柯里化形式运行：</p><p><code>log(new Date())(&quot;DEBUG&quot;)(&quot;some debug&quot;); // log(a)(b)(c)</code></p><p>现在，可以轻松地为当前日志创建便捷函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// logNow 会是带有固定第一个参数的日志的部分应用函数</span>
<span class="token keyword">let</span> logNow <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用它</span>
<span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&#39;INFO&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;message&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] INFO message</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，<code>logNow</code> 是具有固定第一个参数的 <code>log</code>，换句话说，就是更简短的“部分应用函数（partially applied function）”或“部分函数（partial）”。</p><p>可以更进一步，为当前的调试日志（debug log）提供便捷函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> debugNow <span class="token operator">=</span> <span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&#39;DEBUG&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">debugNow</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] DEBUG message</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，柯里化让我们能够更容易地获取部分应用函数。就像在日志记录示例中看到的那样，普通函数 <code>log(date, importance, message)</code> 在被柯里化之后，当调用它的时候传入一个参数（如 <code>log(date)</code>）或两个参数（<code>log(date, importance)</code>）时，它会返回部分应用函数。</p><h4 id="实现柯里化函数的思路" tabindex="-1"><a class="header-anchor" href="#实现柯里化函数的思路" aria-hidden="true">#</a> 实现柯里化函数的思路</h4><ol><li><p><strong>函数参数处理</strong>：</p><ul><li>输入的函数 <code>fn</code> 可能接受多个参数。</li><li>使用 <code>fn.length</code> 来获取函数期望的参数数量。</li></ul></li><li><p><strong>递归调用</strong>：</p><ul><li>定义一个内部函数 <code>curried</code>，用于处理传入的参数。</li><li>检查当前收到的参数数量 <code>args.length</code> 是否达到 <code>fn</code> 所需的参数数量： <ul><li>如果达到了，则直接调用 <code>fn</code> 并返回结果。</li><li>如果未达到，则返回一个新函数，这个新函数接收更多参数（<code>nextArgs</code>）并将之前的参数（<code>args</code>）与新参数合并。</li></ul></li></ul></li><li><p><strong>返回合成的函数</strong>：</p><ul><li>通过递归调用 <code>curried</code>，允许继续接收参数直到满足条件。</li></ul></li></ol><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(1)</code>，每次调用柯里化函数的开销是常数级的，因为只是处理参数和函数调用。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，在最坏情况下需要存储所有传入的参数，直到达到期望数量的参数。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">curry</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 如果参数数量满足要求，调用原始函数</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 否则，返回一个新函数继续接收参数</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>nextArgs</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>nextArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,23),B=n("thead",null,[n("tr",null,[n("th",{style:{"text-align":"center"}},"题号"),n("th",{style:{"text-align":"left"}},"标题"),n("th",{style:{"text-align":"center"}},"题解"),n("th",{style:{"text-align":"left"}},"标签"),n("th",{style:{"text-align":"left"}},"难度")])],-1),D=n("td",{style:{"text-align":"center"}},"2623",-1),E={style:{"text-align":"left"}},C={href:"https://leetcode.com/problems/memoize",target:"_blank",rel:"noopener noreferrer"},H={style:{"text-align":"center"}},I=n("td",{style:{"text-align":"left"}},null,-1),L={style:{"text-align":"left"}},V=n("td",{style:{"text-align":"center"}},"2630",-1),G={style:{"text-align":"left"}},O={href:"https://leetcode.com/problems/memoize-ii",target:"_blank",rel:"noopener noreferrer"},U={style:{"text-align":"center"}},$=n("td",{style:{"text-align":"left"}},null,-1),A={style:{"text-align":"left"}};function M(z,F){const t=p("ExternalLinkIcon"),o=p("font"),c=p("RouterLink");return i(),r("div",null,[n("h1",g,[h,s(),n("a",m,[s("2632. 柯里化 🔒"),a(t)])]),n("p",null,[s("🟠 "),a(o,{color:"#ffb800"},{default:e(()=>[s("Medium")]),_:1}),s("  🔗 "),n("a",_,[f,a(t)]),s(),n("a",v,[b,a(t)])]),x,y,n("p",null,[n("a",w,[s("柯里化（Currying）"),a(t)]),s("是一种关于函数的高阶技术，它是指将一个函数从可调用的 "),N,s(" 转换为可调用的 "),j,s("。柯里化不会调用函数，只是对函数进行转换。")]),q,u(" prettier-ignore "),n("table",null,[B,n("tbody",null,[n("tr",null,[D,n("td",E,[n("a",C,[s("记忆函数"),a(t)])]),n("td",H,[a(c,{to:"/problem/2623.html"},{default:e(()=>[s("[✓]")]),_:1})]),I,n("td",L,[a(o,{color:"#ffb800"},{default:e(()=>[s("Medium")]),_:1})])]),n("tr",null,[V,n("td",G,[n("a",O,[s("记忆函数 II"),a(t)])]),n("td",U,[a(c,{to:"/problem/2630.html"},{default:e(()=>[s("[✓]")]),_:1})]),$,n("td",A,[a(o,{color:"#ff334b"},{default:e(()=>[s("Hard")]),_:1})])])])])])}const S=l(k,[["render",M],["__file","2632.html.vue"]]);export{S as default};
