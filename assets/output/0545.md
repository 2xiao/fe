---
title: 545. 二叉树的边界 🔒
description: LeetCode,545. 二叉树的边界 🔒,二叉树的边界,Boundary of Binary Tree,解题思路,树,深度优先搜索,二叉树
keywords:
  - LeetCode
  - 545. 二叉树的边界 🔒
  - 二叉树的边界
  - Boundary of Binary Tree
  - 解题思路
  - 树
  - 深度优先搜索
  - 二叉树
---

# 545. 二叉树的边界 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/boundary-of-binary-tree) [`LeetCode`](https://leetcode.com/problems/boundary-of-binary-tree)

## 题目

The **boundary** of a binary tree is the concatenation of the **root** , the
**left boundary** , the **leaves** ordered from left-to-right, and the
**reverse order** of the **right boundary**.

The **left boundary** is the set of nodes defined by the following:

  * The root node's left child is in the left boundary. If the root does not have a left child, then the left boundary is **empty**.
  * If a node in the left boundary and has a left child, then the left child is in the left boundary.
  * If a node is in the left boundary, has **no** left child, but has a right child, then the right child is in the left boundary.
  * The leftmost leaf is **not** in the left boundary.

The **right boundary** is similar to the **left boundary** , except it is the
right side of the root's right subtree. Again, the leaf is **not** part of the
**right boundary** , and the **right boundary** is empty if the root does not
have a right child.

The **leaves** are nodes that do not have any children. For this problem, the
root is **not** a leaf.

Given the `root` of a binary tree, return _the values of its**boundary**_.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0545.Boundary%20of%20Binary%20Tree/images/boundary1.jpg)

> Input: root = [1,null,2,3,4]
> 
> Output: [1,3,4,2]
> 
> Explanation:
> - The left boundary is empty because the root does not have a left child.
> - The right boundary follows the path starting from the root's right child 2 -> 4.
> 
>   4 is a leaf, so the right boundary is [2].
> - The leaves from left to right are [3,4].
> 
> Concatenating everything results in [1] + [] + [3,4] + [2] = [1,3,4,2].

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0545.Boundary%20of%20Binary%20Tree/images/boundary2.jpg)

> Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
> 
> Output: [1,2,4,7,8,9,10,6,3]
> 
> Explanation:
> - The left boundary follows the path starting from the root's left child 2 -> 4.
> 
>   4 is a leaf, so the left boundary is [2].
> - The right boundary follows the path starting from the root's right child 3 -> 6 -> 10.
> 
>   10 is a leaf, so the right boundary is [3,6], and in reverse order is [6,3].
> - The leaves from left to right are [4,7,8,9,10].
> 
> Concatenating everything results in [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3].

**Constraints:**

  * The number of nodes in the tree is in the range `[1, 104]`.
  * `-1000 <= Node.val <= 1000`


## 题目大意

二叉树的 **边界** 是由 **根节点** 、**左边界** 、按从左到右顺序的**叶节点** 和 **逆序的右边界** ，按顺序依次连接组成。

**左边界** 是满足下述定义的节点集合：

  * 根节点的左子节点在左边界中。如果根节点不含左子节点，那么左边界就为 **空** 。
  * 如果一个节点在左边界中，并且该节点有左子节点，那么它的左子节点也在左边界中。
  * 如果一个节点在左边界中，并且该节点 **不含** 左子节点，那么它的右子节点就在左边界中。
  * 最左侧的叶节点 **不在** 左边界中。

**右边界** 定义方式与 **左边界** 相同，只是将左替换成右。即，右边界是根节点右子树的右侧部分；叶节点 **不是**
右边界的组成部分；如果根节点不含右子节点，那么右边界为 **空** 。

**叶节点** 是没有任何子节点的节点。对于此问题，根节点 **不是** 叶节点。

给你一棵二叉树的根节点 `root` ，按顺序返回组成二叉树 **边界** 的这些值。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0545.Boundary%20of%20Binary%20Tree/images/boundary1.jpg)

> 
> 
> 
> 
> 
> **输入：** root = [1,null,2,3,4]
> 
> **输出：**[1,3,4,2]
> 
> **解释：**
> - 左边界为空，因为二叉树不含左子节点。
> - 右边界是 [2] 。从根节点的右子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以右边界只有 2 。
> - 叶节点从左到右是 [3,4] 。
> 
> 按题目要求依序连接得到结果 [1] + [] + [3,4] + [2] = [1,3,4,2] 。

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0545.Boundary%20of%20Binary%20Tree/images/boundary2.jpg)

> 
> 
> 
> 
> 
> **输入：** root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
> 
> **输出：**[1,2,4,7,8,9,10,6,3]
> 
> **解释：**
> - 左边界为 [2] 。从根节点的左子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以左边界只有 2 。
> - 右边界是 [3,6] ，逆序为 [6,3] 。从根节点的右子节点开始的路径为 3 -> 6 -> 10 ，但 10 是叶节点。
> - 叶节点从左到右是 [4,7,8,9,10]
> 
> 按题目要求依序连接得到结果 [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3] 。

**提示：**

  * 树中节点的数目在范围 `[1, 104]` 内
  * `-1000 <= Node.val <= 1000`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 199 | 二叉树的右视图 | [[✓]](/problem/0199.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/binary-tree-right-side-view) [🔗](https://leetcode.com/problems/binary-tree-right-side-view) |