# [3313. 查找树中最后标记的节点 🔒](https://2xiao.github.io/leetcode-js/problem/3313.html)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-the-last-marked-nodes-in-tree) [`LeetCode`](https://leetcode.com/problems/find-the-last-marked-nodes-in-tree)

## 题目

There exists an **undirected** tree with `n` nodes numbered `0` to `n - 1`.
You are given a 2D integer array `edges` of length `n - 1`, where `edges[i] =
[ui, vi]` indicates that there is an edge between nodes `ui` and `vi` in the
tree.

Initially, **all** nodes are **unmarked**. After every second, you mark all
unmarked nodes which have **at least** one marked node _adjacent_ to them.

Return an array `nodes` where `nodes[i]` is the last node to get marked in the
tree, if you mark node `i` at time `t = 0`. If `nodes[i]` has _multiple_
answers for any node `i`, you can choose**any** one answer.



**Example 1:**

**Input:** edges = [[0,1],[0,2]]

**Output:** [2,2,1]

**Explanation:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-02-122236.png)

  * For `i = 0`, the nodes are marked in the sequence: `[0] -> [0,1,2]`. Either 1 or 2 can be the answer.
  * For `i = 1`, the nodes are marked in the sequence: `[1] -> [0,1] -> [0,1,2]`. Node 2 is marked last.
  * For `i = 2`, the nodes are marked in the sequence: `[2] -> [0,2] -> [0,1,2]`. Node 1 is marked last.

**Example 2:**

**Input:** edges = [[0,1]]

**Output:** [1,0]

**Explanation:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-02-122249.png)

  * For `i = 0`, the nodes are marked in the sequence: `[0] -> [0,1]`.
  * For `i = 1`, the nodes are marked in the sequence: `[1] -> [0,1]`.

**Example 3:**

**Input:** edges = [[0,1],[0,2],[2,3],[2,4]]

**Output:** [3,3,1,1,1]

**Explanation:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-03-210550.png)

  * For `i = 0`, the nodes are marked in the sequence: `[0] -> [0,1,2] -> [0,1,2,3,4]`.
  * For `i = 1`, the nodes are marked in the sequence: `[1] -> [0,1] -> [0,1,2] -> [0,1,2,3,4]`.
  * For `i = 2`, the nodes are marked in the sequence: `[2] -> [0,2,3,4] -> [0,1,2,3,4]`.
  * For `i = 3`, the nodes are marked in the sequence: `[3] -> [2,3] -> [0,2,3,4] -> [0,1,2,3,4]`.
  * For `i = 4`, the nodes are marked in the sequence: `[4] -> [2,4] -> [0,2,3,4] -> [0,1,2,3,4]`.



**Constraints:**

  * `2 <= n <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * The input is generated such that `edges` represents a valid tree.


## 题目大意

有一棵有 `n` 个节点，编号从 `0` 到 `n - 1` 的 **无向** 树。给定一个长度为 `n - 1` 的整数数组 `edges`，其中
`edges[i] = [ui, vi]` 表示树中的 `ui` 和 `vi` 之间有一条边。

一开始，**所有**  节点都 **未标记** 。之后的每一秒，你需要标记所有 **至少**  有一个已标记节点相邻的未标记节点。

返回一个数组 `nodes`，表示在时刻 `t = 0` 标记了节点 `i`，那么树中最后标记的节点是 `nodes[i]`。如果对于任意节点 `i`
有多个 `nodes[i]`，你可以选择 **任意**  一个作为答案。



**示例 1：**

**输入：** edges = [[0,1],[0,2]]

**输出：**[2,2,1]

**解释：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-02-122236.png)

  * 对于 `i = 0`，节点以如下序列标记：`[0] -> [0,1,2]`。1 和 2 都可以是答案。
  * 对于 `i = 1`，节点以如下序列标记：`[1] -> [0,1] -> [0,1,2]`。节点 2 最后被标记。
  * 对于 `i = 2`，节点以如下序列标记：`[2] -> [0,2] -> [0,1,2]`。节点 1 最后被标记。

**示例 2：**

**输入：** edges = [[0,1]]

**输出：**[1,0]

**解释：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-02-122249.png)

  * 对于 `i = 0`，节点以如下序列被标记：`[0] -> [0,1]`。
  * 对于 `i = 1`，节点以如下序列被标记：`[1] -> [0,1]`。

**示例 3：**

**输入：** edges = [[0,1],[0,2],[2,3],[2,4]]

**输出：**[3,3,1,1,1]

**解释：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3300-3399/3313.Find%20the%20Last%20Marked%20Nodes%20in%20Tree/images/screenshot-2024-06-03-210550.png)

  * 对于 `i = 0`，节点以如下序列被标记：`[0] -> [0,1,2] -> [0,1,2,3,4]`。
  * 对于 `i = 1`，节点以如下序列被标记：`[1] -> [0,1] -> [0,1,2] -> [0,1,2,3,4]`。
  * 对于 `i = 2`，节点以如下序列被标记：`[2] -> [0,2,3,4] -> [0,1,2,3,4]`。
  * 对于 `i = 3`，节点以如下序列被标记：`[3] -> [2,3] -> [0,2,3,4] -> [0,1,2,3,4]`。
  * 对于 `i = 4`，节点以如下序列被标记：`[4] -> [2,4] -> [0,2,3,4] -> [0,1,2,3,4]`。



**提示：**

  * `2 <= n <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * 输入保证 `edges` 形成一棵合法的树。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 3112 | [访问消失节点的最少时间](https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes) |  |  [`图`](/tag/graph.md) [`数组`](/tag/array.md) [`最短路`](/tag/shortest-path.md) `1+` | <font color=#ffb800>Medium</font> |
| 3241 | [标记所有节点需要的时间](https://leetcode.com/problems/time-taken-to-mark-all-nodes) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`图`](/tag/graph.md) `1+` | <font color=#ff334b>Hard</font> |