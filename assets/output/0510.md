# [510. 二叉搜索树中的中序后继 II](https://leetcode.com/problems/inorder-successor-in-bst-ii)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/inorder-successor-in-bst-ii)

## 题目

Given a `node` in a binary search tree, return _the in-order successor of that
node in the BST_. If that node has no in-order successor, return `null`.

The successor of a `node` is the node with the smallest key greater than
`node.val`.

You will have direct access to the node but not to the root of the tree. Each
node will have a reference to its parent node. Below is the definition for
`Node`:

> 
> 
> 
> 
> 
> class Node {
> 
> > 
> public int val;
> 
> > 
> public Node left;
> 
> > 
> public Node right;
> 
> > 
> public Node parent;
> 
> }
> 
> 



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0510.Inorder%20Successor%20in%20BST%20II/images/285_example_1.png)

> Input: tree = [2,1,3], node = 1
> 
> Output: 2
> 
> Explanation: 1's in-order successor node is 2. Note that both the node and the return value is of Node type.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0510.Inorder%20Successor%20in%20BST%20II/images/285_example_2.png)

> Input: tree = [5,3,6,2,4,null,null,1], node = 6
> 
> Output: null
> 
> Explanation: There is no in-order successor of the current node, so the answer is null.

**Constraints:**

  * The number of nodes in the tree is in the range `[1, 104]`.
  * `-10^5 <= Node.val <= 10^5`
  * All Nodes will have unique values.



**Follow up:** Could you solve it without looking up any of the node's values?


## 题目大意

给定一棵二叉搜索树和其中的一个节点 `node` ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 `null` 。

一个节点 `node` 的中序后继是键值比 `node.val` 大所有的节点中键值最小的那个。

你可以直接访问结点，但无法直接访问树。每个节点都会有其父节点的引用。节点 `Node` 定义如下：

> 
> 
> 
> 
> 
> class Node {
> 
> > 
> public int val;
> 
> > 
> public Node left;
> 
> > 
> public Node right;
> 
> > 
> public Node parent;
> 
> }



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0510.Inorder%20Successor%20in%20BST%20II/images/285_example_1.png)

> 
> 
> 
> 
> 
> **输入：** tree = [2,1,3], node = 1
> 
> **输出：** 2
> 
> **解析：** 1 的中序后继结点是 2 。注意节点和返回值都是 Node 类型的。
> 
> 

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0510.Inorder%20Successor%20in%20BST%20II/images/285_example_2.png)

> 
> 
> 
> 
> 
> **输入：** tree = [5,3,6,2,4,null,null,1], node = 6
> 
> **输出：** null
> 
> **解析：** 该结点没有中序后继，因此返回 null 。
> 
> 



**提示：**

  * 树中节点的数目在范围 `[1, 104]` 内。
  * `-10^5 <= Node.val <= 10^5`
  * 树中各结点的值均保证唯一。



**进阶：** 你能否在不访问任何结点的值的情况下解决问题?


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 285 | [二叉搜索树中的中序后继](https://leetcode.com/problems/inorder-successor-in-bst) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `1+` | <font color=#ffb800>Medium</font> |