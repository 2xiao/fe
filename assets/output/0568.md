# [568. 最大休假天数 🔒](https://2xiao.github.io/leetcode-js/problem/0568.html)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) [`矩阵`](/tag/matrix.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/maximum-vacation-days) [`LeetCode`](https://leetcode.com/problems/maximum-vacation-days)

## 题目

LeetCode wants to give one of its best employees the option to travel among
`n` cities to collect algorithm problems. But all work and no play makes Jack
a dull boy, you could take vacations in some particular cities and weeks. Your
job is to schedule the traveling to maximize the number of vacation days you
could take, but there are certain rules and restrictions you need to follow.

Rules and restrictions:

  1. You can only travel among `n` cities, represented by indexes from `0` to `n - 1`. Initially, you are in the city indexed `0` on **Monday**.
  2. The cities are connected by flights. The flights are represented as an `n x n` matrix (not necessarily symmetrical), called `flights` representing the airline status from the city `i` to the city `j`. If there is no flight from the city `i` to the city `j`, `flights[i][j] == 0`; Otherwise, `flights[i][j] == 1`. Also, `flights[i][i] == 0` for all `i`.
  3. You totally have `k` weeks (each week has **seven days**) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we do not consider the impact of flight time.
  4. For each city, you can only have restricted vacation days in different weeks, given an `n x k` matrix called `days` representing this relationship. For the value of `days[i][j]`, it represents the maximum days you could take a vacation in the city `i` in the week `j`.
  5. You could stay in a city beyond the number of vacation days, but you should work on the extra days, which will not be counted as vacation days.
  6. If you fly from city `A` to city `B` and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city `B` in that week.
  7. We do not consider the impact of flight hours on the calculation of vacation days.

Given the two matrices `flights` and `days`, return _the maximum vacation days
you could take during_`k` _weeks_.



**Example 1:**

> Input: flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
> 
> Output: 12
> 
> Explanation:
> 
> One of the best strategies is:
> 
> 1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.
> 
> (Although you start at city 0, we could also fly to and start at other cities since it is Monday.)
> 
> 2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.
> 
> 3rd week : stay at city 2, and play 3 days and work 4 days.
> 
> Ans = 6 + 3 + 3 = 12.

**Example 2:**

> Input: flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
> 
> Output: 3
> 
> Explanation:
> 
> Since there are no flights that enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. 
> 
> For each week, you only have one day to play and six days to work.
> 
> So the maximum number of vacation days is 3.
> 
> Ans = 1 + 1 + 1 = 3.

**Example 3:**

> Input: flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
> 
> Output: 21
> 
> Explanation:
> 
> One of the best strategies is:
> 
> 1st week : stay at city 0, and play 7 days.
> 
> 2nd week : fly from city 0 to city 1 on Monday, and play 7 days.
> 
> 3rd week : fly from city 1 to city 2 on Monday, and play 7 days.
> 
> Ans = 7 + 7 + 7 = 21

**Constraints:**

  * `n == flights.length`
  * `n == flights[i].length`
  * `n == days.length`
  * `k == days[i].length`
  * `1 <= n, k <= 100`
  * `flights[i][j]` is either `0` or `1`.
  * `0 <= days[i][j] <= 7`


## 题目大意

力扣想让一个最优秀的员工在 **N** 个城市间旅行来收集算法问题。
但只工作不玩耍，聪明的孩子也会变傻，所以您可以在某些特定的城市和星期休假。您的工作就是安排旅行使得最大化你可以休假的天数，但是您需要遵守一些规则和限制。

**规则和限制：**

  1. 您只能在 **N** 个城市之间旅行，用 `0` 到 `n-1` 的索引表示。一开始，您在索引为 `0` 的城市，并且那天是**星期一** 。
  2. 这些城市通过航班相连。这些航班用 `n x n` 矩阵**flights** （不一定是对称的）表示，**flights[i][j]** 代表城市 `i` 到城市 `j` 的航空状态。如果没有城市 `i` 到城市 `j` 的航班，`flights[i][j] = 0` ；否则，`flights[i][j] = 1` 。同时，对于所有的 `i` ，`flights[i][i] = 0` **。**
  3. 您总共有 `k` 周（**每周7天** ）的时间旅行。您**每天** 最多只能乘坐一次航班，并且只能在每周的**星期一** 上午乘坐航班。由于飞行时间很短，我们不考虑飞行时间的影响。
  4. 对于每个城市，不同的星期您休假天数是不同的，给定一个 **N*K** 矩阵 **days** 代表这种限制，**days[i][j]** 代表您在第j个星期在城市i能休假的最长天数。
  5. 如果您从 `A` 市飞往 `B` 市，并在当天休假，扣除的假期天数将计入 `B` 市当周的休假天数。
  6. 我们不考虑飞行时数对休假天数计算的影响。

给定 `flights` 矩阵和 `days` 矩阵，您需要输出 `k` 周内可以休假的最长天数。



**示例 1:**

> 
> 
> 
> 
> 
> **输入:** flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
> 
> **输出:** 12
> 
> **解释:** 
> 
> 最好的策略之一：
> 
> 第一个星期 : 星期一从城市 0 飞到城市 1，玩 6 天，工作 1 天。 
> 
> （虽然你是从城市 0 开始，但因为是星期一，我们也可以飞到其他城市。） 
> 
> 第二个星期 : 星期一从城市 1 飞到城市 2，玩 3 天，工作 4 天。
> 
> 第三个星期 : 呆在城市 2，玩 3 天，工作 4 天。
> 
> Ans = 6 + 3 + 3 = 12. 
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
> 
> **输出:** 3
> 
> **解释:** 
> 
> 由于没有航班可以让您飞到其他城市，你必须在城市 0 呆整整 3 个星期。 
> 
> 对于每一个星期，你只有一天时间玩，剩下六天都要工作。 
> 
> 所以最大休假天数为 3.
> 
> Ans = 1 + 1 + 1 = 3. 
> 
> 

**示例 3:**

> 
> 
> 
> 
> 
> **输入:** flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
> 
> **输出:** 21
> 
> **解释:**
> 
> 最好的策略之一是：
> 
> 第一个星期 : 呆在城市 0，玩 7 天。 
> 
> 第二个星期 : 星期一从城市 0 飞到城市 1，玩 7 天。
> 
> 第三个星期 : 星期一从城市 1 飞到城市 2，玩 7 天。
> 
> Ans = 7 + 7 + 7 = 21
> 
> 



**提示:**

  * `n == flights.length`
  * `n == flights[i].length`
  * `n == days.length`
  * `k == days[i].length`
  * `1 <= n, k <= 100`
  * `flights[i][j]` 不是 `0` 就是 `1`
  * `0 <= days[i] <= 7`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 787 | [K 站中转内最便宜的航班](https://leetcode.com/problems/cheapest-flights-within-k-stops) |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `3+` | <font color=#ffb800>Medium</font> |