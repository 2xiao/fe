# [1257. 最小公共区域](https://leetcode.com/problems/smallest-common-region)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/smallest-common-region)

## 题目

You are given some lists of `regions` where the first region of each list
includes all other regions in that list.

Naturally, if a region `x` contains another region `y` then `x` is bigger than
`y`. Also, by definition, a region `x` contains itself.

Given two regions: `region1` and `region2`, return _the smallest region that
contains both of them_.

If you are given regions `r1`, `r2`, and `r3` such that `r1` includes `r3`, it
is guaranteed there is no `r2` such that `r2` includes `r3`.

It is guaranteed the smallest region exists.



**Example 1:**

> Input: regions = [["Earth","North America","South America"],
> 
> ["North America","United States","Canada"],
> 
> ["United States","New York","Boston"],
> 
> ["Canada","Ontario","Quebec"],
> 
> ["South America","Brazil"]],
> 
> region1 = "Quebec",
> 
> region2 = "New York"
> 
> Output: "North America"

**Example 2:**

> Input: regions = [["Earth", "North America", "South America"],["North America", "United States", "Canada"],["United States", "New York", "Boston"],["Canada", "Ontario", "Quebec"],["South America", "Brazil"]], region1 = "Canada", region2 = "South America"
> 
> Output: "Earth"

**Constraints:**

  * `2 <= regions.length <= 10^4`
  * `2 <= regions[i].length <= 20`
  * `1 <= regions[i][j].length, region1.length, region2.length <= 20`
  * `region1 != region2`
  * `regions[i][j]`, `region1`, and `region2` consist of English letters.


## 题目大意

给你一些区域列表 `regions` ，每个列表的第一个区域都包含这个列表内所有其他区域。

很自然地，如果区域 `X` 包含区域 `Y` ，那么区域 `X`  比区域 `Y` 大。

给定两个区域 `region1` 和 `region2` ，找到同时包含这两个区域的 **最小  **区域。

如果区域列表中 `r1` 包含 `r2` 和 `r3` ，那么数据保证 `r2` 不会包含 `r3` 。

数据同样保证最小公共区域一定存在。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** regions = [["Earth","North America","South America"],
> 
> ["North America","United States","Canada"],
> 
> ["United States","New York","Boston"],
> 
> ["Canada","Ontario","Quebec"],
> 
> ["South America","Brazil"]],
> 
> region1 = "Quebec",
> 
> region2 = "New York"
> 
> **输出：** "North America"
> 
> 



**提示：**

  * `2 <= regions.length <= 10^4`
  * `region1 != region2`
  * 所有字符串只包含英文字母和空格，且最多只有 20 个字母。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 235 | [二叉搜索树的最近公共祖先](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree) | [[✓]](/problem/0235.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `1+` | <font color=#ffb800>Medium</font> |
| 236 | [二叉树的最近公共祖先](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree) | [[✓]](/problem/0236.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md) | <font color=#ffb800>Medium</font> |