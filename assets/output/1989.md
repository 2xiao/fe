---
title: 1989. 捉迷藏中可捕获的最大人数 🔒
description: LeetCode,1989. 捉迷藏中可捕获的最大人数 🔒,捉迷藏中可捕获的最大人数,Maximum Number of People That Can Be Caught in Tag,解题思路,贪心,数组
keywords:
  - LeetCode
  - 1989. 捉迷藏中可捕获的最大人数 🔒
  - 捉迷藏中可捕获的最大人数
  - Maximum Number of People That Can Be Caught in Tag
  - 解题思路
  - 贪心
  - 数组
---

# 1989. 捉迷藏中可捕获的最大人数 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag) [`LeetCode`](https://leetcode.com/problems/maximum-number-of-people-that-can-be-caught-in-tag)

## 题目

You are playing a game of tag with your friends. In tag, people are divided
into two teams: people who are "it", and people who are not "it". The people
who are "it" want to catch as many people as possible who are not "it".

You are given a **0-indexed** integer array `team` containing only zeros
(denoting people who are **not** "it") and ones (denoting people who are
"it"), and an integer `dist`. A person who is "it" at index `i` can catch any
**one** person whose index is in the range `[i - dist, i + dist]`
(**inclusive**) and is **not** "it".

Return _the**maximum** number of people that the people who are "it" can
catch_.



**Example 1:**

> Input: team = [0,1,0,1,0], dist = 3
> 
> Output: 2
> 
> Explanation:
> 
> The person who is "it" at index 1 can catch people in the range [i-dist, i+dist] = [1-3, 1+3] = [-2, 4].
> 
> They can catch the person who is not "it" at index 2.
> 
> The person who is "it" at index 3 can catch people in the range [i-dist, i+dist] = [3-3, 3+3] = [0, 6].
> 
> They can catch the person who is not "it" at index 0.
> 
> The person who is not "it" at index 4 will not be caught because the people at indices 1 and 3 are already catching one person.

**Example 2:**

> Input: team = [1], dist = 1
> 
> Output: 0
> 
> Explanation:
> 
> There are no people who are not "it" to catch.

**Example 3:**

> Input: team = [0], dist = 1
> 
> Output: 0
> 
> Explanation: There are no people who are "it" to catch people.

**Constraints:**

  * `1 <= team.length <= 10^5`
  * `0 <= team[i] <= 1`
  * `1 <= dist <= team.length`


## 题目大意

你正在和你的朋友玩捉迷藏游戏。在捉迷藏比赛中，人们被分成两组：是 “鬼” 的人，和不是 “鬼” 的人。是 “鬼” 的人想要抓住尽可能多的不是 “鬼” 的人。

给定一个 **从 0 开始建立索引** 的整数数组 `team`，其中只包含 0 (表示 **不是** “鬼” 的人) 和 1 (表示是 “鬼”
的人)，以及一个整数 `dist`。索引 `i` 为 “鬼” 的人可以捕获索引在 `[i - dist, i + dist]`(**包括**) 范围内且
**不是** “鬼” 的任何**一个** 人。

返回 _“鬼” 所能捕获的最大人数_ 。



**示例 1:**

> 
> 
> 
> 
> 
> **输入:** team = [0,1,0,1,0], dist = 3
> 
> **输出:** 2
> 
> **解释:**
> 
> 在索引 1 的 “鬼” 可以捕获范围 [i-dist, i+dist] = [1-3, 1+3] = [-2, 4] 内的人。
> 
> 他们可以抓住索引 2 中不是 “鬼” 的人。
> 
> 在索引 3 的 “鬼” 可以捕获范围 [i-dist, i+dist] = [3-3, 3+3] = [0, 6] 内的人。
> 
> 他们可以抓住索引 0 中不是 “鬼” 的人。
> 
> 在索引 4 上不是 “鬼” 的人不会被抓住，因为在索引 1 和 3 上的人已经抓住了一个人。

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** team = [1], dist = 1
> 
> **输出:** 0
> 
> **解释:**
> 
> 没有 “鬼" 要抓的人。
> 
> 

**示例 3:**

> 
> 
> 
> 
> 
> **输入:** team = [0], dist = 1
> 
> **输出:** 0
> 
> **解释:** 没有 “鬼” 来抓人。
> 
> 



**提示:**

  * `1 <= team.length <= 10^5`
  * `0 <= team[i] <= 1`
  * `1 <= dist <= team.length`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 2086 | 喂食仓鼠的最小食物桶数 |  |  [`贪心`](/tag/greedy.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters) [🔗](https://leetcode.com/problems/minimum-number-of-food-buckets-to-feed-the-hamsters) |