---
title: 1778. 未知网格中的最短路径 🔒
description: LeetCode,1778. 未知网格中的最短路径 🔒,未知网格中的最短路径,Shortest Path in a Hidden Grid,解题思路,深度优先搜索,广度优先搜索,图,交互
keywords:
  - LeetCode
  - 1778. 未知网格中的最短路径 🔒
  - 未知网格中的最短路径
  - Shortest Path in a Hidden Grid
  - 解题思路
  - 深度优先搜索
  - 广度优先搜索
  - 图
  - 交互
---

# 1778. 未知网格中的最短路径 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) [`交互`](/tag/interactive.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/shortest-path-in-a-hidden-grid) [`LeetCode`](https://leetcode.com/problems/shortest-path-in-a-hidden-grid)

## 题目

This is an **interactive problem**.

There is a robot in a hidden grid, and you are trying to get it from its
starting cell to the target cell in this grid. The grid is of size `m x n`,
and each cell in the grid is either empty or blocked. It is **guaranteed**
that the starting cell and the target cell are different, and neither of them
is blocked.

You want to find the minimum distance to the target cell. However, you **do
not know** the grid's dimensions, the starting cell, nor the target cell. You
are only allowed to ask queries to the `GridMaster` object.

Thr `GridMaster` class has the following functions:

  * `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.
  * `void move(char direction)` Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored** , and the robot will remain in the same position.
  * `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from
`{'U','D','L','R'}`, representing the directions up, down, left, and right,
respectively.

Return _the**minimum distance** between the robot's initial starting cell and
the target cell. If there is no valid path between the cells, return _`-1`.

**Custom testing:**

The test input is read as a 2D matrix `grid` of size `m x n` where:

  * `grid[i][j] == -1` indicates that the robot is in cell `(i, j)` (the starting cell).
  * `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.
  * `grid[i][j] == 1` indicates that the cell `(i, j)` is empty.
  * `grid[i][j] == 2` indicates that the cell `(i, j)` is the target cell.

There is exactly one `-1` and `2` in `grid`. Remember that you will **not**
have this information in your code.



**Example 1:**

> Input: grid = [[1,2],[-1,0]]
> 
> Output: 2
> 
> Explanation: One possible interaction is described below:
> 
> The robot is initially standing on cell (1, 0), denoted by the -1.
> - master.canMove('U') returns true.
> - master.canMove('D') returns false.
> - master.canMove('L') returns false.
> - master.canMove('R') returns false.
> - master.move('U') moves the robot to the cell (0, 0).
> - master.isTarget() returns false.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns false.
> - master.canMove('R') returns true.
> - master.move('R') moves the robot to the cell (0, 1).
> - master.isTarget() returns true. 
> 
> We now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.

**Example 2:**

> Input: grid = [[0,0,-1],[1,1,1],[2,0,0]]
> 
> Output: 4
> 
> Explanation:  The minimum distance between the robot and the target cell is 4.

**Example 3:**

> Input: grid = [[-1,0],[0,2]]
> 
> Output: -1
> 
> Explanation:  There is no path from the robot to the target cell.



**Constraints:**

  * `1 <= n, m <= 500`
  * `m == grid.length`
  * `n == grid[i].length`
  * `grid[i][j]` is either `-1`, `0`, `1`, or `2`.
  * There is **exactly one** `-1` in `grid`.
  * There is **exactly one** `2` in `grid`.


## 题目大意

这是一个**交互式的问题。**

一个未知的网格里有一个机器人，你需要让机器人从起点走到终点。这个网格的大小是 `m x
n`，网格中的每个位置只会是可通行和不可通行两种状态。题目**保证** 机器人的起点和终点不同，且都是可通行的。

你需要找到起点到终点的最短路径，然而你**不知道** 网格的大小、起点和终点。你只能向 `GridMaster` 对象查询。

`GridMaster`有这些方法：

  * `boolean canMove(char direction)` 当机器人能向对应方向移动时，返回 `true`，否则返回 `false`。
  * `void move(char direction)` 把机器人向这个方向移动。如果移动方向上是不可通行的或是网格的边界，则这次移动会被**忽略** ，机器人会待在原地。
  * `boolean isTarget()` 如果机器人当前位于终点，返回 `true`，否则返回 `false`。

注意上述方法中的direction应该是 `{'U','D','L','R'}` 中的一个，分别代表上下左右四个方向。

返回机器人的初始位置到终点的最短距离。如果在起点和终点间没有路径联通，返回 `-1`。

**自定义测试用例**

测试用例是一个 `m x n` 的二维矩阵 `grid`，其中：

  * `grid[i][j] == -1` 表明机器人一开始位于位置 `(i, j)` （即起点）。
  * `grid[i][j] == 0` 表明位置 `(i, j)` 不可通行。
  * `grid[i][j] == 1` 表明位置 `(i, j)` 可以通行.
  * `grid[i][j] == 2` 表明位置 `(i, j)` 是终点.

`grid` 里恰有一个`-1` 和一个 `2`。记住在你的代码中，你对这些信息将**一无所知** 。

**示例1：**

> 
> 
> 
> 
> 
> **输入:** grid = [[1,2],[-1,0]]
> 
> **输出:** 2
> 
> **解释:** 一种可能的交互过程如下：
> 
> The robot is initially standing on cell (1, 0), denoted by the -1.
> - master.canMove('U') 返回 true.
> - master.canMove('D') 返回false.
> - master.canMove('L') 返回 false.
> - master.canMove('R') 返回 false.
> - master.move('U') 把机器人移动到 (0, 0).
> - master.isTarget() 返回 false.
> - master.canMove('U') 返回 false.
> - master.canMove('D') 返回 true.
> - master.canMove('L') 返回 false.
> - master.canMove('R') 返回 true.
> - master.move('R') 把机器人移动到 (0, 1).
> - master.isTarget() 返回 true. 
> 
> 我们现在知道终点是点 (0, 1)，而且最短的路径是2.
> 
> 

**示例2:**

> 
> 
> 
> 
> 
> **输入:** grid = [[0,0,-1],[1,1,1],[2,0,0]]
> 
> **输出:** 4
> 
> **解释:** 机器人和终点的最短路径长是4.

**示例3:**

> 
> 
> 
> 
> 
> **输入:** grid = [[-1,0],[0,2]]
> 
> **输出:** -1
> 
> **解释:** 机器人和终点间没有可通行的路径.

**提示：**

  * `1 <= n, m <= 500`
  * `m == grid.length`
  * `n == grid[i].length`
  * `grid[i][j]` 只可能是 `-1`, `0`, `1` 或 `2`
  * `grid` 中 **有且只有一个** `-1`
  * `grid` 中**有且只有一个** `2`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 489 | 扫地机器人 🔒 |  |  [`回溯`](/tag/backtracking.md) [`交互`](/tag/interactive.md) | <font color=#ff334b>Hard</font> | [🀄️](https://leetcode.cn/problems/robot-room-cleaner) [🔗](https://leetcode.com/problems/robot-room-cleaner) |
| 1810 | 隐藏网格下的最小消耗路径 🔒 |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `2+` | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid) [🔗](https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid) |