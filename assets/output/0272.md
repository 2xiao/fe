---
title: 272. 最接近的二叉搜索树值 II 🔒
description: LeetCode,272. 最接近的二叉搜索树值 II 🔒,最接近的二叉搜索树值 II,Closest Binary Search Tree Value II,解题思路,栈,树,深度优先搜索,二叉搜索树,双指针,二叉树,堆（优先队列）
keywords:
  - LeetCode
  - 272. 最接近的二叉搜索树值 II 🔒
  - 最接近的二叉搜索树值 II
  - Closest Binary Search Tree Value II
  - 解题思路
  - 栈
  - 树
  - 深度优先搜索
  - 二叉搜索树
  - 双指针
  - 二叉树
  - 堆（优先队列）
---

# 272. 最接近的二叉搜索树值 II 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`双指针`](/tag/two-pointers.md) [`二叉树`](/tag/binary-tree.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/closest-binary-search-tree-value-ii) [`LeetCode`](https://leetcode.com/problems/closest-binary-search-tree-value-ii)

## 题目

Given the `root` of a binary search tree, a `target` value, and an integer
`k`, return _the_`k` _values in the BST that are closest to the_ `target`. You
may return the answer in **any order**.

You are **guaranteed** to have only one unique set of `k` values in the BST
that are closest to the `target`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0272.Closest%20Binary%20Search%20Tree%20Value%20II/images/closest1-1-tree.jpg)

> Input: root = [4,2,5,1,3], target = 3.714286, k = 2
> 
> Output: [4,3]

**Example 2:**

> Input: root = [1], target = 0.000000, k = 1
> 
> Output: [1]

**Constraints:**

  * The number of nodes in the tree is `n`.
  * `1 <= k <= n <= 10^4`.
  * `0 <= Node.val <= 10^9`
  * `-10^9 <= target <= 10^9`



**Follow up:** Assume that the BST is balanced. Could you solve it in less
than `O(n)` runtime (where `n = total nodes`)?


## 题目大意

给定二叉搜索树的根 `root` 、一个目标值 `target` 和一个整数 `k` ，返回BST中最接近目标的 `k` 个值。你可以按 **任意顺序**
返回答案。

题目 **保证**  该二叉搜索树中只会存在一种 k 个值集合最接近 `target`



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0272.Closest%20Binary%20Search%20Tree%20Value%20II/images/closest1-1-tree.jpg)

> 
> 
> 
> 
> 
> **输入:** root = [4,2,5,1,3]，目标值 = 3.714286，且 _k_ = 2
> 
> **输出:** [4,3]

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** root = [1], target = 0.000000, k = 1
> 
> **输出:** [1]
> 
> 



**提示：**

  * 二叉树的节点总数为 `n`
  * `1 <= k <= n <= 10^4`
  * `0 <= Node.val <= 10^9`
  * `-10^9 <= target <= 10^9`



**进阶：** 假设该二叉搜索树是平衡的，请问您是否能在小于 `O(n)`（ `n = total nodes` ）的时间复杂度内解决该问题呢？


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 94 | 二叉树的中序遍历 | [[✓]](/problem/0094.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `1+` | 🟢 | [🀄️](https://leetcode.cn/problems/binary-tree-inorder-traversal) [🔗](https://leetcode.com/problems/binary-tree-inorder-traversal) |
| 270 | 最接近的二叉搜索树值 🔒 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `2+` | 🟢 | [🀄️](https://leetcode.cn/problems/closest-binary-search-tree-value) [🔗](https://leetcode.com/problems/closest-binary-search-tree-value) |
| 2476 | 二叉搜索树最近节点查询 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `3+` | 🟠 | [🀄️](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree) [🔗](https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree) |