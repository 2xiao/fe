---
title: 2981. 找出出现至少三次的最长特殊子字符串 I
description: LeetCode 2981. 找出出现至少三次的最长特殊子字符串 I题解，Find Longest Special Substring That Occurs Thrice I，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 2981. 找出出现至少三次的最长特殊子字符串 I
  - 找出出现至少三次的最长特殊子字符串 I
  - Find Longest Special Substring That Occurs Thrice I
  - 解题思路
  - 哈希表
  - 字符串
  - 二分查找
  - 计数
  - 滑动窗口
---

# 2981. 找出出现至少三次的最长特殊子字符串 I

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`二分查找`](/tag/binary-search.md) [`计数`](/tag/counting.md) [`滑动窗口`](/tag/sliding-window.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i) [`LeetCode`](https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i)

## 题目

You are given a string `s` that consists of lowercase English letters.

A string is called **special** if it is made up of only a single character.
For example, the string `"abc"` is not special, whereas the strings `"ddd"`,
`"zz"`, and `"f"` are special.

Return _the length of the**longest special substring** of _`s` _which
occurs**at least thrice**_ , _or_`-1` _if no special substring occurs at least
thrice_.

A **substring** is a contiguous **non-empty** sequence of characters within a
string.

**Example 1:**

> Input: s = "aaaa"
>
> Output: 2
>
> Explanation: The longest special substring which occurs thrice is "aa": substrings "_**aa**_ aa", "a _**aa**_ a", and "aa _**aa**_ ".
>
> It can be shown that the maximum length achievable is 2.

**Example 2:**

> Input: s = "abcdef"
>
> Output: -1
>
> Explanation: There exists no special substring which occurs at least thrice. Hence return -1.

**Example 3:**

> Input: s = "abcaba"
>
> Output: 1
>
> Explanation: The longest special substring which occurs thrice is "a": substrings "_**a**_ bcaba", "abc _**a**_ ba", and "abcab _**a**_ ".
>
> It can be shown that the maximum length achievable is 1.

**Constraints:**

- `3 <= s.length <= 50`
- `s` consists of only lowercase English letters.

## 题目大意

给你一个仅由小写英文字母组成的字符串 `s` 。

如果一个字符串仅由单一字符组成，那么它被称为 **特殊** 字符串。例如，字符串 `"abc"` 不是特殊字符串，而字符串 `"ddd"`、`"zz"` 和
`"f"` 是特殊字符串。

返回在 `s` 中出现 **至少三次** 的**最长特殊子字符串** 的长度，如果不存在出现至少三次的特殊子字符串，则返回 `-1` 。

**子字符串** 是字符串中的一个连续**非空** 字符序列。

**示例 1：**

> **输入：** s = "aaaa"
>
> **输出：** 2
>
> **解释：** 出现三次的最长特殊子字符串是 "aa" ：子字符串 "_**aa**_ aa"、"a _**aa**_ a" 和 "aa _**aa**_ "。
>
> 可以证明最大长度是 2 。

**示例 2：**

> **输入：** s = "abcdef"
>
> **输出：** -1
>
> **解释：** 不存在出现至少三次的特殊子字符串。因此返回 -1 。

**示例 3：**

> **输入：** s = "abcaba"
>
> **输出：** 1
>
> **解释：** 出现三次的最长特殊子字符串是 "a" ：子字符串 "_**a**_ bcaba"、"abc _**a**_ ba" 和 "abcab _**a**_ "。
>
> 可以证明最大长度是 1 。

**提示：**

- `3 <= s.length <= 50`
- `s` 仅由小写英文字母组成。

## 解题思路

### 思路一：暴力遍历

1. **遍历子串长度：**
   - 从最长可能的长度开始遍历，逐步检查是否存在符合条件的特殊子串。
2. **检查特殊字符串：**

   - 使用 `new Set(sub).size` 检查子串是否由单一字符组成。
   - 如果 `size === 1`，表示子串为特殊字符串。

3. **统计子串出现次数：**

   - 利用 `Map` 数据结构记录每个特殊子串的出现次数。
   - 遍历完成后，检查是否有子串的出现次数达到 3 次以上。

4. **返回结果：**
   - 如果找到满足条件的子串，返回其长度。
   - 如果没有找到，返回 `-1`。

#### 复杂度分析

- **时间复杂度：** `O(n^3)`

  - 外层循环遍历可能的子串长度，从最大值逐步减少，最多为 `O(n)`。
  - 内层遍历所有子串，最多为 `O(n^2)`。
  - 检查特殊字符串的过程为 `O(k)`，其中 `k` 为子串长度。
  - 总时间复杂度为 `O(n^3)`。

- **空间复杂度：** `O(n^2)`
  - 使用 `Map` 记录子串的出现次数，最差情况下存储所有子串，空间复杂度为 `O(n^2)`。

这段代码效率较低，对于较大输入可能会超时，可以进一步优化。

---

### 思路二：双指针

1. **定义判断函数 `isValid`**

用一个辅助函数 `isValid(len)` 检查是否存在长度为 `len` 的特殊子字符串，且该子字符串至少出现 3 次。

具体逻辑如下：

- 使用一个 `count` 数组，记录每个字符的特殊子字符串出现次数。
- 使用双指针 `p, i`，维护子字符串的起始和结束位置：
  - 移动 `p` 直到 `s[i] === s[p]`，从而找到以 `s[i]` 为单一字符组成的连续子字符串的起点。
  - 如果当前子字符串长度 `i - p + 1 >= len`，说明可以把这段子字符串作为长度为 `len` 的特殊子字符串，增加计数。
- 如果任意字符的计数达到 3，则返回 `true`，说明存在满足条件的子字符串。

2. **从大到小尝试长度**

由于我们要找的是最长的特殊子字符串长度，因此：

1. 从最大可能长度 `s.length - 2` 开始尝试，逐渐减小长度。
2. 对于每一个长度 `len`，调用 `isValid(len)` 检查是否满足条件：

   - 如果满足，直接返回 `len`。
   - 否则继续尝试更短的长度，直到 `len = 1`。

3. **终止条件**

如果遍历完所有长度都不满足，返回 `-1`。

#### 复杂度分析

- **时间复杂度：** `O(n^2)`

  - 外层循环从最大长度到最小长度，最多进行 `O(n)` 次。
  - 内部 `isValid` 函数，双指针扫描整个字符串，每个字符最多访问两次，复杂度为 `O(n)`。
  - 总时间复杂度为 `O(n^2)`。

- **空间复杂度：** `O(1)`
  - 使用 `count` 数组记录每个字符的特殊子字符串出现次数，大小固定为 26，空间复杂度为 `O(1)`。
  - 其他变量占用常量空间。

---

### 思路三：二分查找 + 双指针

在思路二的基础上，我们可以使用二分查找确定最长特殊子字符串的长度：

- 初始范围为 `1` 到字符串长度 `s.length`。
- 通过中点 `mid` 分割：
  - 如果长度为 `mid` 的特殊子字符串满足条件，则更新左边界 `left = mid - 1`。
  - 否则更新右边界 `right = mid + 1`。
- 二分结束后，`right` 即为满足条件的最大长度，注意不是 `left`，因为在每次迭代中都排除了 `mid`，而 `mid` 本身也可以是答案之一。
- 特殊情况处理：如果长度为 1 的特殊子字符串都不存在（即 `isValid(1)` 返回 `false`），直接返回 `-1`。

#### 复杂度分析

- **时间复杂度：** `O(n * log n)`

  - 二分查找，复杂度为 `O(log n)` 。
  - 内部 `isValid` 函数，双指针扫描整个字符串，每个字符最多访问两次，复杂度为 `O(n)`。
  - 总时间复杂度为 `O(n * log n)`。

- **空间复杂度：** `O(1)`
  - 使用 `count` 数组记录每个字符的特殊子字符串出现次数，大小固定为 26，空间复杂度为 `O(1)`。
  - 其他变量占用常量空间。

## 代码

::: code-tabs

@tab 暴力遍历

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maximumLength = function (s) {
	let minRange = 1,
		maxRange = s.length - 2;

	for (let len = maxRange; len >= minRange; len--) {
		let map = new Map();

		// 遍历所有长度为 len 的子串
		for (let j = 0; j <= s.length - len; j++) {
			let sub = s.substring(j, j + len);

			// 检查子串是否是特殊字符串（由单一字符组成）
			if (new Set(sub).size === 1) {
				map.set(sub, (map.get(sub) || 0) + 1);
			}
		}

		// 检查是否有子串出现至少 3 次
		for (let key of map.keys()) {
			if (map.get(key) >= 3) {
				return len;
			}
		}
	}

	return -1;
};
```

@tab 双指针

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maximumLength = function (s) {
	// 判断长度为 len 的特殊子字符串是否满足条件
	const isValid = (len) => {
		let count = new Array(26).fill(0);
		let p = 0;
		for (let i = 0; i < s.length; i++) {
			const char = s[i].charCodeAt() - 'a'.charCodeAt();
			// 移动指针 p，确保子字符串以单一字符组成
			while (s[i] !== s[p]) p++;
			// 如果当前子字符串长度 >= len，增加计数
			if (i - p + 1 >= len) {
				count[char]++;
			}
			// 如果出现至少 3 次，返回 true
			if (count[char] >= 3) {
				return true;
			}
		}
		// 未找到符合条件的子字符串
		return false;
	};

	let minRange = 1,
		maxRange = s.length - 2;

	// 从大到小尝试长度
	for (let len = maxRange; len >= minRange; len--) {
		if (isValid(len)) return len;
	}

	// 如果没有找到，返回 -1
	return -1;
};
```

@tab 二分查找 + 双指针

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var maximumLength = function (s) {
	// 判断长度为 len 的特殊子字符串是否满足条件
	const isValid = (len) => {
		let count = new Array(26).fill(0);
		let p = 0;
		for (let i = 0; i < s.length; i++) {
			const char = s[i].charCodeAt() - 'a'.charCodeAt();
			// 移动指针 p，确保子字符串以单一字符组成
			while (s[i] !== s[p]) p++;
			// 如果当前子字符串长度 >= len，增加计数
			if (i - p + 1 >= len) {
				count[char]++;
			}
			// 如果出现至少 3 次，返回 true
			if (count[char] >= 3) {
				return true;
			}
		}
		// 未找到符合条件的子字符串
		return false;
	};

	// 特殊情况处理：如果长度为 1 的特殊子字符串都不存在，直接返回 -1
	if (!isValid(1)) return -1;

	// 二分查找
	let left = 1,
		right = s.length;

	while (left <= right) {
		const mid = ((left + right) / 2) | 0;
		if (isValid(mid)) {
			// 更新左边界
			left = mid + 1;
		} else {
			// 更新右边界
			right = mid - 1;
		}
	}

	return right;
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 3 | 无重复字符的最长子串 | [[✓]](/problem/0003.md) |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`滑动窗口`](/tag/sliding-window.md) | 🟠 | [🀄️](https://leetcode.cn/problems/longest-substring-without-repeating-characters) [🔗](https://leetcode.com/problems/longest-substring-without-repeating-characters) |
| 395 | 至少有 K 个重复字符的最长子串 |  |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`分治`](/tag/divide-and-conquer.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters) [🔗](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters) |
