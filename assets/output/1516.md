---
title: 1516. 移动 N 叉树的子树 🔒
description: LeetCode 1516. 移动 N 叉树的子树 🔒题解，Move Sub-Tree of N-Ary Tree，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1516. 移动 N 叉树的子树 🔒
  - 移动 N 叉树的子树
  - Move Sub-Tree of N-Ary Tree
  - 解题思路
  - 树
  - 深度优先搜索
---

# 1516. 移动 N 叉树的子树 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree) [`LeetCode`](https://leetcode.com/problems/move-sub-tree-of-n-ary-tree)

## 题目

Given the `root` of an N-ary tree of unique values, and two nodes of the tree
`p` and `q`.

You should move the subtree of the node `p` to become a direct child of node
`q`. If `p` is already a direct child of `q`, do not change anything. Node `p`
**must be** the last child in the children list of node `q`.

Return _the root of the tree_ after adjusting it.



There are 3 cases for nodes `p` and `q`:

  1. Node `q` is in the sub-tree of node `p`.
  2. Node `p` is in the sub-tree of node `q`.
  3. Neither node `p` is in the sub-tree of node `q` nor node `q` is in the sub-tree of node `p`.

In cases 2 and 3, you just need to move `p` (with its sub-tree) to be a child
of `q`, but in case 1 the tree may be disconnected, thus you need to reconnect
the tree again. **Please read the examples carefully before solving this
problem.**



_Nary-Tree input serialization is represented in their level order traversal,
each group of children is separated by the null value (See examples)._

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/sample_4_964.png)

For example, the above tree is serialized as
`[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e1.jpg)

> Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
> 
> Output: [1,null,2,3,4,null,5,null,6,null,7,8]
> 
> Explanation: This example follows the second case as node p is in the sub-tree of node q. We move node p with its sub-tree to be a direct child of node q.
> 
> Notice that node 4 is the last child of node 1.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e2.jpg)

> Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
> 
> Output: [1,null,2,3,null,4,5,null,6,null,7,8]
> 
> Explanation: Node 7 is already a direct child of node 4. We don't change anything.

**Example 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e3.jpg)

> Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
> 
> Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
> 
> Explanation: This example follows case 3 because node p is not in the sub-tree of node q and vice-versa. We can move node 3 with its sub-tree and make it as node 8's child.

**Constraints:**

  * The total number of nodes is between `[2, 1000]`.
  * Each node has a **unique** value.
  * `p != null`
  * `q != null`
  * `p` and `q` are two different nodes (i.e. `p != q`).


## 题目大意

给定一棵没有重复值的 N 叉树 的根节点 `root` ，以及其中的两个节点 `p` 和 `q`。

移动节点 `p` 及其子树，使节点 `p` 成为节点 `q` 的直接子节点。如果 `p` 已经是 `q` 的直接子节点，则请勿改动任何节点。节点 `p`
**必须** 是节点 `q` 的子节点列表的最后一项。

返回改动后的 _树的根节点_ 。



节点 `p` 和 `q` 可能是下列三种情况之一：

  1. 节点 `q` 在节点 `p` 的子树中。
  2. 节点 `p` 在节点 `q` 的子树中。
  3. 节点 `p` 不在节点 `q` 的子树中，且节点 `q` 也不在节点 `p` 的子树中。

在第 2 种和第 3 种情况中，你只需要移动 `p` （及其子树），使 `p` 成为 `q` 的子节点。但是在第 1
种情况中，树的节点可能会断连，因此你还需要重新连接这些节点。**请在解题前仔细阅读示例。**



_N 叉树的输入序列以层序遍历的形式给出，每组子节点用 null 分隔（见示例）。_

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/sample_4_964.png)

例如，上面的树会被序列化为
[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]。



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e1.jpg)

> 
> 
> 
> 
> 
> **输入:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
> 
> **输出:** [1,null,2,3,4,null,5,null,6,null,7,8]
> 
> **解释:** 该示例属于第二种情况，节点 p 在节点 q 的子树中。我们可以移动节点 p 及其子树，使 p 成为节点 q 的直接子节点。
> 
> 注意，节点 4 是节点 1 的最后一个子节点。

**示例 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e2.jpg)

> 
> 
> 
> 
> 
> **输入:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
> 
> **输出:** [1,null,2,3,null,4,5,null,6,null,7,8]
> 
> **解释:** 节点 7 已经是节点 4 的直接子节点，因此我们不改动任何节点。
> 
> 

**示例 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1516.Move%20Sub-
Tree%20of%20N-Ary%20Tree/images/move_e3.jpg)

> 
> 
> 
> 
> 
> **输入:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
> 
> **输出:** [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
> 
> **解释:** 该示例属于第三种情况，节点 p 不在节点 q 的子树中，反之亦然。我们可以移动节点 3 及其子树，使之成为节点 8 的子节点。
> 
> 



**提示:**

  * 节点的总数在 `[2, 1000]` 间。
  * 每个节点都有 **唯一  **的值。
  * `p != null`
  * `q != null`
  * `p` 和 `q` 是两个不同的节点（即 `p != q` ）。




## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1506 | 找到 N 叉树的根节点 🔒 |  |  [`位运算`](/tag/bit-manipulation.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/find-root-of-n-ary-tree) [🔗](https://leetcode.com/problems/find-root-of-n-ary-tree) |