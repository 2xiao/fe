---
title: 302. 包含全部黑色像素的最小矩形 🔒
description: LeetCode,302. 包含全部黑色像素的最小矩形 🔒,包含全部黑色像素的最小矩形,Smallest Rectangle Enclosing Black Pixels,解题思路,深度优先搜索,广度优先搜索,数组,二分查找,矩阵
keywords:
  - LeetCode
  - 302. 包含全部黑色像素的最小矩形 🔒
  - 包含全部黑色像素的最小矩形
  - Smallest Rectangle Enclosing Black Pixels
  - 解题思路
  - 深度优先搜索
  - 广度优先搜索
  - 数组
  - 二分查找
  - 矩阵
---

# 302. 包含全部黑色像素的最小矩形 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) [`矩阵`](/tag/matrix.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/smallest-rectangle-enclosing-black-pixels) [`LeetCode`](https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels)

## 题目

You are given an `m x n` binary matrix `image` where `0` represents a white
pixel and `1` represents a black pixel.

The black pixels are connected (i.e., there is only one black region). Pixels
are connected horizontally and vertically.

Given two integers `x` and `y` that represents the location of one of the
black pixels, return _the area of the smallest (axis-aligned) rectangle that
encloses all black pixels_.

You must write an algorithm with less than `O(mn)` runtime complexity



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0302.Smallest%20Rectangle%20Enclosing%20Black%20Pixels/images/pixel-
grid.jpg)

> Input: image = [["0","0","1","0"],["0","1","1","0"],["0","1","0","0"]], x = 0, y = 2
> 
> Output: 6

**Example 2:**

> Input: image = [["1"]], x = 0, y = 0
> 
> Output: 1

**Constraints:**

  * `m == image.length`
  * `n == image[i].length`
  * `1 <= m, n <= 100`
  * `image[i][j]` is either `'0'` or `'1'`.
  * `0 <= x < m`
  * `0 <= y < n`
  * `image[x][y] == '1'.`
  * The black pixels in the `image` only form **one component**.


## 题目大意

图片在计算机处理中往往是使用二维矩阵来表示的。

给你一个大小为 `m x n` 的二进制矩阵 `image` 表示一张黑白图片，`0` 代表白色像素，`1` 代表黑色像素。

黑色像素相互连接，也就是说，图片中只会有一片连在一块儿的黑色像素。像素点是水平或竖直方向连接的。

给你两个整数 `x` 和 `y` 表示某一个黑色像素的位置，请你找出包含全部黑色像素的最小矩形（与坐标轴对齐），并返回该矩形的面积。

你必须设计并实现一个时间复杂度低于 `O(mn)` 的算法来解决此问题。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0302.Smallest%20Rectangle%20Enclosing%20Black%20Pixels/images/pixel-
grid.jpg)

> 
> 
> 
> 
> 
> **输入：** image = [["0","0","1","0"],["0","1","1","0"],["0","1","0","0"]], x = 0, y = 2
> 
> **输出：** 6
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** image = [["1"]], x = 0, y = 0
> 
> **输出：** 1
> 
> 



**提示：**

  * `m == image.length`
  * `n == image[i].length`
  * `1 <= m, n <= 100`
  * `image[i][j]` 为 `'0'` 或 `'1'`
  * `1 <= x < m`
  * `1 <= y < n`
  * `image[x][y] == '1'`
  * `image` 中的黑色像素仅形成一个 **组件**


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 3195 | [包含所有 1 的最小矩形面积 I](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i) |  |  [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | <font color=#ffb800>Medium</font> |
| 3197 | [包含所有 1 的最小矩形面积 II](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii) |  |  [`数组`](/tag/array.md) [`枚举`](/tag/enumeration.md) [`矩阵`](/tag/matrix.md) | <font color=#ff334b>Hard</font> |