# [444. 序列重建](https://leetcode.com/problems/sequence-reconstruction)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`图`](/tag/graph.md) [`拓扑排序`](/tag/topological-sort.md) [`数组`](/tag/array.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/sequence-reconstruction)

## 题目

You are given an integer array `nums` of length `n` where `nums` is a
permutation of the integers in the range `[1, n]`. You are also given a 2D
integer array `sequences` where `sequences[i]` is a subsequence of `nums`.

Check if `nums` is the shortest possible and the only **supersequence**. The
shortest **supersequence** is a sequence **with the shortest length** and has
all `sequences[i]` as subsequences. There could be multiple valid
**supersequences** for the given array `sequences`.

  * For example, for `sequences = [[1,2],[1,3]]`, there are two shortest **supersequences** , `[1,2,3]` and `[1,3,2]`.
  * While for `sequences = [[1,2],[1,3],[1,2,3]]`, the only shortest **supersequence** possible is `[1,2,3]`. `[1,2,3,4]` is a possible supersequence but not the shortest.

Return `true` _if_`nums` _is the only shortest**supersequence** for
_`sequences` _, or_`false` _otherwise_.

A **subsequence** is a sequence that can be derived from another sequence by
deleting some or no elements without changing the order of the remaining
elements.



**Example 1:**

> Input: nums = [1,2,3], sequences = [[1,2],[1,3]]
> 
> Output: false
> 
> Explanation: There are two possible supersequences: [1,2,3] and [1,3,2].
> 
> The sequence [1,2] is a subsequence of both: [**_1_** ,**_2_** ,3] and [**_1_** ,3,**_2_**].
> 
> The sequence [1,3] is a subsequence of both: [**_1_** ,2,**_3_**] and [**_1_** ,**_3_** ,2].
> 
> Since nums is not the only shortest supersequence, we return false.

**Example 2:**

> Input: nums = [1,2,3], sequences = [[1,2]]
> 
> Output: false
> 
> Explanation: The shortest possible supersequence is [1,2].
> 
> The sequence [1,2] is a subsequence of it: [**_1_** ,**_2_**].
> 
> Since nums is not the shortest supersequence, we return false.

**Example 3:**

> Input: nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
> 
> Output: true
> 
> Explanation: The shortest possible supersequence is [1,2,3].
> 
> The sequence [1,2] is a subsequence of it: [**_1_** ,**_2_** ,3].
> 
> The sequence [1,3] is a subsequence of it: [**_1_** ,2,**_3_**].
> 
> The sequence [2,3] is a subsequence of it: [1,**_2_** ,**_3_**].
> 
> Since nums is the only shortest supersequence, we return true.

**Constraints:**

  * `n == nums.length`
  * `1 <= n <= 10^4`
  * `nums` is a permutation of all the integers in the range `[1, n]`.
  * `1 <= sequences.length <= 10^4`
  * `1 <= sequences[i].length <= 10^4`
  * `1 <= sum(sequences[i].length) <= 10^5`
  * `1 <= sequences[i][j] <= n`
  * All the arrays of `sequences` are **unique**.
  * `sequences[i]` is a subsequence of `nums`.


## 题目大意

给定一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 是范围为 `[1，n]` 的整数的排列。还提供了一个 2D 整数数组
`sequences` ，其中 `sequences[i]` 是 `nums` 的子序列。  
检查 `nums` 是否是唯一的最短 **超序列** 。最短 **超序列** 是 **长度最短** 的序列，并且所有序列 `sequences[i]`
都是它的子序列。对于给定的数组 `sequences` ，可能存在多个有效的 **超序列** 。

  * 例如，对于 `sequences = [[1,2],[1,3]]` ，有两个最短的 **超序列** ，`[1,2,3]` 和 `[1,3,2]` 。
  * 而对于 `sequences = [[1,2],[1,3],[1,2,3]]` ，唯一可能的最短 **超序列** 是 `[1,2,3]` 。`[1,2,3,4]` 是可能的超序列，但不是最短的。

_如果`nums` 是序列的唯一最短 **超序列** ，则返回 `true` ，否则返回 `false` 。_  
**子序列** 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** nums = [1,2,3], sequences = [[1,2],[1,3]]
> 
> **输出：** false
> 
> **解释：** 有两种可能的超序列：[1,2,3]和[1,3,2]。
> 
> 序列 [1,2] 是[_**1,2**_ ,3]和[_**1**_ ,3,_**2**_]的子序列。
> 
> 序列 [1,3] 是[_**1**_ ,2,_**3**_]和[_**1,3**_ ,2]的子序列。
> 
> 因为 nums 不是唯一最短的超序列，所以返回false。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** nums = [1,2,3], sequences = [[1,2]]
> 
> **输出：** false
> 
> **解释：** 最短可能的超序列为 [1,2]。
> 
> 序列 [1,2] 是它的子序列：[_**1,2**_]。
> 
> 因为 nums 不是最短的超序列，所以返回false。
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
> 
> **输出：** true
> 
> **解释：** 最短可能的超序列为[1,2,3]。
> 
> 序列 [1,2] 是它的一个子序列：[**1,2** ,3]。
> 
> 序列 [1,3] 是它的一个子序列：[_**1**_ ,2,_**3**_]。
> 
> 序列 [2,3] 是它的一个子序列：[1,_**2,3**_]。
> 
> 因为 nums 是唯一最短的超序列，所以返回true。



**提示：**

  * `n == nums.length`
  * `1 <= n <= 10^4`
  * `nums` 是 `[1, n]` 范围内所有整数的排列
  * `1 <= sequences.length <= 10^4`
  * `1 <= sequences[i].length <= 10^4`
  * `1 <= sum(sequences[i].length) <= 10^5`
  * `1 <= sequences[i][j] <= n`
  * `sequences` 的所有数组都是 **唯一** 的
  * `sequences[i]` 是 `nums` 的一个子序列


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 210 | [课程表 II](https://leetcode.com/problems/course-schedule-ii) | [[✓]](/problem/0210.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> |