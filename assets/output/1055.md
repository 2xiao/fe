---
title: 1055. 形成字符串的最短路径 🔒
description: LeetCode 1055. 形成字符串的最短路径 🔒题解，Shortest Way to Form String，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1055. 形成字符串的最短路径 🔒
  - 形成字符串的最短路径
  - Shortest Way to Form String
  - 解题思路
  - 贪心
  - 双指针
  - 字符串
  - 二分查找
---

# 1055. 形成字符串的最短路径 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) [`二分查找`](/tag/binary-search.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/shortest-way-to-form-string) [`LeetCode`](https://leetcode.com/problems/shortest-way-to-form-string)

## 题目

A **subsequence** of a string is a new string that is formed from the original
string by deleting some (can be none) of the characters without disturbing the
relative positions of the remaining characters. (i.e., `"ace"` is a
subsequence of `"_a_ b _c_ d _e_ "` while `"aec"` is not).

Given two strings `source` and `target`, return _the minimum number
of**subsequences** of _`source` _such that their concatenation
equals_`target`. If the task is impossible, return `-1`.



**Example 1:**

> Input: source = "abc", target = "abcbc"
> 
> Output: 2
> 
> Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".

**Example 2:**

> Input: source = "abc", target = "acdbc"
> 
> Output: -1
> 
> Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.

**Example 3:**

> Input: source = "xyz", target = "xzyxz"
> 
> Output: 3
> 
> Explanation: The target string can be constructed as follows "xz" + "y" + "xz".

**Constraints:**

  * `1 <= source.length, target.length <= 1000`
  * `source` and `target` consist of lowercase English letters.


## 题目大意

对于任何字符串，我们可以通过删除其中一些字符（也可能不删除）来构造该字符串的 **子序列** 。(例如，`“ace”` 是 `“abcde”` 的子序列，而
`“aec”` 不是)。

给定源字符串 `source` 和目标字符串 `target`，返回 _源字符串  `source` 中能通过串联形成目标字符串 _`target`
_的**子序列** 的最小数量 _。如果无法通过串联源字符串中的子序列来构造目标字符串，则返回 `-1`。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** source = "abc", target = "abcbc"
> 
> **输出：** 2
> 
> **解释：** 目标字符串 "abcbc" 可以由 "abc" 和 "bc" 形成，它们都是源字符串 "abc" 的子序列。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** source = "abc", target = "acdbc"
> 
> **输出：** -1
> 
> **解释：** 由于目标字符串中包含字符 "d"，所以无法由源字符串的子序列构建目标字符串。
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** source = "xyz", target = "xzyxz"
> 
> **输出：** 3
> 
> **解释：** 目标字符串可以按如下方式构建： "xz" + "y" + "xz"。
> 
> 



**提示：**

  * `1 <= source.length, target.length <= 1000`
  * `source` 和 `target` 仅包含英文小写字母。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 392 | 判断子序列 | [[✓]](/problem/0392.md) |  [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md) | 🟢 | [🀄️](https://leetcode.cn/problems/is-subsequence) [🔗](https://leetcode.com/problems/is-subsequence) |
| 792 | 匹配子序列的单词数 |  |  [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) `4+` | 🟠 | [🀄️](https://leetcode.cn/problems/number-of-matching-subsequences) [🔗](https://leetcode.com/problems/number-of-matching-subsequences) |