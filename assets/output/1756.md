---
title: 1756. 设计最近使用（MRU）队列 🔒
description: LeetCode 1756. 设计最近使用（MRU）队列 🔒题解，Design Most Recently Used Queue，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1756. 设计最近使用（MRU）队列 🔒
  - 设计最近使用（MRU）队列
  - Design Most Recently Used Queue
  - 解题思路
  - 栈
  - 设计
  - 树状数组
  - 数组
  - 哈希表
  - 有序集合
---

# 1756. 设计最近使用（MRU）队列 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`设计`](/tag/design.md) [`树状数组`](/tag/binary-indexed-tree.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`有序集合`](/tag/ordered-set.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/design-most-recently-used-queue) [`LeetCode`](https://leetcode.com/problems/design-most-recently-used-queue)

## 题目

Design a queue-like data structure that moves the most recently used element
to the end of the queue.

Implement the `MRUQueue` class:

  * `MRUQueue(int n)` constructs the `MRUQueue` with `n` elements: `[1,2,3,...,n]`.
  * `int fetch(int k)` moves the `kth` element **(1-indexed)** to the end of the queue and returns it.



**Example 1:**

> Input:
> 
> ["MRUQueue", "fetch", "fetch", "fetch", "fetch"]
> 
> [[8], [3], [5], [2], [8]]
> 
> Output:
> 
> [null, 3, 6, 2, 2]
> 
> 
> 
> Explanation:
> 
> MRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to [1,2,3,4,5,6,7,8].
> 
> mRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become [1,2,4,5,6,7,8,3] and returns it.
> 
> mRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become [1,2,4,5,7,8,3,6] and returns it.
> 
> mRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become [1,4,5,7,8,3,6,2] and returns it.
> 
> mRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it.

**Constraints:**

  * `1 <= n <= 2000`
  * `1 <= k <= n`
  * At most `2000` calls will be made to `fetch`.



**Follow up:** Finding an `O(n)` algorithm per `fetch` is a bit easy. Can you
find an algorithm with a better complexity for each `fetch` call?


## 题目大意

设计一种类似队列的数据结构，该数据结构将最近使用的元素移到队列尾部。

实现 `MRUQueue` 类：

  * `MRUQueue(int n)` 使用 `n` 个元素： `[1,2,3,...,n]` 构造 `MRUQueue` 。
  * `fetch(int k)` 将第 `k` 个元素**（从 1 开始索引）** 移到队尾，并返回该元素。

**示例 1：**

> 
> 
> 
> 
> 
> **输入：**
> 
> ["MRUQueue", "fetch", "fetch", "fetch", "fetch"]
> 
> [[8], [3], [5], [2], [8]]
> 
> **输出：**
> 
> [null, 3, 6, 2, 2]
> 
> 
> 
> **解释：**
> 
> MRUQueue mRUQueue = new MRUQueue(8); // 初始化队列为 [1,2,3,4,5,6,7,8]。
> 
> mRUQueue.fetch(3); // 将第 3 个元素 (3) 移到队尾，使队列变为 [1,2,4,5,6,7,8,3] 并返回该元素。
> 
> mRUQueue.fetch(5); // 将第 5 个元素 (6) 移到队尾，使队列变为 [1,2,4,5,7,8,3,6] 并返回该元素。
> 
> mRUQueue.fetch(2); // 将第 2 个元素 (2) 移到队尾，使队列变为 [1,4,5,7,8,3,6,2] 并返回该元素。
> 
> mRUQueue.fetch(8); // 第 8 个元素 (2) 已经在队列尾部了，所以直接返回该元素即可。
> 
> 

**提示：**

  * `1 <= n <= 2000`
  * `1 <= k <= n`
  * 最多调用 `2000` 次 `fetch`

**进阶：** 找到每次 `fetch` 的复杂度为 `O(n)` 的算法比较简单。你可以找到每次 `fetch` 的复杂度更佳的算法吗？


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 146 | LRU 缓存 | [[✓]](/problem/0146.md) |  [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/lru-cache) [🔗](https://leetcode.com/problems/lru-cache) |