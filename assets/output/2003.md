---
title: 2003. 每棵子树内缺失的最小基因值
description: LeetCode,2003. 每棵子树内缺失的最小基因值,每棵子树内缺失的最小基因值,Smallest Missing Genetic Value in Each Subtree,解题思路,树,深度优先搜索,并查集,动态规划
keywords:
  - LeetCode
  - 2003. 每棵子树内缺失的最小基因值
  - 每棵子树内缺失的最小基因值
  - Smallest Missing Genetic Value in Each Subtree
  - 解题思路
  - 树
  - 深度优先搜索
  - 并查集
  - 动态规划
---

# 2003. 每棵子树内缺失的最小基因值

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`并查集`](/tag/union-find.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree) [`LeetCode`](https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree)

## 题目

There is a **family tree** rooted at `0` consisting of `n` nodes numbered `0`
to `n - 1`. You are given a **0-indexed** integer array `parents`, where
`parents[i]` is the parent for node `i`. Since node `0` is the **root** ,
`parents[0] == -1`.

There are `10^5` genetic values, each represented by an integer in the
**inclusive** range `[1, 105]`. You are given a **0-indexed** integer array
`nums`, where `nums[i]` is a **distinct** genetic value for node `i`.

Return _an array_`ans` _of length_`n` _where_`ans[i]`_is_ _the**smallest**
genetic value that is **missing** from the subtree rooted at node_ `i`.

The **subtree** rooted at a node `x` contains node `x` and all of its
**descendant** nodes.



**Example 1:**

![](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)

> Input: parents = [-1,0,0,2], nums = [1,2,3,4]
> 
> Output: [5,1,1,1]
> 
> Explanation: The answer for each subtree is calculated as follows:
> - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.
> - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.
> - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.
> - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)

> Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
> 
> Output: [7,1,1,4,2,1]
> 
> Explanation: The answer for each subtree is calculated as follows:
> - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.
> - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.
> - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.
> - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.
> - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.
> - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.

**Example 3:**

> Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
> 
> Output: [1,1,1,1,1,1,1]
> 
> Explanation: The value 1 is missing from all the subtrees.

**Constraints:**

  * `n == parents.length == nums.length`
  * `2 <= n <= 10^5`
  * `0 <= parents[i] <= n - 1` for `i != 0`
  * `parents[0] == -1`
  * `parents` represents a valid tree.
  * `1 <= nums[i] <= 10^5`
  * Each `nums[i]` is distinct.


## 题目大意

有一棵根节点为 `0` 的 **家族树**  ，总共包含 `n` 个节点，节点编号为 `0` 到 `n - 1` 。给你一个下标从 **0**
开始的整数数组 `parents` ，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 `0` 是 **根**  ，所以
`parents[0] == -1` 。

总共有 `10^5` 个基因值，每个基因值都用 **闭区间**  `[1, 105]` 中的一个整数表示。给你一个下标从 **0**  开始的整数数组
`nums` ，其中 `nums[i]` 是节点 `i` 的基因值，且基因值 **互不相同**  。

请你返回一个数组 _ _`ans` ，长度为 `n` ，其中 `ans[i]` 是以节点 `i` 为根的子树内 **缺失**  的 **最小**  基因值。

节点 `x` 为根的 **子树  **包含节点 `x` 和它所有的 **后代**  节点。



**示例 1：**

![](https://assets.leetcode.com/uploads/2021/08/23/case-1.png)

> 
> 
> 
> 
> 
> **输入：** parents = [-1,0,0,2], nums = [1,2,3,4]
> 
> **输出：**[5,1,1,1]
> 
> **解释：** 每个子树答案计算结果如下：
> - 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。
> - 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。
> - 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。
> - 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。
> 
> 

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/08/23/case-2.png)

> 
> 
> 
> 
> 
> **输入：** parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
> 
> **输出：**[7,1,1,4,2,1]
> 
> **解释：** 每个子树答案计算结果如下：
> - 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。
> - 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。
> - 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。
> - 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。
> - 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。
> - 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
> 
> **输出：**[1,1,1,1,1,1,1]
> 
> **解释：** 所有子树都缺失基因值 1 。
> 
> 



**提示：**

  * `n == parents.length == nums.length`
  * `2 <= n <= 10^5`
  * 对于 `i != 0` ，满足 `0 <= parents[i] <= n - 1`
  * `parents[0] == -1`
  * `parents` 表示一棵合法的树。
  * `1 <= nums[i] <= 10^5`
  * `nums[i]` 互不相同。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```