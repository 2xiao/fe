---
title: 2534. 通过门的时间 🔒
description: LeetCode,2534. 通过门的时间 🔒,通过门的时间,Time Taken to Cross the Door,解题思路,队列,数组,模拟
keywords:
  - LeetCode
  - 2534. 通过门的时间 🔒
  - 通过门的时间
  - Time Taken to Cross the Door
  - 解题思路
  - 队列
  - 数组
  - 模拟
---

# 2534. 通过门的时间 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`队列`](/tag/queue.md) [`数组`](/tag/array.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/time-taken-to-cross-the-door) [`LeetCode`](https://leetcode.com/problems/time-taken-to-cross-the-door)

## 题目

There are `n` persons numbered from `0` to `n - 1` and a door. Each person can
enter or exit through the door once, taking one second.

You are given a **non-decreasing** integer array `arrival` of size `n`, where
`arrival[i]` is the arrival time of the `ith` person at the door. You are also
given an array `state` of size `n`, where `state[i]` is `0` if person `i`
wants to enter through the door or `1` if they want to exit through the door.

If two or more persons want to use the door at the **same** time, they follow
the following rules:

  * If the door was **not** used in the previous second, then the person who wants to **exit** goes first.
  * If the door was used in the previous second for **entering** , the person who wants to enter goes first.
  * If the door was used in the previous second for **exiting** , the person who wants to **exit** goes first.
  * If multiple persons want to go in the same direction, the person with the **smallest** index goes first.

Return _an array_`answer` _of size_`n` _where_`answer[i]`_is the second at
which the_`ith` _person crosses the door_.

**Note** that:

  * Only one person can cross the door at each second.
  * A person may arrive at the door and wait without entering or exiting to follow the mentioned rules.



**Example 1:**

> Input: arrival = [0,1,1,2,4], state = [0,1,0,0,1]
> 
> Output: [0,3,1,2,4]
> 
> Explanation: At each second we have the following:
> - At t = 0: Person 0 is the only one who wants to enter, so they just enter through the door.
> - At t = 1: Person 1 wants to exit, and person 2 wants to enter. Since the door was used the previous second for entering, person 2 enters.
> - At t = 2: Person 1 still wants to exit, and person 3 wants to enter. Since the door was used the previous second for entering, person 3 enters.
> - At t = 3: Person 1 is the only one who wants to exit, so they just exit through the door.
> - At t = 4: Person 4 is the only one who wants to exit, so they just exit through the door.

**Example 2:**

> Input: arrival = [0,0,0], state = [1,0,1]
> 
> Output: [0,2,1]
> 
> Explanation: At each second we have the following:
> - At t = 0: Person 1 wants to enter while persons 0 and 2 want to exit. Since the door was not used in the previous second, the persons who want to exit get to go first. Since person 0 has a smaller index, they exit first.
> - At t = 1: Person 1 wants to enter, and person 2 wants to exit. Since the door was used in the previous second for exiting, person 2 exits.
> - At t = 2: Person 1 is the only one who wants to enter, so they just enter through the door.

**Constraints:**

  * `n == arrival.length == state.length`
  * `1 <= n <= 10^5`
  * `0 <= arrival[i] <= n`
  * `arrival` is sorted in **non-decreasing** order.
  * `state[i]` is either `0` or `1`.


## 题目大意

`n` 个人，按从 `0` 到 `n - 1` 编号。现在有一扇门，每个人只能通过门进入或离开一次，耗时一秒。

给你一个 **非递减顺序** 排列的整数数组 `arrival` ，数组长度为 `n` ，其中 `arrival[i]` 是第 `i`
个人到达门前的时间。另给你一个长度为 `n` 的数组 `state` ，其中 `state[i]` 是 `0` 则表示第 `i` 个人希望进入这扇门，是
`1` 则表示 TA 想要离开这扇门。

如果 **同时** 有两个或更多人想要使用这扇门，则必须遵循以下规则：

  * 如果前一秒 **没有** 使用门，那么想要 **离开** 的人会先离开。
  * 如果前一秒使用门 **进入** ，那么想要 **进入** 的人会先进入。
  * 如果前一秒使用门 **离开** ，那么想要 **离开** 的人会先离开。
  * 如果多个人都想朝同一方向走（都进入或都离开），编号最小的人会先通过门。

返回一个长度为 `n` 的数组 __`answer` __ ，其中 __`answer[i]`__ 是第 `i` 个人通过门的时刻（秒）。

**注意：**

  * 每秒只有一个人可以通过门。
  * 为遵循上述规则，一个人可以在到达门附近后等待，而不通过门进入或离开。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** arrival = [0,1,1,2,4], state = [0,1,0,0,1]
> 
> **输出：**[0,3,1,2,4]
> 
> **解释：** 每秒发生的情况如下：
> - t = 0 ：第 0 个人是唯一一个想要进入的人，所以 TA 可以直接进入。
> - t = 1 ：第 1 个人想要离开，第 2 个人想要进入。因为前一秒有人使用门进入，所以第 2 个人先进入。
> - t = 2 ：第 1 个人还是想要离开，第 3 个人想要进入。因为前一秒有人使用门进入，所以第 3 个人先进入。
> - t = 3 ：第 1 个人是唯一一个想要离开的人，所以 TA 可以直接离开。
> - t = 4 ：第 4 个人是唯一一个想要进入的人，所以 TA 可以直接离开。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** arrival = [0,0,0], state = [1,0,1]
> 
> **输出：**[0,2,1]
> 
> **解释：** 每秒发生的情况如下：
> - t = 0 ：第 1 个人想要进入，但是第 0 个人和第 2 个人都想要离开。因为前一秒没有使用门，所以想要离开的人会先离开。又因为第 0 个人的编号更小，所以 TA 先离开。
> - t = 1 ：第 1 个人想要进入，第 2 个人想要离开。因为前一秒有人使用门离开，所以第 2 个人先离开。
> - t = 2 ：第 1 个人是唯一一个想要进入的人，所以 TA 可以直接进入。
> 
> 



**提示：**

  * `n == arrival.length == state.length`
  * `1 <= n <= 10^5`
  * `0 <= arrival[i] <= n`
  * `arrival` 按 **非递减顺序** 排列
  * `state[i]` 为 `0` 或 `1`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 2332 | 坐上公交的最晚时间 |  |  [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) [`二分查找`](/tag/binary-search.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/the-latest-time-to-catch-a-bus) [🔗](https://leetcode.com/problems/the-latest-time-to-catch-a-bus) |