---
title: 1917. Leetcodify 好友推荐 🔒
description: LeetCode,1917. Leetcodify 好友推荐 🔒,Leetcodify 好友推荐,Leetcodify Friends Recommendations,解题思路,数据库
keywords:
  - LeetCode
  - 1917. Leetcodify 好友推荐 🔒
  - Leetcodify 好友推荐
  - Leetcodify Friends Recommendations
  - 解题思路
  - 数据库
---

# 1917. Leetcodify 好友推荐 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`数据库`](/tag/database.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/leetcodify-friends-recommendations) [`LeetCode`](https://leetcode.com/problems/leetcodify-friends-recommendations)

## 题目

Table: `Listens`

> 
> 
> 
> 
> 
> +-------------+---------+
> 
> | Column Name | Type> 
> |
> 
> +-------------+---------+
> 
> | user_id> 
>  | int> 
>  |
> 
> | song_id> 
>  | int> 
>  |
> 
> | day> 
> > 
>  | date> 
> |
> 
> +-------------+---------+
> 
> This table may contain duplicates (In other words, there is no primary key for this table in SQL).
> 
> Each row of this table indicates that the user user_id listened to the song song_id on the day day.
> 
> 



Table: `Friendship`

> 
> 
> 
> 
> 
> +---------------+---------+
> 
> | Column Name   | Type> 
> |
> 
> +---------------+---------+
> 
> | user1_id> 
>   | int> 
>  |
> 
> | user2_id> 
>   | int> 
>  |
> 
> +---------------+---------+
> 
> In SQL,(user1_id, user2_id) is the primary key for this table.
> 
> Each row of this table indicates that the users user1_id and user2_id are friends.
> 
> Note that user1_id < user2_id.
> 
> 



Recommend friends to Leetcodify users. We recommend user `x` to user `y` if:

  * Users `x` and `y` are not friends, and
  * Users `x` and `y` listened to the same three or more different songs **on the same day**.

Note that friend recommendations are **unidirectional** , meaning if user `x`
and user `y` should be recommended to each other, the result table should have
both user `x` recommended to user `y` and user `y` recommended to user `x`.
Also, note that the result table should not contain duplicates (i.e., user `y`
should not be recommended to user `x` multiple times.).

Return the result table in **any order**.

The result format is in the following example.



**Example 1:**

> Input: 
> 
> Listens table:
> 
> +---------+---------+------------+
> 
> | user_id | song_id | day> 
> > 
> |
> 
> +---------+---------+------------+
> 
> | 1> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 1> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 1> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 13> 
>   | 2021-03-15 |
> 
> | 5> 
>    | 10> 
>   | 2021-03-16 |
> 
> | 5> 
>    | 11> 
>   | 2021-03-16 |
> 
> | 5> 
>    | 12> 
>   | 2021-03-16 |
> 
> +---------+---------+------------+
> 
> Friendship table:
> 
> +----------+----------+
> 
> | user1_id | user2_id |
> 
> +----------+----------+
> 
> | 1> 
> > 
> | 2> 
> > 
> |
> 
> +----------+----------+
> 
> Output: 
> 
> +---------+----------------+
> 
> | user_id | recommended_id |
> 
> +---------+----------------+
> 
> | 1> 
>    | 3> 
> > 
> > 
>   |
> 
> | 2> 
>    | 3> 
> > 
> > 
>   |
> 
> | 3> 
>    | 1> 
> > 
> > 
>   |
> 
> | 3> 
>    | 2> 
> > 
> > 
>   |
> 
> +---------+----------------+
> 
> Explanation: 
> 
> Users 1 and 2 listened to songs 10, 11, and 12 on the same day, but they are already friends.
> 
> Users 1 and 3 listened to songs 10, 11, and 12 on the same day. Since they are not friends, we recommend them to each other.
> 
> Users 1 and 4 did not listen to the same three songs.
> 
> Users 1 and 5 listened to songs 10, 11, and 12, but on different days.
> 
> 
> 
> Similarly, we can see that users 2 and 3 listened to songs 10, 11, and 12 on the same day and are not friends, so we recommend them to each other.
> 
> 


## 题目大意

表： `Listens`

> 
> 
> 
> 
> 
> +-------------+---------+
> 
> | Column Name | Type> 
> |
> 
> +-------------+---------+
> 
> | user_id> 
>  | int> 
>  |
> 
> | song_id> 
>  | int> 
>  |
> 
> | day> 
> > 
>  | date> 
> |
> 
> +-------------+---------+
> 
> 这个表没有主键，可能存在重复项。
> 
> 表中的每一行表示用户 user_id 在 day 这一天收听的歌曲 song_id。
> 
> 



表： `Friendship`

> 
> 
> 
> 
> 
> +---------------+---------+
> 
> | Column Name   | Type> 
> |
> 
> +---------------+---------+
> 
> | user1_id> 
>   | int> 
>  |
> 
> | user2_id> 
>   | int> 
>  |
> 
> +---------------+---------+
> 
> (user1_id, user2_id) 是这个表的主键。
> 
> 表中的每一行表示 user1_id 和 user2_id 是好友。
> 
> 注意，user1_id < user2_id。
> 
> 



写出 SQL 语句，为 Leetcodify 用户推荐好友。我们将符合下列条件的用户 `x` 推荐给用户 `y` ：

  * 用户 `x` 和 `y` 不是好友，且
  * 用户 `x` 和 `y` 在**同一天** 收听了相同的三首或更多不同歌曲。

注意，好友推荐是**单向** 的，这意味着如果用户 `x` 和用户 `y` 需要互相推荐给对方，结果表需要将用户 `x` 推荐给用户 `y` 并将用户
`y` 推荐给用户 `x`。另外，结果表不得出现重复项（即，用户 `y` 不可多次推荐给用户 `x` ）。

按**任意顺序** 返回结果表。

查询格式如下示例所示：



**示例 1:**

> 
> 
> 
> 
> 
> **输入：**
> 
> Listens 表：
> 
> +---------+---------+------------+
> 
> | user_id | song_id | day> 
> > 
> |
> 
> +---------+---------+------------+
> 
> | 1> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 1> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 1> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 2> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 3> 
>    | 12> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 10> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 11> 
>   | 2021-03-15 |
> 
> | 4> 
>    | 13> 
>   | 2021-03-15 |
> 
> | 5> 
>    | 10> 
>   | 2021-03-16 |
> 
> | 5> 
>    | 11> 
>   | 2021-03-16 |
> 
> | 5> 
>    | 12> 
>   | 2021-03-16 |
> 
> +---------+---------+------------+
> 
> Friendship 表：
> 
> +----------+----------+
> 
> | user1_id | user2_id |
> 
> +----------+----------+
> 
> | 1> 
> > 
> | 2> 
> > 
> |
> 
> +----------+----------+
> 
> **输出：**
> 
> +---------+----------------+
> 
> | user_id | recommended_id |
> 
> +---------+----------------+
> 
> | 1> 
>    | 3> 
> > 
> > 
>   |
> 
> | 2> 
>    | 3> 
> > 
> > 
>   |
> 
> | 3> 
>    | 1> 
> > 
> > 
>   |
> 
> | 3> 
>    | 2> 
> > 
> > 
>   |
> 
> +---------+----------------+
> 
> **解释**
> 
> 用户 1 和 2 在同一天收听了歌曲 10、11 和 12，但他们已经是好友了。
> 
> 用户 1 和 3 在同一天收听了歌曲 10、11 和 12。由于他们不是好友，所以我们给他们互相推荐为好友。
> 
> 用户 1 和 4 没有收听三首相同的歌曲。
> 
> 用户 1 和 5 收听了歌曲 10、11 和 12，但不是在同一天收听的。
> 
> 
> 
> 类似地，我们可以发现用户 2 和 3 在同一天收听了歌曲 10、11 和 12，且他们不是好友，所以我们给他们互相推荐为好友。
> 
> 


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1919 | 兴趣相同的朋友 🔒 |  |  [`数据库`](/tag/database.md) | 🔴 | [🀄️](https://leetcode.cn/problems/leetcodify-similar-friends) [🔗](https://leetcode.com/problems/leetcodify-similar-friends) |
| 1949 | 坚定的友谊 🔒 |  |  [`数据库`](/tag/database.md) | 🟠 | [🀄️](https://leetcode.cn/problems/strong-friendship) [🔗](https://leetcode.com/problems/strong-friendship) |