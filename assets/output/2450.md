---
title: 2450. 应用操作后不同二进制字符串的数量 🔒
description: LeetCode 2450. 应用操作后不同二进制字符串的数量 🔒题解，Number of Distinct Binary Strings After Applying Operations，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 2450. 应用操作后不同二进制字符串的数量 🔒
  - 应用操作后不同二进制字符串的数量
  - Number of Distinct Binary Strings After Applying Operations
  - 解题思路
  - 数学
  - 字符串
---

# 2450. 应用操作后不同二进制字符串的数量 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数学`](/tag/math.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations) [`LeetCode`](https://leetcode.com/problems/number-of-distinct-binary-strings-after-applying-operations)

## 题目

You are given a **binary** string `s` and a positive integer `k`.

You can apply the following operation on the string **any** number of times:

  * Choose any substring of size `k` from `s` and **flip** all its characters, that is, turn all `1`'s into `0`'s, and all `0`'s into `1`'s.

Return _the number of**distinct** strings you can obtain_. Since the answer
may be too large, return it **modulo** `109 + 7`.

**Note** that:

  * A binary string is a string that consists **only** of the characters `0` and `1`.
  * A substring is a contiguous part of a string.



**Example 1:**

> Input: s = "1001", k = 3
> 
> Output: 4
> 
> Explanation: We can obtain the following strings:
> - Applying no operation on the string gives s = "1001".
> - Applying one operation on the substring starting at index 0 gives s = "_**011**_ 1".
> - Applying one operation on the substring starting at index 1 gives s = "1 _**110**_ ".
> - Applying one operation on both the substrings starting at indices 0 and 1 gives s = "_**0000**_ ".
> 
> It can be shown that we cannot obtain any other string, so the answer is 4.

**Example 2:**

> Input: s = "10110", k = 5
> 
> Output: 2
> 
> Explanation: We can obtain the following strings:
> - Applying no operation on the string gives s = "10110".
> - Applying one operation on the whole string gives s = "01001".
> 
> It can be shown that we cannot obtain any other string, so the answer is 2.

**Constraints:**

  * `1 <= k <= s.length <= 10^5`
  * `s[i]` is either `0` or `1`.


## 题目大意

给定一个 **二进制  **字符串 `s` 和一个正整数 `k`。

你可以对字符串应用以下操作 **任意  **次数:

  * 从 `s` 中选择任何大小为 `k` 的子字符串，将其所有字符 **翻转** ，即将所有 `1` 都变成 `0`，所有 `0` 都变成 `1`。

返回 _您可以获得的  **不同  **字符串的数量。_因为答案可能太大，所以对 `109 + 7` **取模  **后返回。

**注意** :

  * 二进制字符串是 **仅由  **字符 `0` 和 `1` 组成的字符串。
  * 子字符串是字符串的连续部分。



**示例 1:**

> 
> 
> 
> 
> 
> **输入:** s = "1001", k = 3
> 
> **输出:** 4
> 
> **解释:** 我们可以获得以下字符串:
> - 对字符串不应用任何操作将得到 s = "1001"。
> - 对从下标 0 开始的子字符串应用一个操作，得到 s = "_**011**_ 1"。
> - 对从下标 1 开始的子字符串应用一个操作，得到 s = "1 _**110**_ "。
> - 对从下标 0 和 1 开始的两个子字符串都应用一个操作，得到 s = "_**0000**_ "。
> 
> 可以证明，我们不能获得任何其他字符串，所以答案是 4。

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** s = "10110", k = 5
> 
> **输出:** 2
> 
> **解释:** 我们可以获得以下字符串:
> - 对字符串不执行任何操作，将得到 s = "10110"。
> - 对整个字符串应用一个操作将得到 s = "01001"。
> 
> 可以证明，我们不能获得任何其他字符串，所以答案是 2。
> 
> 



**提示:**

  * `1 <= k <= s.length <= 10^5`
  * `s[i]` 是 `0` 或 `1`。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 995 | K 连续位的最小翻转次数 |  |  [`位运算`](/tag/bit-manipulation.md) [`队列`](/tag/queue.md) [`数组`](/tag/array.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips) [🔗](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips) |