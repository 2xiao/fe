---
title: 3189. 得到一个和平棋盘的最少步骤 🔒
description: LeetCode,3189. 得到一个和平棋盘的最少步骤 🔒,得到一个和平棋盘的最少步骤,Minimum Moves to Get a Peaceful Board,解题思路,贪心,数组,计数排序,排序
keywords:
  - LeetCode
  - 3189. 得到一个和平棋盘的最少步骤 🔒
  - 得到一个和平棋盘的最少步骤
  - Minimum Moves to Get a Peaceful Board
  - 解题思路
  - 贪心
  - 数组
  - 计数排序
  - 排序
---

# 3189. 得到一个和平棋盘的最少步骤 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`计数排序`](/tag/counting-sort.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/minimum-moves-to-get-a-peaceful-board) [`LeetCode`](https://leetcode.com/problems/minimum-moves-to-get-a-peaceful-board)

## 题目

Given a 2D array `rooks` of length `n`, where `rooks[i] = [xi, yi]` indicates
the position of a rook on an `n x n` chess board. Your task is to move the
rooks **1 cell** at a time vertically or horizontally (to an _adjacent_ cell)
such that the board becomes **peaceful**.

A board is **peaceful** if there is **exactly** one rook in each row and each
column.

Return the **minimum** number of moves required to get a _peaceful board_.

**Note** that **at no point** can there be two rooks in the same cell.



**Example 1:**

**Input:** rooks = [[0,0],[1,0],[1,1]]

**Output:** 3

**Explanation:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3100-3199/3189.Minimum%20Moves%20to%20Get%20a%20Peaceful%20Board/images/ex1-edited.gif)

**Example 2:**

**Input:** rooks = [[0,0],[0,1],[0,2],[0,3]]

**Output:** 6

**Explanation:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3100-3199/3189.Minimum%20Moves%20to%20Get%20a%20Peaceful%20Board/images/ex2-edited.gif)



**Constraints:**

  * `1 <= n == rooks.length <= 500`
  * `0 <= xi, yi <= n - 1`
  * The input is generated such that there are no 2 rooks in the same cell.


## 题目大意

给定一个长度为 `n` 的二维数组 `rooks`，其中 `rooks[i] = [xi, yi]` 表示 `n x n`
棋盘上一个车的位置。你的任务是每次在垂直或水平方向上移动 **1 格**  车（到一个相邻的格子）使得棋盘变得 **和平** 。

如果每行每列都 **只有** 一个车，那么这块棋盘就是和平的。

返回获得和平棋盘所需的 **最少** 步数。

**注意 任何时刻  **两个车都不能在同一个格子。



**示例 1：**

**输入：** rooks = [[0,0],[1,0],[1,1]]

**输出：** 3

**解释：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3100-3199/3189.Minimum%20Moves%20to%20Get%20a%20Peaceful%20Board/images/1719285456-CnJqJS-
ex1-edited.gif)

**示例 2：**

**输入：** rooks = [[0,0],[0,1],[0,2],[0,3]]

**输出：** 6

**解释：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/3100-3199/3189.Minimum%20Moves%20to%20Get%20a%20Peaceful%20Board/images/1719285456-wtGRzv-
ex2-edited.gif)



**提示：**

  * `1 <= n == rooks.length <= 500`
  * `0 <= xi, yi <= n - 1`
  * 输入保证没有两个车在相同的格子。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 782 | 变为棋盘 |  |  [`位运算`](/tag/bit-manipulation.md) [`数组`](/tag/array.md) [`数学`](/tag/math.md) `1+` | <font color=#ff334b>Hard</font> | [🀄️](https://leetcode.cn/problems/transform-to-chessboard) [🔗](https://leetcode.com/problems/transform-to-chessboard) |
| 947 | 移除最多的同行或同列石头 |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`并查集`](/tag/union-find.md) [`图`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column) [🔗](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column) |