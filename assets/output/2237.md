---
title: 2237. 计算街道上满足所需亮度的位置数量 🔒
description: LeetCode,2237. 计算街道上满足所需亮度的位置数量 🔒,计算街道上满足所需亮度的位置数量,Count Positions on Street With Required Brightness,解题思路,数组,前缀和
keywords:
  - LeetCode
  - 2237. 计算街道上满足所需亮度的位置数量 🔒
  - 计算街道上满足所需亮度的位置数量
  - Count Positions on Street With Required Brightness
  - 解题思路
  - 数组
  - 前缀和
---

# 2237. 计算街道上满足所需亮度的位置数量 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`前缀和`](/tag/prefix-sum.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/count-positions-on-street-with-required-brightness) [`LeetCode`](https://leetcode.com/problems/count-positions-on-street-with-required-brightness)

## 题目

You are given an integer `n`. A perfectly straight street is represented by a
number line ranging from `0` to `n - 1`. You are given a 2D integer array
`lights` representing the street lamp(s) on the street. Each `lights[i] =
[positioni, rangei]` indicates that there is a street lamp at position
`positioni` that lights up the area from `[max(0, positioni - rangei), min(n -
1, positioni + rangei)]` (**inclusive**).

The **brightness** of a position `p` is defined as the number of street lamps
that light up the position `p`. You are given a **0-indexed** integer array
`requirement` of size `n` where `requirement[i]` is the minimum **brightness**
of the `ith` position on the street.

Return _the number of positions_`i` _on the street between_`0` _and_`n - 1`
_that have a**brightness** __of**at least** _`requirement[i]`_._



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2237.Count%20Positions%20on%20Street%20With%20Required%20Brightness/images/screenshot-2022-04-11-at-22-24-43-diagramdrawio-
diagramsnet.png)

> Input: n = 5, lights = [[0,1],[2,1],[3,2]], requirement = [0,2,1,4,1]
> 
> Output: 4
> 
> Explanation:
> - The first street lamp lights up the area from [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 1] (inclusive).
> - The second street lamp lights up the area from [max(0, 2 - 1), min(n - 1, 2 + 1)] = [1, 3] (inclusive).
> - The third street lamp lights up the area from [max(0, 3 - 2), min(n - 1, 3 + 2)] = [1, 4] (inclusive).
> 
> 
> -   Position 0 is covered by the first street lamp. It is covered by 1 street lamp which is greater than requirement[0].
> -   Position 1 is covered by the first, second, and third street lamps. It is covered by 3 street lamps which is greater than requirement[1].
> -   Position 2 is covered by the second and third street lamps. It is covered by 2 street lamps which is greater than requirement[2].
> -   Position 3 is covered by the second and third street lamps. It is covered by 2 street lamps which is less than requirement[3].
> -   Position 4 is covered by the third street lamp. It is covered by 1 street lamp which is equal to requirement[4].
> 
> 
> 
> Positions 0, 1, 2, and 4 meet the requirement so we return 4.
> 
> 

**Example 2:**

> Input: n = 1, lights = [[0,1]], requirement = [2]
> 
> Output: 0
> 
> Explanation:
> - The first street lamp lights up the area from [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 0] (inclusive).
> - Position 0 is covered by the first street lamp. It is covered by 1 street lamp which is less than requirement[0].
> - We return 0 because no position meets their brightness requirement.

**Constraints:**

  * `1 <= n <= 10^5`
  * `1 <= lights.length <= 10^5`
  * `0 <= positioni < n`
  * `0 <= rangei <= 10^5`
  * `requirement.length == n`
  * `0 <= requirement[i] <= 10^5`


## 题目大意

给你一个整数 `n`。一条完全笔直的街道用一条从 `0` 到 `n - 1` 的数轴表示。给你一个二维整数数组 `lights`，表示街道上的路灯。每个
`lights[i] = [positioni, rangei]` 表示在位置 `positioni` 有一盏路灯，从 `[max(0, positioni
- rangei), min(n - 1, positioni + rangei)]` (**包含边界**) 开始照亮该区域。

位置 `p` 的 **亮度  **定义为点亮位置 `p` 的路灯的数量。给定一个大小为 `n` 的整数数组 `requirement`，数组的 **下标从
0 开始** ，其中 `requirement[i]` 是街道上第 `i` 个位置的最小 **亮度** 。

返回 _街道上`0` 到 `n - 1` 之间 **亮度至少满足**  _`requirement[i]`_的位置`i` 的数量。_



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2237.Count%20Positions%20on%20Street%20With%20Required%20Brightness/images/screenshot-2022-04-11-at-22-24-43-diagramdrawio-
diagramsnet.png)

> 
> 
> 
> 
> 
> **输入:** n = 5, lights = [[0,1],[2,1],[3,2]], requirement = [0,2,1,4,1]
> 
> **输出:** 4
> 
> **解释:**
> - 第一盏路灯照亮区域范围为 [max(0,0 - 1)， min(n - 1,0 + 1)] =[0,1](含边界)。
> - 第二盏路灯的点亮范围为 [max(0,2 - 1)， min(n - 1,2 + 1)] =[1,3](含边界)。
> - 第三盏路灯照亮区域范围为 [max(0,3 - 2)， min(n - 1,3 + 2)] =[1,4](含边界)。
> 
> 
> -   位置 0 被第一盏路灯覆盖。它被 1 个路灯覆盖，大于 requirement[0]。
> -   位置 1 被第一、第二和第三个路灯覆盖。被 3 个路灯覆盖，大于 requirement[1]。
> -   位置 2 由第二和第三路灯覆盖。被 2 个路灯覆盖，大于 requirement[2]。
> -   位置 3 由第二和第三路灯覆盖。它被 2 个路灯覆盖，比 requirement[3] 少。
> -   位置 4 被第三个路灯覆盖。它被 1 盏路灯覆盖，等于 requirement[4]。
> 
> 
> 
> 位置 0、1、2、4 满足要求，因此返回4。
> 
> 
> 
> 

**示例  2:**

> 
> 
> 
> 
> 
> **输入:** n = 1, lights = [[0,1]], requirement = [2]
> 
> **输出:** 0
> 
> **解释:**
> - 第一盏路灯照亮区域范围为 [max(0,0 - 1)， min(n - 1,0 + 1)] =[0,0](含边界)。
> - 位置 0 被第一盏路灯覆盖。它被 1 个路灯覆盖，比 requirement[0] 少。
> - 返回0，因为没有位置满足亮度要求。
> 
> 



**提示:**

  * `1 <= n <= 10^5`
  * `1 <= lights.length <= 10^5`
  * `0 <= positioni < n`
  * `0 <= rangei <= 10^5`
  * `requirement.length == n`
  * `0 <= requirement[i] <= 10^5`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 370 | 区间加法 🔒 |  |  [`数组`](/tag/array.md) [`前缀和`](/tag/prefix-sum.md) | 🟠 | [🀄️](https://leetcode.cn/problems/range-addition) [🔗](https://leetcode.com/problems/range-addition) |
| 2021 | 街上最亮的位置 🔒 |  |  [`数组`](/tag/array.md) [`有序集合`](/tag/ordered-set.md) [`前缀和`](/tag/prefix-sum.md) | 🟠 | [🀄️](https://leetcode.cn/problems/brightest-position-on-street) [🔗](https://leetcode.com/problems/brightest-position-on-street) |
| 2536 | 子矩阵元素加 1 |  |  [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) [`前缀和`](/tag/prefix-sum.md) | 🟠 | [🀄️](https://leetcode.cn/problems/increment-submatrices-by-one) [🔗](https://leetcode.com/problems/increment-submatrices-by-one) |