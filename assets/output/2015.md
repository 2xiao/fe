---
title: 2015. 每段建筑物的平均高度 🔒
description: LeetCode,2015. 每段建筑物的平均高度 🔒,每段建筑物的平均高度,Average Height of Buildings in Each Segment,解题思路,贪心,数组,排序,堆（优先队列）
keywords:
  - LeetCode
  - 2015. 每段建筑物的平均高度 🔒
  - 每段建筑物的平均高度
  - Average Height of Buildings in Each Segment
  - 解题思路
  - 贪心
  - 数组
  - 排序
  - 堆（优先队列）
---

# 2015. 每段建筑物的平均高度 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`排序`](/tag/sorting.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/average-height-of-buildings-in-each-segment) [`LeetCode`](https://leetcode.com/problems/average-height-of-buildings-in-each-segment)

## 题目

A perfectly straight street is represented by a number line. The street has
building(s) on it and is represented by a 2D integer array `buildings`, where
`buildings[i] = [starti, endi, heighti]`. This means that there is a building
with `heighti` in the **half-closed segment** `[starti, endi)`.

You want to **describe** the heights of the buildings on the street with the
**minimum** number of non-overlapping **segments**. The street can be
represented by the 2D integer array `street` where `street[j] = [leftj,
rightj, averagej]` describes a **half-closed segment** `[leftj, rightj)` of
the road where the **average** heights of the buildings in the**segment** is
`averagej`.

  * For example, if `buildings = [[1,5,2],[3,10,4]],` the street could be represented by `street = [[1,3,2],[3,5,3],[5,10,4]]` because: 
> 
> * From 1 to 3, there is only the first building with an average height of `2 / 1 = 2`.
> 
> * From 3 to 5, both the first and the second building are there with an average height of `(2+4) / 2 = 3`.
> 
> * From 5 to 10, there is only the second building with an average height of `4 / 1 = 4`.

Given `buildings`, return _the 2D integer array_`street` _as described above
(**excluding** any areas of the street where there are no buldings). You may
return the array in **any order**_.

The **average** of `n` elements is the **sum** of the `n` elements divided
(**integer division**) by `n`.

A **half-closed segment** `[a, b)` is the section of the number line between
points `a` and `b` **including** point `a` and **not including** point `b`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2000-2099/2015.Average%20Height%20of%20Buildings%20in%20Each%20Segment/images/image-20210921224001-2.png)

> Input: buildings = [[1,4,2],[3,9,4]]
> 
> Output: [[1,3,2],[3,4,3],[4,9,4]]
> 
> Explanation:
> 
> From 1 to 3, there is only the first building with an average height of 2 / 1 = 2.
> 
> From 3 to 4, both the first and the second building are there with an average height of (2+4) / 2 = 3.
> 
> From 4 to 9, there is only the second building with an average height of 4 / 1 = 4.

**Example 2:**

> Input: buildings = [[1,3,2],[2,5,3],[2,8,3]]
> 
> Output: [[1,3,2],[3,8,3]]
> 
> Explanation:
> 
> From 1 to 2, there is only the first building with an average height of 2 / 1 = 2.
> 
> From 2 to 3, all three buildings are there with an average height of (2+3+3) / 3 = 2.
> 
> From 3 to 5, both the second and the third building are there with an average height of (3+3) / 2 = 3.
> 
> From 5 to 8, there is only the last building with an average height of 3 / 1 = 3.
> 
> The average height from 1 to 3 is the same so we can group them into one segment.
> 
> The average height from 3 to 8 is the same so we can group them into one segment.

**Example 3:**

> Input: buildings = [[1,2,1],[5,6,1]]
> 
> Output: [[1,2,1],[5,6,1]]
> 
> Explanation:
> 
> From 1 to 2, there is only the first building with an average height of 1 / 1 = 1.
> 
> From 2 to 5, there are no buildings, so it is not included in the output.
> 
> From 5 to 6, there is only the second building with an average height of 1 / 1 = 1.
> 
> We cannot group the segments together because an empty space with no buildings seperates the segments.

**Constraints:**

  * `1 <= buildings.length <= 10^5`
  * `buildings[i].length == 3`
  * `0 <= starti < endi <= 10^8`
  * `1 <= heighti <= 10^5`


## 题目大意

一条完全笔直的街道由一条数字线表示。街道上有建筑物，由二维整数阵列 `buildings` 表示，其中 `buildings[i] = [starti,
endi, heighti]`。这意味着在 **半封闭的位置**`[starti，endi)` 有一座高度为 `heighti` 的建筑。  
你想用 **最少** 数量的非重叠 **部分** 来 **描述** 街道上建筑物的高度。街道可以用2D整数数组 `street` 来表示，其中
`street[j] = [leftj, rightj, averagej]` 描述了道路的 **半封闭区域**  `[leftj, rightj)`
，该段中建筑物的 **平均** 高度为 `averagej` 。

  * 例如，如果 `buildings = [[1,5,2],[3,10,4]]` ， `street = [[1,3,2],[3,5,3],[5,10,4]]` 可以表示街道，因为： 
> 
> * 从 1 到 3 ，只有第一栋建筑的平均高度为 `2 / 1 = 2` 。
> 
> * 从 3 到 5 ，第一和第二栋建筑的平均高度均为 `（2+4） / 2 = 3 `。
> 
> * 从 5 到 10 ，只有第二栋建筑的平均高度为 `4 / 1 = 4` 。

给定 `buildings` ，返回如上所述的二维整数矩阵 _ _`street` _ _ （ **不包括** 街道上没有建筑物的任何区域）。您可以按
**任何顺序** 返回数组。  
`n` 个元素的 **平均值** 是 `n` 个元素除以 `n` 的 **总和** （**整数除法** ）。  
**半闭合段**  `[a, b)` 是点 `a` 和 `b` 之间的数字线的截面，**包括** 点 `a` ，**不包括  **点 `b` 。



**示例1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2000-2099/2015.Average%20Height%20of%20Buildings%20in%20Each%20Segment/images/image-20210921224001-2.png)

> 
> 
> 
> 
> 
> **输入:** buildings = [[1,4,2],[3,9,4]]
> 
> **输出:** [[1,3,2],[3,4,3],[4,9,4]]
> 
> **解释:**
> 
> 从 1 到 3 ，只有第一栋建筑的平均高度为 2 / 1 = 2。
> 
> 从 3 到 4 ，第一和第二栋建筑的平均高度均为（2+4）/ 2 = 3。
> 
> 从 4 到 9 ，只有第二栋建筑的平均高度为 4 / 1 = 4。
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** buildings = [[1,3,2],[2,5,3],[2,8,3]]
> 
> **输出:** [[1,3,2],[3,8,3]]
> 
> **解释:**
> 
> 从 1 到 2 ，只有第一栋建筑的平均高度为 2 / 1 = 2。
> 
> 从 2 到 3 ，这三座建筑的平均高度均为 （2+3+3） / 3 = 2。
> 
> 从 3 到 5 ，第二和第三栋楼都在那里，平均高度为 （3+3） / 2 = 3。
> 
> 从 5 到 8 ，只有最后一栋建筑的平均高度为 3 / 1 = 3。
> 
> 从 1 到 3 的平均高度是相同的，所以我们可以把它们分成一个部分。
> 
> 从 3 到 8 的平均高度是相同的，所以我们可以把它们分成一个部分。
> 
> 

**示例 3:**

> 
> 
> 
> 
> 
> **输入:** buildings = [[1,2,1],[5,6,1]]
> 
> **输出:** [[1,2,1],[5,6,1]]
> 
> **解释:**
> 
> 从 1 到 2 ，只有第一栋建筑的平均高度为 1 / 1 = 1。
> 
> 从 2 到 5 ，没有建筑物，因此不包括在输出中。
> 
> 从 5 到 6 ，只有第二栋建筑的平均高度为 1 / 1 = 1。
> 
> 我们无法将这些部分组合在一起，因为没有建筑的空白空间将这些部分隔开。
> 
> 



**提示:**

  * `1 <= buildings.length <= 10^5`
  * `buildings[i].length == 3`
  * `0 <= starti < endi <= 10^8`
  * `1 <= heighti <= 10^5`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1701 | [平均等待时间](https://leetcode.com/problems/average-waiting-time) |  |  [`数组`](/tag/array.md) [`模拟`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |
| 1943 | [描述绘画结果](https://leetcode.com/problems/describe-the-painting) |  |  [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`前缀和`](/tag/prefix-sum.md) `1+` | <font color=#ffb800>Medium</font> |
| 2158 | [每天绘制新区域的数量 🔒](https://leetcode.com/problems/amount-of-new-area-painted-each-day) |  |  [`线段树`](/tag/segment-tree.md) [`数组`](/tag/array.md) [`有序集合`](/tag/ordered-set.md) | <font color=#ff334b>Hard</font> |
| 2406 | [将区间分为最少组数](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups) | [[✓]](/problem/2406.md) |  [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) `3+` | <font color=#ffb800>Medium</font> |