# [296. 最佳的碰头地点 🔒](https://2xiao.github.io/leetcode-js/problem/0296.html)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`数学`](/tag/math.md) [`矩阵`](/tag/matrix.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/best-meeting-point) [`LeetCode`](https://leetcode.com/problems/best-meeting-point)

## 题目

Given an `m x n` binary grid `grid` where each `1` marks the home of one
friend, return _the minimal**total travel distance**_.

The **total travel distance** is the sum of the distances between the houses
of the friends and the meeting point.

The distance is calculated using [Manhattan
Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1,
p2) = |p2.x - p1.x| + |p2.y - p1.y|`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0296.Best%20Meeting%20Point/images/meetingpoint-
grid.jpg)

> Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
> 
> Output: 6
> 
> Explanation: Given three friends living at (0,0), (0,4), and (2,2).
> 
> The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.
> 
> So return 6.

**Example 2:**

> Input: grid = [[1,1]]
> 
> Output: 1

**Constraints:**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 200`
  * `grid[i][j]` is either `0` or `1`.
  * There will be **at least two** friends in the `grid`.


## 题目大意

给你一个 `m x n`  的二进制网格 `grid` ，其中 `1` 表示某个朋友的家所处的位置。返回 _最小的**总行走距离**_ 。

**总行走距离** 是朋友们家到碰头地点的距离之和。

我们将使用
[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB)
来计算，其中 `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|` 。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0296.Best%20Meeting%20Point/images/meetingpoint-
grid.jpg)

> 
> 
> 
> 
> 
> **输入:** grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
> 
> **输出:** 6 **解释:** 给定的三个人分别住在(0,0)，(0,4) 和 (2,2):
> 
> > 
>  (0,2) 是一个最佳的碰面点，其总行走距离为 2 + 2 + 2 = 6，最小，因此返回 6。

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** grid = [[1,1]]
> 
> **输出:** 1



**提示:**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 200`
  * `grid[i][j] ==` `0` or `1`.
  * `grid` 中 **至少** 有两个朋友


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 317 | [离建筑物最近的距离 🔒](https://leetcode.com/problems/shortest-distance-from-all-buildings) |  |  [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | <font color=#ff334b>Hard</font> |
| 462 | [最小操作次数使数组元素相等 II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii) |  |  [`数组`](/tag/array.md) [`数学`](/tag/math.md) [`排序`](/tag/sorting.md) | <font color=#ffb800>Medium</font> |