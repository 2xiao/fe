---
title: 1135. 最低成本连通所有城市 🔒
description: LeetCode,1135. 最低成本连通所有城市 🔒,最低成本连通所有城市,Connecting Cities With Minimum Cost,解题思路,并查集,图,最小生成树,堆（优先队列）
keywords:
  - LeetCode
  - 1135. 最低成本连通所有城市 🔒
  - 最低成本连通所有城市
  - Connecting Cities With Minimum Cost
  - 解题思路
  - 并查集
  - 图
  - 最小生成树
  - 堆（优先队列）
---

# 1135. 最低成本连通所有城市 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`并查集`](/tag/union-find.md) [`图`](/tag/graph.md) [`最小生成树`](/tag/minimum-spanning-tree.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/connecting-cities-with-minimum-cost) [`LeetCode`](https://leetcode.com/problems/connecting-cities-with-minimum-cost)

## 题目

There are `n` cities labeled from `1` to `n`. You are given the integer `n`
and an array `connections` where `connections[i] = [xi, yi, costi]` indicates
that the cost of connecting city `xi` and city `yi` (bidirectional connection)
is `costi`.

Return _the minimum**cost** to connect all the _`n` _cities such that there is
at least one path between each pair of cities_. If it is impossible to connect
all the `n` cities, return `-1`,

The **cost** is the sum of the connections' costs used.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1135.Connecting%20Cities%20With%20Minimum%20Cost/images/1314_ex2.png)

> Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
> 
> Output: 6
> 
> Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1135.Connecting%20Cities%20With%20Minimum%20Cost/images/1314_ex1.png)

> Input: n = 4, connections = [[1,2,3],[3,4,4]]
> 
> Output: -1
> 
> Explanation: There is no way to connect all cities even if all edges are used.

**Constraints:**

  * `1 <= n <= 10^4`
  * `1 <= connections.length <= 10^4`
  * `connections[i].length == 3`
  * `1 <= xi, yi <= n`
  * `xi != yi`
  * `0 <= costi <= 10^5`


## 题目大意

想象一下你是个城市基建规划者，地图上有 `n` 座城市，它们按以 `1` 到 `n` 的次序编号。

给你整数 `n` 和一个数组 `conections`，其中 `connections[i] = [xi, yi, costi]` 表示将城市 `xi`
和城市 `yi` 连接所要的`costi`（**连接是双向的** ）。

返回连接所有城市的**最低成本** ，每对城市之间**至少** 有一条路径。如果无法连接所有 `n` 个城市，返回 `-1`

该 **最小成本** 应该是所用全部连接成本的总和。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1135.Connecting%20Cities%20With%20Minimum%20Cost/images/1314_ex2.png)

> 
> 
> 
> 
> 
> **输入：** n = 3, conections = [[1,2,5],[1,3,6],[2,3,1]]
> 
> **输出：** 6
> 
> **解释：** 选出任意 2 条边都可以连接所有城市，我们从中选取成本最小的 2 条。
> 
> 

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1135.Connecting%20Cities%20With%20Minimum%20Cost/images/1314_ex1.png)

> 
> 
> 
> 
> 
> **输入：** n = 4, conections = [[1,2,3],[3,4,4]]
> 
> **输出：** -1
> 
> **解释：** 即使连通所有的边，也无法连接所有城市。
> 
> 



**提示：**

  * `1 <= n <= 10^4`
  * `1 <= connections.length <= 10^4`
  * `connections[i].length == 3`
  * `1 <= xi, yi <= n`
  * `xi != yi`
  * `0 <= costi <= 10^5`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 2093 | 前往目标城市的最小费用 🔒 |  |  [`图`](/tag/graph.md) [`最短路`](/tag/shortest-path.md) [`堆（优先队列）`](/tag/heap-priority-queue.md) | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts) [🔗](https://leetcode.com/problems/minimum-cost-to-reach-city-with-discounts) |