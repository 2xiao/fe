---
title: 1724. 检查边长度限制的路径是否存在 II 🔒
description: LeetCode,1724. 检查边长度限制的路径是否存在 II 🔒,检查边长度限制的路径是否存在 II,Checking Existence of Edge Length Limited Paths II,解题思路,并查集,图,最小生成树
keywords:
  - LeetCode
  - 1724. 检查边长度限制的路径是否存在 II 🔒
  - 检查边长度限制的路径是否存在 II
  - Checking Existence of Edge Length Limited Paths II
  - 解题思路
  - 并查集
  - 图
  - 最小生成树
---

# 1724. 检查边长度限制的路径是否存在 II 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`并查集`](/tag/union-find.md) [`图`](/tag/graph.md) [`最小生成树`](/tag/minimum-spanning-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii) [`LeetCode`](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii)

## 题目

An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i]
= [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance
`disi`. Note that there may be **multiple** edges between two nodes, and the
graph may not be connected.

Implement the `DistanceLimitedPathsExist` class:

  * `DistanceLimitedPathsExist(int n, int[][] edgeList)` Initializes the class with an undirected graph.
  * `boolean query(int p, int q, int limit)` Returns `true` if there exists a path from `p` to `q` such that each edge on the path has a distance **strictly less than** `limit`, and otherwise `false`.



**Example 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1724.Checking%20Existence%20of%20Edge%20Length%20Limited%20Paths%20II/images/messed.png)**

> 
> 
> 
> 
> 
> **Input**
> 
> ["DistanceLimitedPathsExist", "query", "query", "query", "query"]
> 
> [[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
> 
> **Output**
> 
> [null, true, false, true, false]
> 
> 
> 
> **Explanation**
> 
> DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
> 
> distanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.
> 
> distanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances **strictly** less than 3.
> 
> distanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.
> 
> distanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.
> 
> 



`**Constraints:**`

  * `2 <= n <= 10^4`
  * `0 <= edgeList.length <= 10^4`
  * `edgeList[i].length == 3`
  * `0 <= ui, vi, p, q <= n-1`
  * `ui != vi`
  * `p != q`
  * `1 <= disi, limit <= 10^9`
  * At most `10^4` calls will be made to `query`.


## 题目大意

一张有 `n` 个节点的无向图以边的列表 `edgeList` 的形式定义，其中 `edgeList[i] = [ui, vi, disi]` 表示一条连接
`ui` 和 `vi` ，距离为 `disi` 的边。注意，同一对节点间可能有**多条** 边，且该图可能不是连通的。

实现 `DistanceLimitedPathsExist` 类：

  * `DistanceLimitedPathsExist(int n, int[][] edgeList)` 以给定的无向图初始化对象。
  * `boolean query(int p, int q, int limit)` 当存在一条从 `p` 到 `q` 的路径，且路径中每条边的距离都**严格小于** `limit` 时，返回 `true` ，否则返回 `false` 。



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1724.Checking%20Existence%20of%20Edge%20Length%20Limited%20Paths%20II/images/1693449815-oSOAxI-%E6%88%AA%E5%B1%8F2023-08-31%2010.43.30.png\){:width=400})![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1724.Checking%20Existence%20of%20Edge%20Length%20Limited%20Paths%20II/images/1693449815-oSOAxI-%E6%88%AA%E5%B1%8F2023-08-31%2010.43.30.png)

> 
> 
> 
> 
> 
> **输入：**
> 
> ["DistanceLimitedPathsExist", "query", "query", "query", "query"]
> 
> [[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
> 
> **输出：**
> 
> [null, true, false, true, false]
> 
> 
> 
> **解释：**
> 
> DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
> 
> distanceLimitedPathsExist.query(2, 3, 2); // 返回 true。存在一条从 2 到 3 ，距离为 1 的边，
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // 这条边的距离小于 2。
> 
> distanceLimitedPathsExist.query(1, 3, 3); // 返回 false。从 1 到 3 之间不存在每条边的距离都
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // **严格** 小于 3 的路径。
> 
> distanceLimitedPathsExist.query(2, 0, 3); // 返回 true。存在一条从 2 到 0 的路径，使得每条边的
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // 距离 < 3：从 2 到 3 到 0 行进即可。
> 
> distanceLimitedPathsExist.query(0, 5, 6); // 返回 false。从 0 到 5 之间不存在路径。
> 
> 



**提示：**

  * `2 <= n <= 10^4`
  * `0 <= edgeList.length <= 10^4`
  * `edgeList[i].length == 3`
  * `0 <= ui, vi, p, q <= n-1`
  * `ui != vi`
  * `p != q`
  * `1 <= disi, limit <= 10^9`
  * 最多调用 `10^4` 次 `query` 。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1697 | 检查边长度限制的路径是否存在 |  |  [`并查集`](/tag/union-find.md) [`图`](/tag/graph.md) [`数组`](/tag/array.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths) [🔗](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths) |
| 2421 | 好路径的数目 |  |  [`树`](/tag/tree.md) [`并查集`](/tag/union-find.md) [`图`](/tag/graph.md) `3+` | 🔴 | [🀄️](https://leetcode.cn/problems/number-of-good-paths) [🔗](https://leetcode.com/problems/number-of-good-paths) |
| 2492 | 两个城市间路径的最小分数 |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`并查集`](/tag/union-find.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities) [🔗](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities) |