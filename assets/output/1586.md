---
title: 1586. 二叉搜索树迭代器 II 🔒
description: LeetCode,1586. 二叉搜索树迭代器 II 🔒,二叉搜索树迭代器 II,Binary Search Tree Iterator II,解题思路,栈,树,设计,二叉搜索树,二叉树,迭代器
keywords:
  - LeetCode
  - 1586. 二叉搜索树迭代器 II 🔒
  - 二叉搜索树迭代器 II
  - Binary Search Tree Iterator II
  - 解题思路
  - 栈
  - 树
  - 设计
  - 二叉搜索树
  - 二叉树
  - 迭代器
---

# 1586. 二叉搜索树迭代器 II 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`二叉树`](/tag/binary-tree.md) [`迭代器`](/tag/iterator.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/binary-search-tree-iterator-ii) [`LeetCode`](https://leetcode.com/problems/binary-search-tree-iterator-ii)

## 题目

Implement the `BSTIterator` class that represents an iterator over the **[in-
order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-
order_\(LNR\))** of a binary search tree (BST):

  * `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
  * `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.
  * `int next()` Moves the pointer to the right, then returns the number at the pointer.
  * `boolean hasPrev()` Returns `true` if there exists a number in the traversal to the left of the pointer, otherwise returns `false`.
  * `int prev()` Moves the pointer to the left, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the
first call to `next()` will return the smallest element in the BST.

You may assume that `next()` and `prev()` calls will always be valid. That is,
there will be at least a next/previous number in the in-order traversal when
`next()`/`prev()` is called.



**Example 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1586.Binary%20Search%20Tree%20Iterator%20II/images/untitled-
diagram-1.png)**

> 
> 
> 
> 
> 
> **Input**
> 
> ["BSTIterator", "next", "next", "prev", "next", "hasNext", "next", "next", "next", "hasNext", "hasPrev", "prev", "prev"]
> 
> [[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]
> 
> **Output**
> 
> [null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]
> 
> 
> 
> **Explanation**
> 
> // The underlined element is where the pointer currently is.
> 
> BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is __ [3, 7, 9, 15, 20]
> 
> bSTIterator.next(); // state becomes [_3_ , 7, 9, 15, 20], return 3
> 
> bSTIterator.next(); // state becomes [3, _7_ , 9, 15, 20], return 7
> 
> bSTIterator.prev(); // state becomes [_3_ , 7, 9, 15, 20], return 3
> 
> bSTIterator.next(); // state becomes [3, _7_ , 9, 15, 20], return 7
> 
> bSTIterator.hasNext(); // return true
> 
> bSTIterator.next(); // state becomes [3, 7, _9_ , 15, 20], return 9
> 
> bSTIterator.next(); // state becomes [3, 7, 9, _15_ , 20], return 15
> 
> bSTIterator.next(); // state becomes [3, 7, 9, 15, _20_], return 20
> 
> bSTIterator.hasNext(); // return false
> 
> bSTIterator.hasPrev(); // return true
> 
> bSTIterator.prev(); // state becomes [3, 7, 9, _15_ , 20], return 15
> 
> bSTIterator.prev(); // state becomes [3, 7, _9_ , 15, 20], return 9

**Constraints:**

  * The number of nodes in the tree is in the range `[1, 105]`.
  * `0 <= Node.val <= 10^6`
  * At most `10^5` calls will be made to `hasNext`, `next`, `hasPrev`, and `prev`.



**Follow up:** Could you solve the problem without precalculating the values
of the tree?


## 题目大意

实现二叉搜索树（BST）的[中序遍历](https://baike.baidu.com/item/中序遍历/757281?fr=aladdin)迭代器
`BSTIterator` 类：

  * `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的实例。二叉搜索树的根节点 `root` 作为构造函数的参数传入。内部指针使用一个不存在于树中且小于树中任意值的数值来初始化。
  * `boolean hasNext()` 如果当前指针在中序遍历序列中，存在右侧数值，返回 `true` ，否则返回 `false` 。
  * `int next()` 将指针在中序遍历序列中向右移动，然后返回移动后指针所指数值。
  * `boolean hasPrev()` 如果当前指针在中序遍历序列中，存在左侧数值，返回 `true` ，否则返回 `false` 。
  * `int prev()` 将指针在中序遍历序列中向左移动，然后返回移动后指针所指数值。

注意，虽然我们使用树中不存在的最小值来初始化内部指针，第一次调用 `next()` 需要返回二叉搜索树中最小的元素。

你可以假设 `next()` 和 `prev()` 的调用总是有效的。即，当 `next()`/`prev()`
被调用的时候，在中序遍历序列中一定存在下一个/上一个元素。

**进阶：** 你可以不提前遍历树中的值来解决问题吗？



**示例 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1586.Binary%20Search%20Tree%20Iterator%20II/images/untitled-
diagram-1.png)**

> 
> 
> 
> 
> 
> **输入**
> 
> ["BSTIterator", "next", "next", "prev", "next", "hasNext", "next", "next", "next", "hasNext", "hasPrev", "prev", "prev"]
> 
> [[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]
> 
> **输出**
> 
> [null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]
> 
> 
> 
> **解释**
> 
> // 划线的元素表示指针当前的位置。
> 
> BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // 当前状态为 <u> </u> [3, 7, 9, 15, 20]
> 
> bSTIterator.next(); // 状态变为 [<u>3</u>, 7, 9, 15, 20], 返回 3
> 
> bSTIterator.next(); // 状态变为 [3, <u>7</u>, 9, 15, 20], 返回 7
> 
> bSTIterator.prev(); // 状态变为 [<u>3</u>, 7, 9, 15, 20], 返回 3
> 
> bSTIterator.next(); // 状态变为 [3, <u>7</u>, 9, 15, 20], 返回 7
> 
> bSTIterator.hasNext(); // 返回 true
> 
> bSTIterator.next(); // 状态变为 [3, 7, <u>9</u>, 15, 20], 返回 9
> 
> bSTIterator.next(); // 状态变为 [3, 7, 9, <u>15</u>, 20], 返回 15
> 
> bSTIterator.next(); // 状态变为 [3, 7, 9, 15, <u>20</u>], 返回 20
> 
> bSTIterator.hasNext(); // 返回 false
> 
> bSTIterator.hasPrev(); // 返回 true
> 
> bSTIterator.prev(); // 状态变为 [3, 7, 9, <u>15</u>, 20], 返回 15
> 
> bSTIterator.prev(); // 状态变为 [3, 7, <u>9</u>, 15, 20], 返回 9
> 
> 



**提示:**

  * 树中节点个数的范围是 `[1, 105]` 。
  * `0 <= Node.val <= 10^6`
  * 最多调用 105 次 `hasNext`、 `next`、 `hasPrev` 和 `prev` 。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 173 | 二叉搜索树迭代器 | [[✓]](/problem/0173.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) `3+` | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/binary-search-tree-iterator) [🔗](https://leetcode.com/problems/binary-search-tree-iterator) |