---
title: 1506. 找到 N 叉树的根节点 🔒
description: LeetCode 1506. 找到 N 叉树的根节点 🔒题解，Find Root of N-Ary Tree，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1506. 找到 N 叉树的根节点 🔒
  - 找到 N 叉树的根节点
  - Find Root of N-Ary Tree
  - 解题思路
  - 位运算
  - 树
  - 深度优先搜索
  - 哈希表
---

# 1506. 找到 N 叉树的根节点 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`位运算`](/tag/bit-manipulation.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`哈希表`](/tag/hash-table.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-root-of-n-ary-tree) [`LeetCode`](https://leetcode.com/problems/find-root-of-n-ary-tree)

## 题目

You are given all the nodes of an **[N-ary
tree](https://leetcode.com/explore/learn/card/n-ary-tree/)** as an array of
`Node` objects, where each node has a **unique value**.

Return _the**root** of the N-ary tree_.

**Custom testing:**

An N-ary tree can be serialized as represented in its level order traversal
where each group of children is separated by the `null` value (see examples).

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png)

For example, the above tree is serialized as
`[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.

The testing will be done in the following way:

  1. The **input data** should be provided as a serialization of the tree.
  2. The driver code will construct the tree from the serialized input data and put each `Node` object into an array **in an arbitrary order**.
  3. The driver code will pass the array to `findRoot`, and your function should find and return the root `Node` object in the array.
  4. The driver code will take the returned `Node` object and serialize it. If the serialized value and the input data are the **same** , the test **passes**.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/narytreeexample.png)

> Input: tree = [1,null,3,2,4,null,5,6]
> 
> Output: [1,null,3,2,4,null,5,6]
> 
> Explanation: The tree from the input data is shown above.
> 
> The driver code creates the tree and gives findRoot the Node objects in an arbitrary order.
> 
> For example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)].
> 
> The findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data.
> 
> The input data and serialized Node(1) are the same, so the test passes.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png)

> Input: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

**Constraints:**

  * The total number of nodes is between `[1, 5 * 104]`.
  * Each node has a **unique** value.



**Follow up:**

  * Could you solve this problem in constant space complexity with a linear time algorithm?


## 题目大意

给定一棵 [N 叉树](https://leetcode.cn/explore/learn/card/n-ary-tree/) 的所有节点在一个数组
`Node[] tree` 中，树中每个节点都有 **唯一的值** 。

找到并返回 N 叉树的 **根节点** 。



**自定义测试：**

_N 叉树的输入序列为其层序遍历序列，每组子节点用 null 分隔（见示例）。_

_![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png)_

上图中的 N 叉树的序列化描述为
`[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`
。

**测试将以下列方式进行：**

  * 输入数据的形式为树的序列化描述。
  * 驱动程序代码将根据序列化的输入数据构造树，并以任意顺序将每个 `Node` 对象放入一个数组中。
  * 驱动程序代码将把数组传递给 `findRoot` ，你所编写的函数应该在数组中查找并返回根 `Node` 对象。
  * 驱动程序代码将接受返回的 `Node` 对象并对其进行序列化。如果序列化的结果和输入数据 **相同** ，则测试 **通过** 。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/narytreeexample.png)

> 
> 
> 
> 
> 
> **输入：** tree = [1,null,3,2,4,null,5,6]
> 
> **输出：**[1,null,3,2,4,null,5,6]
> 
> **解释：** 来自输入数据的树如上所示。
> 
> 驱动程序代码创建树，并以任意顺序向 findRoot 提供 Node 对象。
> 
> 例如，传递的数组可以是 [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] 或 [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)] 。
> 
> findRoot 函数应该返回根 Node(1) ，驱动程序代码将序列化它并与输入数据进行比较。
> 
> 输入数据和序列化的 Node(1) 相同，因此测试通过。

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png)

> 
> 
> 
> 
> 
> **输入：** tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> **输出：**[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> 



**提示：**

  * 节点的总个数在 `[1, 5*10^4]` 之间。
  * 每个节点都有唯一的值。



**进阶：**

  * 你可以使用 O(1) 额外内存空间且 O(n) 时间复杂度的算法来找到该树的根节点吗？


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1516 | 移动 N 叉树的子树 🔒 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) | 🔴 | [🀄️](https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree) [🔗](https://leetcode.com/problems/move-sub-tree-of-n-ary-tree) |