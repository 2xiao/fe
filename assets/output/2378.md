---
title: 2378. 选择边来最大化树的得分 🔒
description: LeetCode,2378. 选择边来最大化树的得分 🔒,选择边来最大化树的得分,Choose Edges to Maximize Score in a Tree,解题思路,树,深度优先搜索,动态规划
keywords:
  - LeetCode
  - 2378. 选择边来最大化树的得分 🔒
  - 选择边来最大化树的得分
  - Choose Edges to Maximize Score in a Tree
  - 解题思路
  - 树
  - 深度优先搜索
  - 动态规划
---

# 2378. 选择边来最大化树的得分 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree) [`LeetCode`](https://leetcode.com/problems/choose-edges-to-maximize-score-in-a-tree)

## 题目

You are given a **weighted** tree consisting of `n` nodes numbered from `0` to
`n - 1`.

The tree is **rooted** at node `0` and represented with a **2D** array `edges`
of size `n` where `edges[i] = [pari, weighti]` indicates that node `pari` is
the **parent** of node `i`, and the edge between them has a weight equal to
`weighti`. Since the root does **not** have a parent, you have `edges[0] =
[-1, -1]`.

Choose some edges from the tree such that no two chosen edges are **adjacent**
and the **sum** of the weights of the chosen edges is maximized.

Return _the**maximum** sum of the chosen edges_.

**Note** :

  * You are allowed to **not** choose any edges in the tree, the sum of weights in this case will be `0`.
  * Two edges `Edge1` and `Edge2` in the tree are **adjacent** if they have a **common** node. 
> 
> * In other words, they are adjacent if `Edge1` connects nodes `a` and `b` and `Edge2` connects nodes `b` and `c`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treedrawio.png)

> Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
> 
> Output: 11
> 
> Explanation: The above diagram shows the edges that we have to choose colored in red.
> 
> The total score is 5 + 6 = 11.
> 
> It can be shown that no better score can be obtained.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treee1293712983719827.png)

> Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]]
> 
> Output: 7
> 
> Explanation: We choose the edge with weight 7.
> 
> Note that we cannot choose more than one edge because all edges are adjacent to each other.

**Constraints:**

  * `n == edges.length`
  * `1 <= n <= 10^5`
  * `edges[i].length == 2`
  * `par0 == weight0 == -1`
  * `0 <= pari <= n - 1` for all `i >= 1`.
  * `pari != i`
  * `-10^6 <= weighti <= 10^6` for all `i >= 1`.
  * `edges` represents a valid tree.


## 题目大意

给定一个 **加权  **树，由 `n` 个节点组成，从 `0` 到 `n - 1`。

该树以节点 0 为 **根** ，用大小为 `n` 的二维数组 `edges` 表示，其中 `edges[i] = [pari, weighti]`
表示节点 `pari` 是节点 `i` 的 **父  **节点，它们之间的边的权重等于 `weighti`。因为根结点 **没有  **父结点，所以有
`edges[0] = [-1, -1]`。

从树中选择一些边，使所选的两条边都不 **相邻** ，所选边的权值之 **和** 最大。



返回 _所选边的  **最大  **和。_

**注意** :

  * 你可以 **不选择  **树中的任何边，在这种情况下权值和将为 `0`。
  * 如果树中的两条边 `Edge1` 和 `Edge2` 有一个 **公共  **节点，它们就是 **相邻  **的。 
> 
> * 换句话说，如果 `Edge1`连接节点 `a` 和 `b`, `Edge2` 连接节点 `b` 和 `c`，它们是相邻的。



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treedrawio.png)

> 
> 
> 
> 
> 
> **输入:** edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
> 
> **输出:** 11
> 
> **解释:** 上面的图表显示了我们必须选择红色的边。
> 
> 总分是 5 + 6 = 11.
> 
> 可以看出，没有更好的分数可以获得。
> 
> 

**示例 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treee1293712983719827.png)

> 
> 
> 
> 
> 
> **输入:** edges = [[-1,-1],[0,5],[0,-6],[0,7]]
> 
> **输出:** 7
> 
> **解释:** 我们选择权值为 7 的边。
> 
> 注意，我们不能选择一条以上的边，因为所有的边都是彼此相邻的。
> 
> 



**提示:**

  * `n == edges.length`
  * `1 <= n <= 10^5`
  * `edges[i].length == 2`
  * `par0 == weight0 == -1`
  * `i >= 1` 时 `0 <= pari <= n - 1` 。
  * `pari != i`
  * `i >= 1` 时 `-10^6 <= weighti <= 10^6` 。
  * `edges` 表示有效的树。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 968 | 监控二叉树 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`动态规划`](/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> | [🀄️](https://leetcode.cn/problems/binary-tree-cameras) [🔗](https://leetcode.com/problems/binary-tree-cameras) |
| 2246 | 相邻字符不同的最长路径 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`图`](/tag/graph.md) `3+` | <font color=#ff334b>Hard</font> | [🀄️](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters) [🔗](https://leetcode.com/problems/longest-path-with-different-adjacent-characters) |