# [431. 将 N 叉树编码为二叉树 🔒](https://2xiao.github.io/leetcode-js/problem/0431.html)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`设计`](/tag/design.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree) [`LeetCode`](https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree)

## 题目

Design an algorithm to encode an N-ary tree into a binary tree and decode the
binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in
which each node has no more than N children. Similarly, a binary tree is a
rooted tree in which each node has no more than 2 children. There is no
restriction on how your encode/decode algorithm should work. You just need to
ensure that an N-ary tree can be encoded to a binary tree and this binary tree
can be decoded to the original N-nary tree structure.

_Nary-Tree input serialization is represented in their level order traversal,
each group of children is separated by the null value (See following
example)._

For example, you may encode the following `3-ary` tree to a binary tree in
this way:

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0431.Encode%20N-ary%20Tree%20to%20Binary%20Tree/images/narytreebinarytreeexample.png)

> Input: root = [1,null,3,2,4,null,5,6]
> 
> 

Note that the above is just an example which _might or might not_ work. You do
not necessarily need to follow this format, so please be creative and come up
with different approaches yourself.



**Example 1:**

> Input: root = [1,null,3,2,4,null,5,6]
> 
> Output: [1,null,3,2,4,null,5,6]

**Example 2:**

> Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

**Example 3:**

> Input: root = []
> 
> Output: []

**Constraints:**

  * The number of nodes in the tree is in the range `[0, 104]`.
  * `0 <= Node.val <= 10^4`
  * The height of the n-ary tree is less than or equal to `1000`
  * Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.


## 题目大意

设计一个算法，可以将 N 叉树编码为二叉树，并能将该二叉树解码为原 N 叉树。一个 N 叉树是指每个节点都有不超过 N
个孩子节点的有根树。类似地，一个二叉树是指每个节点都有不超过 2 个孩子节点的有根树。你的编码 / 解码的算法的实现没有限制，你只需要保证一个 N
叉树可以编码为二叉树且该二叉树可以解码回原始 N 叉树即可。

例如，你可以将下面的 `3-叉` 树以该种方式编码：



![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0431.Encode%20N-ary%20Tree%20to%20Binary%20Tree/images/narytreebinarytreeexample.png)



> 
> 
> 
> 
> 
> **输入：** root = [1,null,3,2,4,null,5,6]
> 
> 

注意，上面的方法仅仅是一个例子，可能可行也可能不可行。你没有必要遵循这种形式转化，你可以自己创造和实现不同的方法。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** root = [1,null,3,2,4,null,5,6]
> 
> **输出：**[1,null,3,2,4,null,5,6]
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> **输出：**[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** root = []
> 
> **输出：**[]
> 
> 



**提示：**

  1. `N` 的范围在 `[1, 104]`
  2. `0 <= Node.val <= 10^4`
  3. N 叉树的高度小于等于 `1000`。
  4. 不要使用类成员 / 全局变量 / 静态变量来存储状态。你的编码和解码算法应是无状态的。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 428 | [序列化和反序列化 N 叉树 🔒](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | <font color=#ff334b>Hard</font> |