---
title: 359. 日志速率限制器 🔒
description: LeetCode,359. 日志速率限制器 🔒,日志速率限制器,Logger Rate Limiter,解题思路,设计,哈希表,数据流
keywords:
  - LeetCode
  - 359. 日志速率限制器 🔒
  - 日志速率限制器
  - Logger Rate Limiter
  - 解题思路
  - 设计
  - 哈希表
  - 数据流
---

# 359. 日志速率限制器 🔒

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`数据流`](/tag/data-stream.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/logger-rate-limiter) [`LeetCode`](https://leetcode.com/problems/logger-rate-limiter)

## 题目

Design a logger system that receives a stream of messages along with their
timestamps. Each **unique** message should only be printed **at most every 10
seconds** (i.e. a message printed at timestamp `t` will prevent other
identical messages from being printed until timestamp `t + 10`).

All messages will come in chronological order. Several messages may arrive at
the same timestamp.

Implement the `Logger` class:

  * `Logger()` Initializes the `logger` object.
  * `bool shouldPrintMessage(int timestamp, string message)` Returns `true` if the `message` should be printed in the given `timestamp`, otherwise returns `false`.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Logger", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage"]
> 
> [[], [1, "foo"], [2, "bar"], [3, "foo"], [8, "bar"], [10, "foo"], [11, "foo"]]
> 
> **Output**
> 
> [null, true, true, false, false, false, true]
> 
> 
> 
> **Explanation**
> 
> Logger logger = new Logger();
> 
> logger.shouldPrintMessage(1, "foo");  // return true, next allowed timestamp for "foo" is 1 + 10 = 11
> 
> logger.shouldPrintMessage(2, "bar");  // return true, next allowed timestamp for "bar" is 2 + 10 = 12
> 
> logger.shouldPrintMessage(3, "foo");  // 3 < 11, return false
> 
> logger.shouldPrintMessage(8, "bar");  // 8 < 12, return false
> 
> logger.shouldPrintMessage(10, "foo"); // 10 < 11, return false
> 
> logger.shouldPrintMessage(11, "foo"); // 11 >= 11, return true, next allowed timestamp for "foo" is 11 + 10 = 21

**Constraints:**

  * `0 <= timestamp <= 10^9`
  * Every `timestamp` will be passed in non-decreasing order (chronological order).
  * `1 <= message.length <= 30`
  * At most `10^4` calls will be made to `shouldPrintMessage`.


## 题目大意

请你设计一个日志系统，可以流式接收消息以及它的时间戳。每条 **不重复** 的消息最多只能每 10 秒打印一次。也就是说，如果在时间戳 `t`
打印某条消息，那么相同内容的消息直到时间戳变为 `t + 10` 之前都不会被打印。

所有消息都按时间顺序发送。多条消息可能到达同一时间戳。

实现 `Logger` 类：

  * `Logger()` 初始化 `logger` 对象
  * `bool shouldPrintMessage(int timestamp, string message)` 如果这条消息 `message` 在给定的时间戳 `timestamp` 应该被打印出来，则返回 `true` ，否则请返回 `false` 。

**示例：**

> 
> 
> 
> 
> 
> **输入：**
> 
> ["Logger", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage"]
> 
> [[], [1, "foo"], [2, "bar"], [3, "foo"], [8, "bar"], [10, "foo"], [11, "foo"]]
> 
> **输出：**
> 
> [null, true, true, false, false, false, true]
> 
> 
> 
> **解释：**
> 
> Logger logger = new Logger();
> 
> logger.shouldPrintMessage(1, "foo");  // 返回 true ，下一次 "foo" 可以打印的时间戳是 1 + 10 = 11
> 
> logger.shouldPrintMessage(2, "bar");  // 返回 true ，下一次 "bar" 可以打印的时间戳是 2 + 10 = 12
> 
> logger.shouldPrintMessage(3, "foo");  // 3 < 11 ，返回 false
> 
> logger.shouldPrintMessage(8, "bar");  // 8 < 12 ，返回 false
> 
> logger.shouldPrintMessage(10, "foo"); // 10 < 11 ，返回 false
> 
> logger.shouldPrintMessage(11, "foo"); // 11 >= 11 ，返回 true ，下一次 "foo" 可以打印的时间戳是 11 + 10 = 21
> 
> 

**提示：**

  * `0 <= timestamp <= 10^9`
  * 每个 `timestamp` 都将按非递减顺序（时间顺序）传递
  * `1 <= message.length <= 30`
  * 最多调用 `10^4` 次 `shouldPrintMessage` 方法


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 362 | [敲击计数器 🔒](https://leetcode.com/problems/design-hit-counter) |  |  [`设计`](/tag/design.md) [`队列`](/tag/queue.md) [`数组`](/tag/array.md) `2+` | <font color=#ffb800>Medium</font> |