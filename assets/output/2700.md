# [2700. 两个对象之间的差异](https://leetcode.com/problems/differences-between-two-objects)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/differences-between-two-objects)

## 题目

Write a function that accepts two deeply nested objects or arrays `obj1` and
`obj2` and returns a new object representing their differences.

The function should compare the properties of the two objects and identify any
changes. The returned object should only contains keys where the value is
different from `obj1` to `obj2`.

For each changed key, the value should be represented as an array `[obj1
value, obj2 value]`. Keys that exist in one object but not in the other should
not be included in the returned object. The end result should be a deeply
nested object where each leaf value is a difference array.

When comparing two arrays, the indices of the arrays are considered to be
their keys.

You may assume that both objects are the output of `JSON.parse`.



**Example 1:**

> Input: 
> 
> obj1 = {}
> 
> obj2 = {
> 
>   "a": 1, 
> 
>   "b": 2
> 
> }
> 
> Output: {}
> 
> Explanation: There were no modifications made to obj1. New keys "a" and "b" appear in obj2, but keys that are added or removed should be ignored.

**Example 2:**

> Input: 
> 
> obj1 = {
> 
>   "a": 1,
> 
>   "v": 3,
> 
>   "x": [],
> 
>   "z": {
> 
> > 
> "a": null
> 
>   }
> 
> }
> 
> obj2 = {
> 
>   "a": 2,
> 
>   "v": 4,
> 
>   "x": [],
> 
>   "z": {
> 
> > 
> "a": 2
> 
>   }
> 
> }
> 
> Output: 
> 
> {
> 
>   "a": [1, 2],
> 
>   "v": [3, 4],
> 
>   "z": {
> 
> > 
> "a": [null, 2]
> 
>   }
> 
> }
> 
> Explanation: The keys "a", "v", and "z" all had changes applied. "a" was changed from 1 to 2. "v" was changed from 3 to 4. "z" had a change applied to a child object. "z.a" was changed from null to 2.

**Example 3:**

> Input: 
> 
> obj1 = {
> 
>   "a": 5, 
> 
>   "v": 6, 
> 
>   "z": [1, 2, 4, [2, 5, 7]]
> 
> }
> 
> obj2 = {
> 
>   "a": 5, 
> 
>   "v": 7, 
> 
>   "z": [1, 2, 3, [1]]
> 
> }
> 
> Output: 
> 
> {
> 
>   "v": [6, 7],
> 
>   "z": {
> 
> > 
> "2": [4, 3],
> 
> > 
> "3": {
> 
> > 
>   "0": [2, 1]
> 
> > 
> }
> 
>   }
> 
> }
> 
> Explanation: In obj1 and obj2, the keys "v" and "z" have different assigned values. "a" is ignored because the value is unchanged. In the key "z", there is a nested array. Arrays are treated like objects where the indices are keys. There were two alterations to the the array: z[2] and z[3][0]. z[0] and z[1] were unchanged and thus not included. z[3][1] and z[3][2] were removed and thus not included.

**Example 4:**

> Input: 
> 
> obj1 = {
> 
>   "a": {"b": 1}, 
> 
> }
> 
> obj2 = {
> 
>   "a": [5],
> 
> }
> 
> Output: 
> 
> {
> 
>   "a": [{"b": 1}, [5]]
> 
> }
> 
> Explanation: The key "a" exists in both objects. Since the two associated values have different types, they are placed in the difference array.

**Example 5:**

> Input: 
> 
> obj1 = {
> 
>   "a": [1, 2, {}], 
> 
>   "b": false
> 
> }
> 
> obj2 = {   
> 
>   "b": false,
> 
>   "a": [1, 2, {}]
> 
> }
> 
> Output: 
> 
> {}
> 
> Explanation: Apart from a different ordering of keys, the two objects are identical so an empty object is returned.



**Constraints:**

  * `obj1` and `obj2` are valid JSON objects or arrays
  * `2 <= JSON.stringify(obj1).length <= 10^4`
  * `2 <= JSON.stringify(obj2).length <= 10^4`


## 题目大意

请你编写一个函数，它接收两个深度嵌套的对象或数组 `obj1` 和 `obj2` ，并返回一个新对象表示它们之间差异。

该函数应该比较这两个对象的属性，并识别任何变化。返回的对象应仅包含从 `obj1` 到 `obj2` 的值不同的键。

对于每个变化的键，值应表示为一个数组 `[obj1 value, obj2 value]`
。不存在于一个对象中但存在于另一个对象中的键不应包含在返回的对象中。在比较两个数组时，数组的索引被视为它们的键。最终结果应是一个深度嵌套的对象，其中每个叶子的值都是一个差异数组。

你可以假设这两个对象都是 `JSON.parse` 的输出结果。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** 
> 
> obj1 = {}
> 
> obj2 = {
> 
>   "a": 1, 
> 
>   "b": 2
> 
> }
> 
> **输出：**{}
> 
> **解释：** obj1没有进行任何修改。obj2中出现了新的键 "a" 和 "b" ，但添加或删除的键应该被忽略。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：**
> 
> obj1 = {
> 
>   "a": 1,
> 
>   "v": 3,
> 
>   "x": [],
> 
>   "z": {
> 
> > 
> "a": null
> 
>   }
> 
> }
> 
> obj2 = {
> 
>   "a": 2,
> 
>   "v": 4,
> 
>   "x": [],
> 
>   "z": {
> 
> > 
> "a": 2
> 
>   }
> 
> }
> 
> **输出：**
> 
> {
> 
>   "a": [1, 2],
> 
>   "v": [3, 4],
> 
>   "z": {
> 
> > 
> "a": [null, 2]
> 
>   }
> 
> }
> 
> **解释：** 键 "a"、"v" 和 "z" 都有变化。"a" 从 1 变为 2，"v" 从 3 变为 4 ，"z" 的子对象 "a" 从 null 变为 2。
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：**
> 
> obj1 = {
> 
>   "a": 5, 
> 
>   "v": 6, 
> 
>   "z": [1, 2, 4, [2, 5, 7]]
> 
> }
> 
> obj2 = {
> 
>   "a": 5, 
> 
>   "v": 7, 
> 
>   "z": [1, 2, 3, [1]]
> 
> }
> 
> **输出：**
> 
> {
> 
>   "v": [6, 7],
> 
>   "z": {
> 
> > 
> "2": [4, 3],
> 
> > 
> "3": {
> 
> > 
>   "0": [2, 1]
> 
> > 
> }
> 
>   }
> 
> }
> 
> **解释：** 在 obj1 和 obj2 中，键 "v" 和 "z" 的值不同。"a" 被忽略，因为值没有变化。在键 "z" 中，有一个嵌套的数组。数组被视为对象，其中索引被视为键。数组发生了两处变化：z[2] 和 z[3][0]。z[0] 和 z[1] 没有变化，因此没有包含在结果中。z[3][1] 和 z[3][2] 被删除，因此也没有包含在结果中。
> 
> 

**示例 4：**

> 
> 
> 
> 
> 
> **输入：**
> 
> obj1 = {
> 
>   "a": {"b": 1}, 
> 
> }
> 
> obj2 = {
> 
>   "a": [5],
> 
> }
> 
> **输出：**
> 
> {
> 
>   "a": [{"b": 1}, [5]]
> 
> }
> 
> **解释：** 键 "a" 在两个对象中都存在。但由于两个相关值具有不同的类型，所以它们被放置在差异数组中。

**示例 5：**

> 
> 
> 
> 
> 
> **输入：**
> 
> obj1 = {
> 
>   "a": [1, 2, {}], 
> 
>   "b": false
> 
> }
> 
> obj2 = {   
> 
>   "b": false,
> 
>   "a": [1, 2, {}]
> 
> }
> 
> **输出：**
> 
> {}
> 
> **解释：** 除了键的顺序不同之外，两个对象是相同的，因此返回一个空对象。



**提示：**

  * `obj1` 和 `obj2` 都是有效的 JSON 对象或数组
  * `2 <= JSON.stringify(obj1).length <= 10^4`
  * `2 <= JSON.stringify(obj2).length <= 10^4`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2628 | [完全相等的 JSON 字符串](https://leetcode.com/problems/json-deep-equal) |  |  | <font color=#ffb800>Medium</font> |
| 2633 | [将对象转换为 JSON 字符串](https://leetcode.com/problems/convert-object-to-json-string) |  |  | <font color=#ffb800>Medium</font> |