---
title: 1804. 实现 Trie （前缀树） II 🔒
description: LeetCode 1804. 实现 Trie （前缀树） II 🔒题解，Implement Trie II (Prefix Tree)，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1804. 实现 Trie （前缀树） II 🔒
  - 实现 Trie （前缀树） II
  - Implement Trie II (Prefix Tree)
  - 解题思路
  - 设计
  - 字典树
  - 哈希表
  - 字符串
---

# 1804. 实现 Trie （前缀树） II 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/implement-trie-ii-prefix-tree) [`LeetCode`](https://leetcode.com/problems/implement-trie-ii-prefix-tree)

## 题目

A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as "try") or
**prefix tree** is a tree data structure used to efficiently store and
retrieve keys in a dataset of strings. There are various applications of this
data structure, such as autocomplete and spellchecker.

Implement the Trie class:

  * `Trie()` Initializes the trie object.
  * `void insert(String word)` Inserts the string `word` into the trie.
  * `int countWordsEqualTo(String word)` Returns the number of instances of the string `word` in the trie.
  * `int countWordsStartingWith(String prefix)` Returns the number of strings in the trie that have the string `prefix` as a prefix.
  * `void erase(String word)` Erases the string `word` from the trie.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Trie", "insert", "insert", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsStartingWith"]
> 
> [[], ["apple"], ["apple"], ["apple"], ["app"], ["apple"], ["apple"], ["app"], ["apple"], ["app"]]
> 
> **Output**
> 
> [null, null, null, 2, 2, null, 1, 1, null, 0]
> 
> 
> 
> **Explanation**
> 
> Trie trie = new Trie();
> 
> trie.insert("apple");> 
> > 
> > 
>    // Inserts "apple".
> 
> trie.insert("apple");> 
> > 
> > 
>    // Inserts another "apple".
> 
> trie.countWordsEqualTo("apple");> 
> // There are two instances of "apple" so return 2.
> 
> trie.countWordsStartingWith("app"); // "app" is a prefix of "apple" so return 2.
> 
> trie.erase("apple");> 
> > 
> > 
> > 
> // Erases one "apple".
> 
> trie.countWordsEqualTo("apple");> 
> // Now there is only one instance of "apple" so return 1.
> 
> trie.countWordsStartingWith("app"); // return 1
> 
> trie.erase("apple");> 
> > 
> > 
> > 
> // Erases "apple". Now the trie is empty.
> 
> trie.countWordsStartingWith("app"); // return 0

**Constraints:**

  * `1 <= word.length, prefix.length <= 2000`
  * `word` and `prefix` consist only of lowercase English letters.
  * At most `3 * 10^4` calls **in total** will be made to `insert`, `countWordsEqualTo`, `countWordsStartingWith`, and `erase`.
  * It is guaranteed that for any function call to `erase`, the string `word` will exist in the trie.


## 题目大意

前缀树（**[trie](https://en.wikipedia.org/wiki/Trie)** ，发音为
"try"）是一个树状的数据结构，用于高效地存储和检索一系列字符串的前缀。前缀树有许多应用，如自动补全和拼写检查。

实现前缀树 Trie 类：

  * `Trie()` 初始化前缀树对象。
  * `void insert(String word)` 将字符串 `word` 插入前缀树中。
  * `int countWordsEqualTo(String word)` 返回前缀树中字符串 `word` 的实例个数。
  * `int countWordsStartingWith(String prefix)` 返回前缀树中以 `prefix` 为前缀的字符串个数。
  * `void erase(String word)` 从前缀树中移除字符串 `word` 。

**示例 1:**

> 
> 
> 
> 
> 
> **输入**
> 
> ["Trie", "insert", "insert", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsStartingWith"]
> 
> [[], ["apple"], ["apple"], ["apple"], ["app"], ["apple"], ["apple"], ["app"], ["apple"], ["app"]]
> 
> **输出**
> 
> [null, null, null, 2, 2, null, 1, 1, null, 0]
> 
> 
> 
> **解释**
> 
> Trie trie = new Trie();
> 
> trie.insert("apple");> 
> > 
> > 
>    // 插入 "apple"。
> 
> trie.insert("apple");> 
> > 
> > 
>    // 插入另一个 "apple"。
> 
> trie.countWordsEqualTo("apple");> 
> // 有两个 "apple" 实例，所以返回 2。
> 
> trie.countWordsStartingWith("app"); // "app" 是 "apple" 的前缀，所以返回 2。
> 
> trie.erase("apple");> 
> > 
> > 
> > 
> // 移除一个 "apple"。
> 
> trie.countWordsEqualTo("apple");> 
> // 现在只有一个 "apple" 实例，所以返回 1。
> 
> trie.countWordsStartingWith("app"); // 返回 1
> 
> trie.erase("apple");> 
> > 
> > 
> > 
> // 移除 "apple"。现在前缀树是空的。
> 
> trie.countWordsStartingWith("app"); // 返回 0
> 
> 

**提示：**

  * `1 <= word.length, prefix.length <= 2000`
  * `word` 和 `prefix` 只包含小写英文字母。
  * `insert`、 `countWordsEqualTo`、 `countWordsStartingWith` 和 `erase` **总共** 调用最多 `3 * 10^4` 次。
  * 保证每次调用 `erase` 时，字符串 `word` 总是存在于前缀树中。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 208 | 实现 Trie (前缀树) | [[✓]](/problem/0208.md) |  [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`哈希表`](/tag/hash-table.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/implement-trie-prefix-tree) [🔗](https://leetcode.com/problems/implement-trie-prefix-tree) |
| 2227 | 加密解密字符串 |  |  [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/encrypt-and-decrypt-strings) [🔗](https://leetcode.com/problems/encrypt-and-decrypt-strings) |