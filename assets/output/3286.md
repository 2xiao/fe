---
title: 3286. 穿越网格图的安全路径
description: LeetCode 3286. 穿越网格图的安全路径题解，Find a Safe Walk Through a Grid，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3286. 穿越网格图的安全路径
  - 穿越网格图的安全路径
  - Find a Safe Walk Through a Grid
  - 解题思路
  - 广度优先搜索
  - 图
  - 数组
  - 矩阵
  - 最短路
  - 堆（优先队列）
---

# 3286. 穿越网格图的安全路径

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) [`最短路`](/tag/shortest-path.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-a-safe-walk-through-a-grid) [`LeetCode`](https://leetcode.com/problems/find-a-safe-walk-through-a-grid)

## 题目

You are given an `m x n` binary matrix `grid` and an integer `health`.

You start on the upper-left corner `(0, 0)` and would like to get to the
lower-right corner `(m - 1, n - 1)`.

You can move up, down, left, or right from one cell to another adjacent cell
as long as your health _remains_ **positive**.

Cells `(i, j)` with `grid[i][j] = 1` are considered **unsafe** and reduce your
health by 1.

Return `true` if you can reach the final cell with a health value of 1 or
more, and `false` otherwise.



**Example 1:**

**Input:** grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1

**Output:** true

**Explanation:**

The final cell can be reached safely by walking along the gray cells below.

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png)

**Example 2:**

**Input:** grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]],
health = 3

**Output:** false

**Explanation:**

A minimum of 4 health points is needed to reach the final cell safely.

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png)

**Example 3:**

**Input:** grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5

**Output:** true

**Explanation:**

The final cell can be reached safely by walking along the gray cells below.

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png)

Any path that does not go through the cell `(1, 1)` is unsafe since your
health will drop to 0 when reaching the final cell.



**Constraints:**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 50`
  * `2 <= m * n`
  * `1 <= health <= m + n`
  * `grid[i][j]` is either 0 or 1.


## 题目大意

给你一个 `m x n` 的二进制矩形 `grid` 和一个整数 `health` 表示你的健康值。

你开始于矩形的左上角 `(0, 0)` ，你的目标是矩形的右下角 `(m - 1, n - 1)` 。

你可以在矩形中往上下左右相邻格子移动，但前提是你的健康值始终是 **正数**  。

对于格子 `(i, j)` ，如果 `grid[i][j] = 1` ，那么这个格子视为 **不安全**  的，会使你的健康值减少 1 。

如果你可以到达最终的格子，请你返回 `true` ，否则返回 `false` 。

**注意**  ，当你在最终格子的时候，你的健康值也必须为**  正数** 。



**示例 1：**

**输入：** grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1

**输出：** true

**解释：**

沿着下图中灰色格子走，可以安全到达最终的格子。

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png)

**示例 2：**

**输入：** grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]],
health = 3

**输出：** false

**解释：**

健康值最少为 4 才能安全到达最后的格子。

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png)

**示例 3：**

**输入：** grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5

**输出：** true

**解释：**

沿着下图中灰色格子走，可以安全到达最终的格子。

![](https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png)

任何不经过格子 `(1, 1)` 的路径都是不安全的，因为你的健康值到达最终格子时，都会小于等于 0 。



**提示：**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 50`
  * `2 <= m * n`
  * `1 <= health <= m + n`
  * `grid[i][j]` 要么是 0 ，要么是 1 。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1293 | 网格中的最短路径 |  |  [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | 🔴 | [🀄️](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination) [🔗](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination) |