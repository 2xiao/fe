---
title: 1810. 隐藏网格下的最小消耗路径 🔒
description: LeetCode,1810. 隐藏网格下的最小消耗路径 🔒,隐藏网格下的最小消耗路径,Minimum Path Cost in a Hidden Grid,解题思路,深度优先搜索,广度优先搜索,图,交互,堆（优先队列）
keywords:
  - LeetCode
  - 1810. 隐藏网格下的最小消耗路径 🔒
  - 隐藏网格下的最小消耗路径
  - Minimum Path Cost in a Hidden Grid
  - 解题思路
  - 深度优先搜索
  - 广度优先搜索
  - 图
  - 交互
  - 堆（优先队列）
---

# 1810. 隐藏网格下的最小消耗路径 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) [`交互`](/tag/interactive.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid) [`LeetCode`](https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid)

## 题目

This is an **interactive problem**.

There is a robot in a hidden grid, and you are trying to get it from its
starting cell to the target cell in this grid. The grid is of size `m x n`,
and each cell in the grid is either empty or blocked. It is **guaranteed**
that the starting cell and the target cell are different, and neither of them
is blocked.

Each cell has a **cost** that you need to pay each time you **move** to the
cell. The starting cell's cost is **not** applied before the robot moves.

You want to find the minimum total cost to move the robot to the target cell.
However, you **do not know** the grid's dimensions, the starting cell, nor the
target cell. You are only allowed to ask queries to the `GridMaster` object.

The `GridMaster` class has the following functions:

  * `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.
  * `int move(char direction)` Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored** , the robot will remain in the same position, and the function will return `-1`.
  * `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from
`{'U','D','L','R'}`, representing the directions up, down, left, and right,
respectively.

Return _the**minimum total cost** to get the robot from its initial starting
cell to the target cell. If there is no valid path between the cells, return
_`-1`.

**Custom testing:**

The test input is read as a 2D matrix `grid` of size `m x n` and four integers
`r1`, `c1`, `r2`, and `c2` where:

  * `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.
  * `grid[i][j] >= 1` indicates that the cell `(i, j)` is empty and `grid[i][j]` is the **cost** to move to that cell.
  * `(r1, c1)` is the starting cell of the robot.
  * `(r2, c2)` is the target cell of the robot.

Remember that you will **not** have this information in your code.



**Example 1:**

> Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
> 
> Output: 2
> 
> Explanation: One possible interaction is described below:
> 
> The robot is initially standing on cell (0, 1), denoted by the 3.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns true.
> - master.canMove('R') returns false.
> - master.move('L') moves the robot to the cell (0, 0) and returns 2.
> - master.isTarget() returns false.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns false.
> - master.canMove('R') returns true.
> - master.move('D') moves the robot to the cell (1, 0) and returns 1.
> - master.isTarget() returns true.
> - master.move('L') doesn't move the robot and returns -1.
> - master.move('R') moves the robot to the cell (1, 1) and returns 1.
> 
> We now know that the target is the cell (1, 0), and the minimum total cost to reach it is 2. 

**Example 2:**

> Input: grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
> 
> Output: 9
> 
> Explanation: The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).

**Example 3:**

> Input: grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
> 
> Output: -1
> 
> Explanation: There is no path from the robot to the target cell.

**Constraints:**

  * `1 <= n, m <= 100`
  * `m == grid.length`
  * `n == grid[i].length`
  * `0 <= grid[i][j] <= 100`


## 题目大意

这是一个交互问题。

有一个机器人存在于网格中，你需要通过不断尝试使他从初始单元到达目标单元。网格的规格为m x n，并且每个单元的属性值要不为空，要不已被占用。题目**保证**
初始网格和目标网格不同且均为空。

每个单元格都有**消耗** 值，你需要在每次**移动** 至此单元格后支付该费用。在机器人启动前，初始单元的费用不被计算在内。

你需要找到机器人移动至目标网格的最小总消耗。但可惜的是你并**不知道**
网格的尺寸、初始单元和目标单元。你只允许通过询问`GridMaster`类获得信息。

`GridMaster`类存在以下功能：

  * `boolean canMove(char direction)` 当机器人可以向这个方向移动时，返回`true`；反之返回`false`。
  * `int move(char direction)` 沿该方向移动机器人，并返回移动到该单元的消耗值。如果此移动将机器人移动到被占有的单元格或离开网格，则移动将被**忽略** ，机器人将保持在相同的位置，函数将返回`-1`。
  * `boolean isTarget()` ：如果机器人当前位于目标单元格上，则返回`true`；反之返回 `false` 。

请注意，上述函数中的方向应该是`{ 'U'、'D'、'L'、'R' }`中的字符，分别表示向上、向下、左和右方向。

返回使机器人从其初始起始单元到目标单元的**最小总消耗** 。如果单元格之间不存在有效路径，则返回`-1`。

**测试实例:**

测试输入一个大小为`m x n`的二维数组 `grid` 和四个`int`型参数 `r1`, `c1`, `r2`, 和 `c2` :

  * `grid[i][j] == 0` 表示网格 `(i, j)` 已被占用。
  * `grid[i][j] >= 1` 表示网格单元 `(i, j)` 为空并且 `grid[i][j]` 的值为移动至此网格的成本值。
  * `(r1, c1)` 为初始单元。
  * `(r2, c2)` 为目标单元。

请注意，你将无法在你的代码中获知这些信息。

**示例 1:**

> 
> 
> 
> 
> 
> **输入:** grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
> 
> **输出:** 2
> 
> **解释:** 其中一种可能路径描述如下：
> 
> 机器人最开始站在单元格 (0, 1) ，用 3 表示
> - master.canMove('U') 返回 false
> - master.canMove('D') 返回 true
> - master.canMove('L') 返回 true
> - master.canMove('R') 返回 false
> - master.move('L') 机器人移动到单元格 (0, 0) 并返回 2
> - master.isTarget() 返回 false
> - master.canMove('U') 返回 false
> - master.canMove('D') 返回 true
> - master.canMove('L') 返回 false
> - master.canMove('R') 返回 true
> - master.move('D') 机器人移动到单元格 (1, 0) 并返回 1
> - master.isTarget() 返回 true
> - master.move('L') 机器人不移动并返回 -1
> - master.move('R') 机器人移动到单元格 (1, 1) 并返回 1
> 
> 现在我们知道了机器人达到目标单元(1, 0)的最小消耗成本为2。 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
> 
> **输出:** 9
> 
> **解释:** 最小消耗路径为 (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).
> 
> 

**示例 3:**

> 
> 
> 
> 
> 
> **输入:** grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
> 
> **输出:** -1
> 
> **解释:** 不存在可使机器人到达目标单元的路径。
> 
> 

**提示:**

  * `1 <= n, m <= 100`
  * `m == grid.length`
  * `n == grid[i].length`
  * `0 <= grid[i][j] <= 100`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 489 | [扫地机器人 🔒](https://leetcode.com/problems/robot-room-cleaner) |  |  [`回溯`](/tag/backtracking.md) [`交互`](/tag/interactive.md) | <font color=#ff334b>Hard</font> |
| 1778 | [未知网格中的最短路径 🔒](https://leetcode.com/problems/shortest-path-in-a-hidden-grid) |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> |