# [348. 设计井字棋 🔒](https://2xiao.github.io/leetcode-js/problem/0348.html)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`矩阵`](/tag/matrix.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/design-tic-tac-toe) [`LeetCode`](https://leetcode.com/problems/design-tic-tac-toe)

## 题目

Assume the following rules are for the tic-tac-toe game on an `n x n` board
between two players:

  1. A move is guaranteed to be valid and is placed on an empty block.
  2. Once a winning condition is reached, no more moves are allowed.
  3. A player who succeeds in placing `n` of their marks in a horizontal, vertical, or diagonal row wins the game.

Implement the `TicTacToe` class:

  * `TicTacToe(int n)` Initializes the object the size of the board `n`.
  * `int move(int row, int col, int player)` Indicates that the player with id `player` plays at the cell `(row, col)` of the board. The move is guaranteed to be a valid move, and the two players alternate in making moves. Return 
> 
> * `0` if there is **no winner** after the move,
> 
> * `1` if **player 1** is the winner after the move, or
> 
> * `2` if **player 2** is the winner after the move.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["TicTacToe", "move", "move", "move", "move", "move", "move", "move"]
> 
> [[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]
> 
> **Output**
> 
> [null, 0, 0, 0, 0, 0, 0, 1]
> 
> 
> 
> **Explanation**
> 
> TicTacToe ticTacToe = new TicTacToe(3);
> 
> Assume that player 1 is "X" and player 2 is "O" in the board.
> 
> ticTacToe.move(0, 0, 1); // return 0 (no one wins)
> 
> |X| | |
> 
> | | | |> 
> // Player 1 makes a move at (0, 0).
> 
> | | | |
> 
> 
> 
> ticTacToe.move(0, 2, 2); // return 0 (no one wins)
> 
> |X| |O|
> 
> | | | |> 
> // Player 2 makes a move at (0, 2).
> 
> | | | |
> 
> 
> 
> ticTacToe.move(2, 2, 1); // return 0 (no one wins)
> 
> |X| |O|
> 
> | | | |> 
> // Player 1 makes a move at (2, 2).
> 
> | | |X|
> 
> 
> 
> ticTacToe.move(1, 1, 2); // return 0 (no one wins)
> 
> |X| |O|
> 
> | |O| |> 
> // Player 2 makes a move at (1, 1).
> 
> | | |X|
> 
> 
> 
> ticTacToe.move(2, 0, 1); // return 0 (no one wins)
> 
> |X| |O|
> 
> | |O| |> 
> // Player 1 makes a move at (2, 0).
> 
> |X| |X|
> 
> 
> 
> ticTacToe.move(1, 0, 2); // return 0 (no one wins)
> 
> |X| |O|
> 
> |O|O| |> 
> // Player 2 makes a move at (1, 0).
> 
> |X| |X|
> 
> 
> 
> ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)
> 
> |X| |O|
> 
> |O|O| |> 
> // Player 1 makes a move at (2, 1).
> 
> |X|X|X|

**Constraints:**

  * `2 <= n <= 100`
  * player is `1` or `2`.
  * `0 <= row, col < n`
  * `(row, col)` are **unique** for each different call to `move`.
  * At most `n2` calls will be made to `move`.



**Follow-up:** Could you do better than `O(n2)` per `move()` operation?


## 题目大意

请在 n × n 的棋盘上，实现一个判定井字棋（Tic-Tac-Toe）胜负的神器，判断每一次玩家落子后，是否有胜出的玩家。

在这个井字棋游戏中，会有 2 名玩家，他们将轮流在棋盘上放置自己的棋子。

在实现这个判定器的过程中，你可以假设以下这些规则一定成立：

> 
>   1\. 每一步棋都是在棋盘内的，并且只能被放置在一个空的格子里；

> 
>   2\. 一旦游戏中有一名玩家胜出的话，游戏将不能再继续；

> 
>   3\. 一个玩家如果在同一行、同一列或者同一斜对角线上都放置了自己的棋子，那么他便获得胜利。

**示例:**

> 
> 
> 
> 
> 
> 给定棋盘边长 _n_ = 3, 玩家 1 的棋子符号是 "X"，玩家 2 的棋子符号是 "O"。
> 
> 
> 
> TicTacToe toe = new TicTacToe(3);
> 
> 
> 
> toe.move(0, 0, 1); -> 函数返回 0 (此时，暂时没有玩家赢得这场对决)
> 
> |X| | |
> 
> | | | |> 
> // 玩家 1 在 (0, 0) 落子。
> 
> | | | |
> 
> 
> 
> toe.move(0, 2, 2); -> 函数返回 0 (暂时没有玩家赢得本场比赛)
> 
> |X| |O|
> 
> | | | |> 
> // 玩家 2 在 (0, 2) 落子。
> 
> | | | |
> 
> 
> 
> toe.move(2, 2, 1); -> 函数返回 0 (暂时没有玩家赢得比赛)
> 
> |X| |O|
> 
> | | | |> 
> // 玩家 1 在 (2, 2) 落子。
> 
> | | |X|
> 
> 
> 
> toe.move(1, 1, 2); -> 函数返回 0 (暂没有玩家赢得比赛)
> 
> |X| |O|
> 
> | |O| |> 
> // 玩家 2 在 (1, 1) 落子。
> 
> | | |X|
> 
> 
> 
> toe.move(2, 0, 1); -> 函数返回 0 (暂无玩家赢得比赛)
> 
> |X| |O|
> 
> | |O| |> 
> // 玩家 1 在 (2, 0) 落子。
> 
> |X| |X|
> 
> 
> 
> toe.move(1, 0, 2); -> 函数返回 0 (没有玩家赢得比赛)
> 
> |X| |O|
> 
> |O|O| |> 
> // 玩家 2 在 (1, 0) 落子.
> 
> |X| |X|
> 
> 
> 
> toe.move(2, 1, 1); -> 函数返回 1 (此时，玩家 1 赢得了该场比赛)
> 
> |X| |O|
> 
> |O|O| |> 
> // 玩家 1 在 (2, 1) 落子。
> 
> |X|X|X|
> 
> 



**进阶:**  
您有没有可能将每一步的 `move()` 操作优化到比 O(_n_ 2) 更快吗?


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 794 | [有效的井字游戏](https://leetcode.com/problems/valid-tic-tac-toe-state) |  |  [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | <font color=#ffb800>Medium</font> |