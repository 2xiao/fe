# [251. 展开二维向量](https://leetcode.com/problems/flatten-2d-vector)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) [`迭代器`](/tag/iterator.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/flatten-2d-vector)

## 题目

Design an iterator to flatten a 2D vector. It should support the `next` and
`hasNext` operations.

Implement the `Vector2D` class:

  * `Vector2D(int[][] vec)` initializes the object with the 2D vector `vec`.
  * `next()` returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to `next` are valid.
  * `hasNext()` returns `true` if there are still some elements in the vector, and `false` otherwise.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Vector2D", "next", "next", "next", "hasNext", "hasNext", "next", "hasNext"]
> 
> [[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]
> 
> **Output**
> 
> [null, 1, 2, 3, true, true, 4, false]
> 
> 
> 
> **Explanation**
> 
> Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]);
> 
> vector2D.next();> 
> // return 1
> 
> vector2D.next();> 
> // return 2
> 
> vector2D.next();> 
> // return 3
> 
> vector2D.hasNext(); // return True
> 
> vector2D.hasNext(); // return True
> 
> vector2D.next();> 
> // return 4
> 
> vector2D.hasNext(); // return False

**Constraints:**

  * `0 <= vec.length <= 200`
  * `0 <= vec[i].length <= 500`
  * `-500 <= vec[i][j] <= 500`
  * At most `10^5` calls will be made to `next` and `hasNext`.



**Follow up:** As an added challenge, try to code it using only [iterators in
C++](http://www.cplusplus.com/reference/iterator/iterator/) or [iterators in
Java](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html).


## 题目大意

请设计并实现一个能够展开二维向量的迭代器。该迭代器需要支持 `next` 和 `hasNext` 两种操作。

实现 `Vector2D` 类：

  * `Vector2D(int[][] vec)` 使用二维向量 `vec` 初始化对象
  * `next()` 从二维向量返回下一个元素并将指针移动到下一个位置。你可以假设对 `next` 的所有调用都是合法的。
  * `hasNext()` 当向量中还有元素返回 `true`，否则返回 `false`。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：**
> 
> ["Vector2D", "next", "next", "next", "hasNext", "hasNext", "next", "hasNext"]
> 
> [[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]
> 
> **输出：**
> 
> [null, 1, 2, 3, true, true, 4, false]
> 
> 
> 
> **解释：**
> 
> Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]);
> 
> vector2D.next();> 
> // return 1
> 
> vector2D.next();> 
> // return 2
> 
> vector2D.next();> 
> // return 3
> 
> vector2D.hasNext(); // return True
> 
> vector2D.hasNext(); // return True
> 
> vector2D.next();> 
> // return 4
> 
> vector2D.hasNext(); // return False
> 
> 



**提示：**

  * `0 <= vec.length <= 200`
  * `0 <= vec[i].length <= 500`
  * `-500 <= vec[i][j] <= 500`
  * 最多调用 `next` 和 `hasNext` `10^5` 次。



**进阶：** 尝试在代码中仅使用 [C++
提供的迭代器](http://www.cplusplus.com/reference/iterator/iterator/) 或 [Java
提供的迭代器](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 173 | [二叉搜索树迭代器](https://leetcode.com/problems/binary-search-tree-iterator) | [[✓]](/problem/0173.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) `3+` | <font color=#ffb800>Medium</font> |
| 281 | [锯齿迭代器](https://leetcode.com/problems/zigzag-iterator) |  |  [`设计`](/tag/design.md) [`队列`](/tag/queue.md) [`数组`](/tag/array.md) `1+` | <font color=#ffb800>Medium</font> |
| 284 | [窥视迭代器](https://leetcode.com/problems/peeking-iterator) |  |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`迭代器`](/tag/iterator.md) | <font color=#ffb800>Medium</font> |
| 341 | [扁平化嵌套列表迭代器](https://leetcode.com/problems/flatten-nested-list-iterator) |  |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `3+` | <font color=#ffb800>Medium</font> |