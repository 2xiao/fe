# [1500. 设计文件分享系统](https://leetcode.com/problems/design-a-file-sharing-system)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`数据流`](/tag/data-stream.md) [`排序`](/tag/sorting.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/design-a-file-sharing-system)

## 题目

We will use a file-sharing system to share a very large file which consists of
`m` small **chunks** with IDs from `1` to `m`.

When users join the system, the system should assign **a unique** ID to them.
The unique ID should be used **once** for each user, but when a user leaves
the system, the ID can be **reused** again.

Users can request a certain chunk of the file, the system should return a list
of IDs of all the users who own this chunk. If the user receives a non-empty
list of IDs, they receive the requested chunk successfully.

  
Implement the `FileSharing` class:

  * `FileSharing(int m)` Initializes the object with a file of `m` chunks.
  * `int join(int[] ownedChunks)`: A new user joined the system owning some chunks of the file, the system should assign an id to the user which is the **smallest positive integer** not taken by any other user. Return the assigned id.
  * `void leave(int userID)`: The user with `userID` will leave the system, you cannot take file chunks from them anymore.
  * `int[] request(int userID, int chunkID)`: The user `userID` requested the file chunk with `chunkID`. Return a list of the IDs of all users that own this chunk sorted in ascending order.



**Example:**

> Input:
> 
> ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
> 
> [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
> 
> Output:
> 
> [null,1,2,3,[2],[1,2],null,[],null,1]
> 
> Explanation:
> 
> FileSharing fileSharing = new FileSharing(4); // We use the system to share a file of 4 chunks.
> 
> 
> 
> fileSharing.join([1, 2]);> 
> // A user who has chunks [1,2] joined the system, assign id = 1 to them and return 1.
> 
> 
> 
> fileSharing.join([2, 3]);> 
> // A user who has chunks [2,3] joined the system, assign id = 2 to them and return 2.
> 
> 
> 
> fileSharing.join([4]);> 
>    // A user who has chunk [4] joined the system, assign id = 3 to them and return 3.
> 
> 
> 
> fileSharing.request(1, 3);   // The user with id = 1 requested the third file chunk, as only the user with id = 2 has the file, return [2] . Notice that user 1 now has chunks [1,2,3].
> 
> 
> 
> fileSharing.request(2, 2);   // The user with id = 2 requested the second file chunk, users with ids [1,2] have this chunk, thus we return [1,2].
> 
> 
> 
> fileSharing.leave(1);> 
> > 
> // The user with id = 1 left the system, all the file chunks with them are no longer available for other users.
> 
> 
> 
> fileSharing.request(2, 1);   // The user with id = 2 requested the first file chunk, no one in the system has this chunk, we return empty list [].
> 
> 
> 
> fileSharing.leave(2);> 
> > 
> // The user with id = 2 left the system.
> 
> 
> 
> fileSharing.join([]);> 
> > 
> // A user who doesn't have any chunks joined the system, assign id = 1 to them and return 1. Notice that ids 1 and 2 are free and we can reuse them.

**Constraints:**

  * `1 <= m <= 10^5`
  * `0 <= ownedChunks.length <= min(100, m)`
  * `1 <= ownedChunks[i] <= m`
  * Values of `ownedChunks` are unique.
  * `1 <= chunkID <= m`
  * `userID` is guaranteed to be a user in the system if you **assign** the IDs **correctly**.
  * At most `10^4` calls will be made to `join`, `leave` and `request`.
  * Each call to `leave` will have a matching call for `join`.



**Follow-up:**

  * What happens if the system identifies the user by their IP address instead of their unique ID and users disconnect and connect from the system with the same IP?
  * If the users in the system join and leave the system frequently without requesting any chunks, will your solution still be efficient?
  * If all users join the system one time, request all files, and then leave, will your solution still be efficient?
  * If the system will be used to share `n` files where the `ith` file consists of `m[i]`, what are the changes you have to make?


## 题目大意

我们需要使用一套文件分享系统来分享一个非常大的文件，该文件由 `m` 个从 `1` 到 `m` 编号的 **文件块** 组成。

当用户加入系统时，系统应为其注册 **一个独有  **的 ID。这个独有的 ID 应当被相应的用户使用 **一次** ，但是当用户离开系统时，其 ID
应可以被（后续新注册的用户）**再次使用** 。

用户可以请求文件中的某个指定的文件块，系统应当返回拥有这个文件块的所有用户的 ID。如果用户收到 ID 的非空列表，就表示成功接收到请求的文件块。

  
实现 `FileSharing` 类：

  * `FileSharing(int m)` 初始化该对象，文件有 `m` 个文件块。
  * `int join(int[] ownedChunks)`：一个新用户加入系统，并拥有文件的一些文件块。系统应当为该用户注册一个 ID，该 ID 应是未被其他用户占用的**最小正整数** 。返回注册的 ID。
  * `void leave(int userID)`：ID 为 `userID` 的用户将离开系统，你不能再从该用户提取文件块了。
  * `int[] request(int userID, int chunkID)`：ID 为 `userID` 的用户请求编号为 `chunkID` 的文件块。返回拥有这个文件块的所有用户的 ID 所构成的列表或数组，按升序排列。



**示例:**

> 
> 
> 
> 
> 
> **输入:**
> 
> ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
> 
> [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
> 
> **输出:**
> 
> [null,1,2,3,[2],[1,2],null,[],null,1]
> 
> **解释:**
> 
> FileSharing fileSharing = new FileSharing(4); // 我们用该系统分享由 4 个文件块组成的文件。
> 
> 
> 
> fileSharing.join([1, 2]);> 
> // 一个拥有文件块 [1,2] 的用户加入系统，为其注册 id = 1 并返回 1。
> 
> 
> 
> fileSharing.join([2, 3]);> 
> // 一个拥有文件块 [2,3] 的用户加入系统，为其注册 id = 2 并返回 2。
> 
> 
> 
> fileSharing.join([4]);> 
>    // 一个拥有文件块 [4] 的用户加入系统，为其注册 id = 3 并返回 3。
> 
> 
> 
> fileSharing.request(1, 3);   // id = 1 的用户请求第 3 个文件块，只有 id = 2 的用户拥有文件块，返回 [2] 。注意，现在用户 1 现拥有文件块 [1,2,3]。
> 
> 
> 
> fileSharing.request(2, 2);   // id = 2 的用户请求第 2 个文件块，id 为 [1,2] 的用户拥有该文件块，所以我们返回 [1,2] 。
> 
> 
> 
> fileSharing.leave(1);> 
> > 
> // id = 1 的用户离开系统，其所拥有的所有文件块不再对其他用户可用。
> 
> 
> 
> fileSharing.request(2, 1);   // id = 2 的用户请求第 1 个文件块，系统中没有用户拥有该文件块，所以我们返回空列表 [] 。
> 
> 
> 
> fileSharing.leave(2);> 
> > 
> // id = 2 的用户离开系统。
> 
> 
> 
> fileSharing.join([]);> 
> > 
> // 一个不拥有任何文件块的用户加入系统，为其注册 id = 1 并返回 1 。注意，id 1 和 2 空闲，可以重新使用。
> 
> 



**提示:**

  * `1 <= m <= 10^5`
  * `0 <= ownedChunks.length <= min(100, m)`
  * `1 <= ownedChunks[i] <= m`
  * `ownedChunks` 的值是互不相同的。
  * `1 <= chunkID <= m`
  * 当你**正确地注册** 用户 ID 时，题目保证 `userID` 是系统中的一个已注册用户。
  * `join`、 `leave` 和 `request` 最多被调用 `10^4` 次。
  * 每次对 `leave` 的调用都有对应的对 `join` 的调用。



**进阶：**

  * 当系统以用户的 IP 地址而不是独有 ID 来识别用户，且用户断开连接后以相同 IP 重新连接系统时，会发生什么？
  * 当用户频繁加入并退出系统，且该用户不请求任何文件块时，你的解决方案仍然保持高效吗？
  * 当所有用户同时加入系统，请求所有文件并离开时，你的解决方案仍然保持高效吗？
  * 如果系统用于分享 `n` 个文件，其中第  `i` 个文件由 `m[i]` 组成，你需要如何修改？


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 355 | [设计推特](https://leetcode.com/problems/design-twitter) | [[✓]](/problem/0355.md) |  [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) `1+` | <font color=#ffb800>Medium</font> |