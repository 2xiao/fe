---
title: 1485. 克隆含随机指针的二叉树 🔒
description: LeetCode,1485. 克隆含随机指针的二叉树 🔒,克隆含随机指针的二叉树,Clone Binary Tree With Random Pointer,解题思路,树,深度优先搜索,广度优先搜索,哈希表,二叉树
keywords:
  - LeetCode
  - 1485. 克隆含随机指针的二叉树 🔒
  - 克隆含随机指针的二叉树
  - Clone Binary Tree With Random Pointer
  - 解题思路
  - 树
  - 深度优先搜索
  - 广度优先搜索
  - 哈希表
  - 二叉树
---

# 1485. 克隆含随机指针的二叉树 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`哈希表`](/tag/hash-table.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/clone-binary-tree-with-random-pointer) [`LeetCode`](https://leetcode.com/problems/clone-binary-tree-with-random-pointer)

## 题目

A binary tree is given such that each node contains an additional random
pointer which could point to any node in the tree or null.

Return a [**deep
copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the tree.

The tree is represented in the same input/output way as normal binary trees
where each node is represented as a pair of `[val, random_index]` where:

  * `val`: an integer representing `Node.val`
  * `random_index`: the index of the node (in the input) where the random pointer points to, or `null` if it does not point to any node.

You will be given the tree in class `Node` and you should return the cloned
tree in class `NodeCopy`. `NodeCopy` class is just a clone of `Node` class
with the same attributes and constructors.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/clone_1.png)

> Input: root = [[1,null],null,[4,3],[7,0]]
> 
> Output: [[1,null],null,[4,3],[7,0]]
> 
> Explanation: The original binary tree is [1,null,4,7].
> 
> The random pointer of node one is null, so it is represented as [1, null].
> 
> The random pointer of node 4 is node 7, so it is represented as [4, 3] where 3 is the index of node 7 in the array representing the tree.
> 
> The random pointer of node 7 is node 1, so it is represented as [7, 0] where 0 is the index of node 1 in the array representing the tree.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/clone_2.png)

> Input: root = [[1,4],null,[1,0],null,[1,5],[1,5]]
> 
> Output: [[1,4],null,[1,0],null,[1,5],[1,5]]
> 
> Explanation: The random pointer of a node can be the node itself.

**Example 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/clone_3.png)

> Input: root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
> 
> Output: [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]

**Constraints:**

  * The number of nodes in the `tree` is in the range `[0, 1000].`
  * `1 <= Node.val <= 10^6`


## 题目大意

给你一个二叉树，树中每个节点都含有一个附加的随机指针，该指针可以指向树中的任何节点或者指向空（`null`）。

请返回该树的
**[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)**
。

该树的输入/输出形式与普通二叉树相同，每个节点都用 `[val, random_index]` 表示：

  * `val`：表示 `Node.val` 的整数
  * `random_index`：随机指针指向的节点（在输入的树数组中）的下标；如果未指向任何节点，则为 `null` 。

该树以 `Node` 类的形式给出，而你需要以 `NodeCopy` 类的形式返回克隆得到的树。`NodeCopy` 类和`Node` 类定义一致。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/clone_1.png)

> 
> 
> 
> 
> 
> **输入：** root = [[1,null],null,[4,3],[7,0]]
> 
> **输出：**[[1,null],null,[4,3],[7,0]]
> 
> **解释：** 初始二叉树为 [1,null,4,7] 。
> 
> 节点 1 的随机指针指向 null，所以表示为 [1, null] 。
> 
> 节点 4 的随机指针指向 7，所以表示为 [4, 3] 其中 3 是树数组中节点 7 对应的下标。
> 
> 节点 7 的随机指针指向 1，所以表示为 [7, 0] 其中 0 是树数组中节点 1 对应的下标。
> 
> 

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/clone_2.png)

> 
> 
> 
> 
> 
> **输入：** root = [[1,4],null,[1,0],null,[1,5],[1,5]]
> 
> **输出：**[[1,4],null,[1,0],null,[1,5],[1,5]]
> 
> **解释：** 节点的随机指针可以指向它自身。
> 
> 

**示例 3：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1485.Clone%20Binary%20Tree%20With%20Random%20Pointer/images/e2.png)

> 
> 
> 
> 
> 
> **输入：** root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
> 
> **输出：**[[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
> 
> 



**提示：**

  * `tree` 中节点数目范围是 `[0, 1000]`
  * 每个节点的值的范围是 `[1, 10^6]`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 133 | [克隆图](https://leetcode.com/problems/clone-graph) | [[✓]](/problem/0133.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> |
| 138 | [随机链表的复制](https://leetcode.com/problems/copy-list-with-random-pointer) | [[✓]](/problem/0138.md) |  [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) | <font color=#ffb800>Medium</font> |
| 1490 | [克隆 N 叉树 🔒](https://leetcode.com/problems/clone-n-ary-tree) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | <font color=#ffb800>Medium</font> |