# [2277. 树中最接近路径的节点](https://leetcode.com/problems/closest-node-to-path-in-tree)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/closest-node-to-path-in-tree)

## 题目

You are given a positive integer `n` representing the number of nodes in a
tree, numbered from `0` to `n - 1` (**inclusive**). You are also given a 2D
integer array `edges` of length `n - 1`, where `edges[i] = [node1i, node2i]`
denotes that there is a **bidirectional** edge connecting `node1i` and
`node2i` in the tree.

You are given a **0-indexed** integer array `query` of length `m` where
`query[i] = [starti, endi, nodei]` means that for the `ith` query, you are
tasked with finding the node on the path from `starti` to `endi` that is
**closest** to `nodei`.

Return _an integer array_`answer` _of length_`m` _, where_`answer[i]`_is the
answer to the_`ith` _query_.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132158-1.png)

> Input: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]
> 
> Output: [0,2]
> 
> Explanation:
> 
> The path from node 5 to node 3 consists of the nodes 5, 2, 0, and 3.
> 
> The distance between node 4 and node 0 is 2.
> 
> Node 0 is the node on the path closest to node 4, so the answer to the first query is 0.
> 
> The distance between node 6 and node 2 is 1.
> 
> Node 2 is the node on the path closest to node 6, so the answer to the second query is 2.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132318-2.png)

> Input: n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]
> 
> Output: [1]
> 
> Explanation:
> 
> The path from node 0 to node 1 consists of the nodes 0, 1.
> 
> The distance between node 2 and node 1 is 1.
> 
> Node 1 is the node on the path closest to node 2, so the answer to the first query is 1.

**Example 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132333-3.png)

> Input: n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]
> 
> Output: [0]
> 
> Explanation:
> 
> The path from node 0 to node 0 consists of the node 0.
> 
> Since 0 is the only node on the path, the answer to the first query is 0.



**Constraints:**

  * `1 <= n <= 1000`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= node1i, node2i <= n - 1`
  * `node1i != node2i`
  * `1 <= query.length <= 1000`
  * `query[i].length == 3`
  * `0 <= starti, endi, nodei <= n - 1`
  * The graph is a tree.


## 题目大意

给定一个正整数 `n`，表示树中的节点数，编号从 `0` 到 `n - 1` (**含边界**)。还给定一个长度为 `n - 1` 的二维整数数组
`edges`，其中 `edges[i] = [node1i, node2i]` 表示有一条 **双向  **边连接树中的 `node1i` 和
`node2i`。

给定一个长度为 `m` ，**下标从 0 开始**  的整数数组 `query`，其中 `query[i] = [starti, endi, nodei]`
意味着对于第 `i` 个查询，您的任务是从 `starti` 到 `endi` 的路径上找到 **最接近** `nodei` 的节点。

返回 _长度为`m` 的整数数组 _`answer` _，其中_`answer[i]` _是第`i` 个查询的答案。_



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132158-1.png)

> 
> 
> 
> 
> 
> **输入:** n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]
> 
> **输出:** [0,2]
> 
> **解释:**
> 
> 节点 5 到节点 3 的路径由节点 5、2、0、3 组成。
> 
> 节点 4 到节点 0 的距离为 2。
> 
> 节点 0 是距离节点 4 最近的路径上的节点，因此第一个查询的答案是 0。
> 
> 节点 6 到节点 2 的距离为 1。
> 
> 节点 2 是距离节点 6 最近的路径上的节点，因此第二个查询的答案是 2。
> 
> 

**示例 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132318-2.png)

> 
> 
> 
> 
> 
> **输入:** n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]
> 
> **输出:** [1]
> 
> **解释:**
> 
> 从节点 0 到节点 1 的路径由节点 0,1 组成。
> 
> 节点 2 到节点 1 的距离为 1。
> 
> 节点 1 是距离节点 2 最近的路径上的节点，因此第一个查询的答案是 1。
> 
> 

**示例 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2277.Closest%20Node%20to%20Path%20in%20Tree/images/image-20220514132333-3.png)

> 
> 
> 
> 
> 
> **输入:** n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]
> 
> **输出:** [0]
> 
> **解释:**
> 
> 节点 0 到节点 0 的路径由节点 0 组成。
> 
> 因为 0 是路径上唯一的节点，所以第一个查询的答案是0。



**提示:**

  * `1 <= n <= 1000`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= node1i, node2i <= n - 1`
  * `node1i != node2i`
  * `1 <= query.length <= 1000`
  * `query[i].length == 3`
  * `0 <= starti, endi, nodei <= n - 1`
  * 这个图是一个树。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2581 | [统计可能的树根数目](https://leetcode.com/problems/count-number-of-possible-root-nodes) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`数组`](/tag/array.md) `2+` | <font color=#ff334b>Hard</font> |
| 2642 | [设计可以求最短路径的图类](https://leetcode.com/problems/design-graph-with-shortest-path-calculator) |  |  [`图`](/tag/graph.md) [`设计`](/tag/design.md) [`最短路`](/tag/shortest-path.md) `1+` | <font color=#ff334b>Hard</font> |