---
title: 2676. 节流 🔒
description: LeetCode,2676. 节流 🔒,节流,Throttle,解题思路
keywords:
  - LeetCode
  - 2676. 节流 🔒
  - 节流
  - Throttle
  - 解题思路
---

# 2676. 节流 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/throttle) [`LeetCode`](https://leetcode.com/problems/throttle)

## 题目

Given a function `fn` and a time in milliseconds `t`, return a **throttled**
version of that function.

A **throttled** function is first called without delay and then, for a time
interval of `t` milliseconds, can't be executed but should store the latest
function arguments provided to call `fn` with them after the end of the delay.

For instance, `t = 50ms`, and the function was called at `30ms`, `40ms`, and
`60ms`.

At `30ms`, without delay, the **throttled** function `fn` should be called
with the arguments, and calling the **throttled** function `fn` should be
blocked for the following `t` milliseconds.

At `40ms`, the function should just save arguments.

At `60ms`, arguments should overwrite currently stored arguments from the
second call because the second and third calls are made before `80ms`. Once
the delay has passed, the **throttled** function `fn` should be called with
the latest arguments provided during the delay period, and it should also
create another delay period of `80ms + t`.

![Throttle
Diagram](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2600-2699/2676.Throttle/images/screen-
shot-2023-04-08-at-120313-pm.png)The above diagram shows how throttle will
transform events. Each rectangle represents 100ms and the throttle time is
400ms. Each color represents a different set of inputs.



**Example 1:**

> Input: 
> 
> t = 100, 
> 
> calls = [
> 
>   {"t":20,"inputs":[1]}
> 
> ]
> 
> Output: [{"t":20,"inputs":[1]}]
> 
> Explanation: The 1st call is always called without delay

**Example 2:**

> Input: 
> 
> t = 50, 
> 
> calls = [
> 
>   {"t":50,"inputs":[1]},
> 
>   {"t":75,"inputs":[2]}
> 
> ]
> 
> Output: [{"t":50,"inputs":[1]},{"t":100,"inputs":[2]}]
> 
> Explanation: 
> 
> The 1st is called a function with arguments (1) without delay.
> 
> The 2nd is called at 75ms, within the delay period because 50ms + 50ms = 100ms, so the next call can be reached at 100ms. Therefore, we save arguments from the 2nd call to use them at the callback of the 1st call.

**Example 3:**

> Input: 
> 
> t = 70, 
> 
> calls = [
> 
>   {"t":50,"inputs":[1]},
> 
>   {"t":75,"inputs":[2]},
> 
>   {"t":90,"inputs":[8]},
> 
>   {"t": 140, "inputs":[5,7]},
> 
>   {"t": 300, "inputs": [9,4]}
> 
> ]
> 
> Output: [{"t":50,"inputs":[1]},{"t":120,"inputs":[8]},{"t":190,"inputs":[5,7]},{"t":300,"inputs":[9,4]}]
> 
> Explanation: 
> 
> The 1st is called a function with arguments (1) without delay.
> 
> The 2nd is called at 75ms within the delay period because 50ms + 70ms = 120ms, so it should only save arguments. 
> 
> The 3rd is also called within the delay period, and because we need just the latest function arguments, we overwrite previous ones. After the delay period, we do a callback at 120ms with saved arguments. That callback makes another delay period of 120ms + 70ms = 190ms so that the next function can be called at 190ms.
> 
> The 4th is called at 140ms in the delay period, so it should be called as a callback at 190ms. That will create another delay period of 190ms + 70ms = 260ms.
> 
> The 5th is called at 300ms, but it is after 260ms, so it should be called immediately and should create another delay period of 300ms + 70ms = 370ms.



**Constraints:**

  * `0 <= t <= 1000`
  * `1 <= calls.length <= 10`
  * `0 <= calls[i].t <= 1000`
  * `0 <= calls[i].inputs[j], calls[i].inputs.length <= 10`


## 题目大意

现给定一个函数 `fn` 和一个以毫秒为单位的时间 `t` ，请你返回该函数的 **节流** 版本。

**节流** 函数首先立即被调用，然后在 `t` 毫秒的时间间隔内不能再次执行，但应该存储最新的函数参数，以便在延迟结束后使用这些参数调用 `fn` 。

例如，`t = 50ms` ，并且函数在 `30ms` 、 `40ms` 和 `60ms` 时被调用。

在 `30ms`，**节流** 函数 `fn` 会以这些函数调用，并且对 **节流** 函数 `fn` 的调用在接下来的 `t` 毫秒会被阻塞。

在 `40ms`，函数应当只是存储参数。

在 `60ms`，参数应该覆盖第二次调用中当前存储的参数，因为第二次和第三次调用是在 `80ms`
之前进行的。延迟结束后，应该使用延迟期间提供的最新参数来调用 **节流** 函数 `fn`，并且它还应该创建另一个 `80ms + t` 的延迟。

![Throttle
Diagram](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2600-2699/2676.Throttle/images/screen-
shot-2023-04-08-at-120313-pm.png)上面的图示展示了节流如何转换事件。每个矩形代表100毫秒，节流时间为400毫秒。每种颜色代表不同的输入集合。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** t = 100, 
> 
> calls = [
> 
>   {"t":20,"inputs":[1]}
> 
> ]
> 
> **输出：**[{"t":20,"inputs":[1]}]
> 
> **解释：** 第一次调用总是立即执行，没有延迟。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** t = 50, 
> 
> calls = [
> 
>   {"t":50,"inputs":[1]},
> 
>   {"t":75,"inputs":[2]}
> 
> ]
> 
> **输出：**[{"t":50,"inputs":[1]},{"t":100,"inputs":[2]}]
> 
> **解释：**
> 
> 第一次调用立即执行带有参数 (1) 的函数。 
> 
> 第二次调用发生在 75毫秒 时，在延迟期间内，因为 50毫秒 + 50毫秒 = 100毫秒，所以下一次调用可以在 100毫秒 时执行。因此，我们保存第二次调用的参数，以便在第一次调用的回调函数中使用。
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** t = 70, 
> 
> calls = [
> 
>   {"t":50,"inputs":[1]},
> 
>   {"t":75,"inputs":[2]},
> 
>   {"t":90,"inputs":[8]},
> 
>   {"t": 140, "inputs":[5,7]},
> 
>   {"t": 300, "inputs": [9,4]}
> 
> ]
> 
> **输出：**[{"t":50,"inputs":[1]},{"t":120,"inputs":[8]},{"t":190,"inputs":[5,7]},{"t":300,"inputs":[9,4]}]
> 
> **解释：**
> 
> 第一次调用立即执行带有参数 (1) 的函数。 
> 
> 第二次调用发生在 75毫秒 时，在延迟期间内，因为 50毫秒 + 70毫秒 = 120毫秒，所以它只应保存参数。 
> 
> 第三次调用也在延迟期间内，因为我们只需要最新的函数参数，所以覆盖之前的参数。延迟期过后，在 120毫秒时进行回调，并使用保存的参数进行调用。该回调会创建另一个延迟期间，时长为 120毫秒 + 70毫秒 = 190毫秒，以便下一个函数可以在 190毫秒时调用。 
> 
> 第四次调用发生在 140毫秒，在延迟期间内，因此应在190毫秒时作为回调进行调用。这将创建另一个延迟期间，时长为 190毫秒 + 70毫秒 = 260毫秒。 
> 
> 第五次调用发生在 300毫秒，但它是在 260毫秒 之后，所以应立即调用，并创建另一个延迟期间，时长为 300毫秒 + 70毫秒 = 370毫秒。



**提示：**

  * `0 <= t <= 1000`
  * `1 <= calls.length <= 10`
  * `0 <= calls[i].t <= 1000`
  * `0 <= calls[i].inputs[i], calls[i].inputs.length <= 10`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 2627 | 函数防抖 | [[✓]](/problem/2627.md) |  | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/debounce) [🔗](https://leetcode.com/problems/debounce) |
| 2636 | Promise 对象池 🔒 | [[✓]](/problem/2636.md) |  | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/promise-pool) [🔗](https://leetcode.com/problems/promise-pool) |
| 2637 | 有时间限制的 Promise 对象 | [[✓]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> | [🀄️](https://leetcode.cn/problems/promise-time-limit) [🔗](https://leetcode.com/problems/promise-time-limit) |