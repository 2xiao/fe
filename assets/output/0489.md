# [489. 扫地机器人](https://leetcode.com/problems/robot-room-cleaner)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`回溯`](/tag/backtracking.md) [`交互`](/tag/interactive.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/robot-room-cleaner)

## 题目

You are controlling a robot that is located somewhere in a room. The room is
modeled as an `m x n` binary grid where `0` represents a wall and `1`
represents an empty slot.

The robot starts at an unknown location in the room that is guaranteed to be
empty, and you do not have access to the grid, but you can move the robot
using the given API `Robot`.

You are tasked to use the robot to clean the entire room (i.e., clean every
empty cell in the room). The robot with the four given APIs can move forward,
turn left, or turn right. Each turn is `90` degrees.

When the robot tries to move into a wall cell, its bumper sensor detects the
obstacle, and it stays on the current cell.

Design an algorithm to clean the entire room using the following APIs:

> 
> 
> 
> 
> 
> interface Robot {
> 
>   // returns true if next cell is open and robot moves into the cell.
> 
>   // returns false if next cell is obstacle and robot stays on the current cell.
> 
>   boolean move();
> 
> 
> 
>   // Robot will stay on the same cell after calling turnLeft/turnRight.
> 
>   // Each turn will be 90 degrees.
> 
>   void turnLeft();
> 
>   void turnRight();
> 
> 
> 
>   // Clean the current cell.
> 
>   void clean();
> 
> }
> 
> 

**Note** that the initial direction of the robot will be facing up. You can
assume all four edges of the grid are all surrounded by a wall.



**Custom testing:**

The input is only given to initialize the room and the robot's position
internally. You must solve this problem "blindfolded". In other words, you
must control the robot using only the four mentioned APIs without knowing the
room layout and the initial robot's position.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0489.Robot%20Room%20Cleaner/images/lc-
grid.jpg)

> Input: room = [[1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1],[1,0,1,1,1,1,1,1],[0,0,0,1,0,0,0,0],[1,1,1,1,1,1,1,1]], row = 1, col = 3
> 
> Output: Robot cleaned all rooms.
> 
> Explanation: All grids in the room are marked by either 0 or 1.
> 
> 0 means the cell is blocked, while 1 means the cell is accessible.
> 
> The robot initially starts at the position of row=1, col=3.
> 
> From the top left corner, its position is one row below and three columns right.

**Example 2:**

> Input: room = [[1]], row = 0, col = 0
> 
> Output: Robot cleaned all rooms.

**Constraints:**

  * `m == room.length`
  * `n == room[i].length`
  * `1 <= m <= 100`
  * `1 <= n <= 200`
  * `room[i][j]` is either `0` or `1`.
  * `0 <= row < m`
  * `0 <= col < n`
  * `room[row][col] == 1`
  * All the empty cells can be visited from the starting position.


## 题目大意

房间中的某个位置上有一个机器人，你需要控制它清扫房间。房间被建模为一个 `m x n` 的二进制网格，其中 `0` 表示单元格中有障碍物，`1`
表示空单元格。

机器人从一个未知的空单元格开始出发，并且你无法访问网格，但你可以使用给定的 API `Robot` 控制机器人。

你的任务是使用机器人清扫整个房间（即清理房间中的每个空单元格）。机器人具有四个给定的API，可以前进、向左转或向右转。每次转弯 `90` 度。

当机器人试图移动到一个存在障碍物的单元格时，它的碰撞传感器会检测到障碍物，并停留在当前单元格。

设计一个算法，使用下述 API 清扫整个房间：

> 
> 
> 
> 
> 
> interface Robot {
> 
>   // 若下一个单元格为空，则返回 true ，并移动至该单元格。
> 
>   // 若下一个单元格为障碍物，则返回 false ，并停留在当前单元格。
> 
>   boolean move();
> 
> 
> 
>   // 在调用 turnLeft/turnRight 后机器人会停留在当前单元格。
> 
>   // 每次转弯 90 度。
> 
>   void turnLeft();
> 
>   void turnRight();
> 
> 
> 
>   // 清理当前单元格。
> 
>   void clean();
> 
> }
> 
> 

**注意** 扫地机器人的初始方向向上。你可以假定网格的四周都被墙包围。



**自定义测试：**

输入只用于初始化房间和机器人的位置。你需要「盲解」这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用 4 个给出的 API 解决问题。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0489.Robot%20Room%20Cleaner/images/lc-
grid.jpg)

> 
> 
> 
> 
> 
> **输入：** room = [[1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1],[1,0,1,1,1,1,1,1],[0,0,0,1,0,0,0,0],[1,1,1,1,1,1,1,1]], row = 1, col = 3
> 
> **输出：** Robot cleaned all rooms.
> 
> **解释：**
> 
> 房间内的所有单元格用 0 或 1 填充。
> 
> 0 表示障碍物，1 表示可以通过。 
> 
> 机器人从 row=1, col=3 的初始位置出发。
> 
> 在左上角的一行以下，三列以右。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** room = [[1]], row = 0, col = 0
> 
> **输出：** Robot cleaned all rooms.
> 
> 



**提示：**

  * `m == room.length`
  * `n == room[i].length`
  * `1 <= m <= 100`
  * `1 <= n <= 200`
  * `room[i][j]` 为 `0` 或 `1`.
  * `0 <= row < m`
  * `0 <= col < n`
  * `room[row][col] == 1`
  * 所有空单元格都可以从起始位置出发访问到。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 286 | [墙与门](https://leetcode.com/problems/walls-and-gates) |  |  [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | <font color=#ffb800>Medium</font> |
| 1778 | [未知网格中的最短路径](https://leetcode.com/problems/shortest-path-in-a-hidden-grid) |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> |
| 1810 | [隐藏网格下的最小消耗路径](https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid) |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) `2+` | <font color=#ffb800>Medium</font> |
| 2061 | [扫地机器人清扫过的空间个数](https://leetcode.com/problems/number-of-spaces-cleaning-robot-cleaned) |  |  [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) [`模拟`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |