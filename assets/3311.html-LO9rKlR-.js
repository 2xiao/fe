import{_ as c,r,o as i,c as l,a as e,b as t,d as o,w as n,e as g}from"./app-wp1xnw1k.js";const p={},h=e("h1",{id:"_3311-构造符合图结构的二维矩阵",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3311-构造符合图结构的二维矩阵","aria-hidden":"true"},"#"),t(" 3311. 构造符合图结构的二维矩阵")],-1),u=e("code",null,"图",-1),_=e("code",null,"数组",-1),m=e("code",null,"哈希表",-1),f=e("code",null,"矩阵",-1),v={href:"https://leetcode.cn/problems/construct-2d-grid-matching-graph-layout",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"力扣",-1),b={href:"https://leetcode.com/problems/construct-2d-grid-matching-graph-layout",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"LeetCode",-1),E=g(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>You are given a 2D integer array <code>edges</code> representing an <strong>undirected</strong> graph having <code>n</code> nodes, where <code>edges[i] = [ui, vi]</code> denotes an edge between nodes <code>ui</code> and <code>vi</code>.</p><p>Construct a 2D grid that satisfies these conditions:</p><ul><li>The grid contains <strong>all nodes</strong> from <code>0</code> to <code>n - 1</code> in its cells, with each node appearing exactly <strong>once</strong>.</li><li>Two nodes should be in adjacent grid cells (<strong>horizontally</strong> or <strong>vertically</strong>) <strong>if and only if</strong> there is an edge between them in <code>edges</code>.</li></ul><p>It is guaranteed that <code>edges</code> can form a 2D grid that satisfies the conditions.</p><p>Return a 2D integer array satisfying the conditions above. If there are multiple solutions, return <em>any</em> of them.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> n = 4, edges = [[0,1],[0,2],[1,3],[2,3]]</p><p><strong>Output:</strong> [[3,1],[2,0]]</p><p><strong>Explanation:</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-07-59.png)</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> n = 5, edges = [[0,1],[1,3],[2,3],[2,4]]</p><p><strong>Output:</strong> [[4,2,3,1,0]]</p><p><strong>Explanation:</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-06-02.png)</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]</p><p><strong>Output:</strong> [[8,6,3],[7,4,2],[1,0,5]]</p><p><strong>Explanation:</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-06-38.png)</p><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= n &lt;= 5 * 10^4</code></li><li><code>1 &lt;= edges.length &lt;= 10^5</code></li><li><code>edges[i] = [ui, vi]</code></li><li><code>0 &lt;= ui &lt; vi &lt; n</code></li><li>All the edges are distinct.</li><li>The input is generated such that <code>edges</code> can form a 2D grid that satisfies the conditions.</li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>给你一个二维整数数组 <code>edges</code> ，它表示一棵 <code>n</code> 个节点的 <strong>无向</strong> 图，其中 <code>edges[i] = [ui, vi]</code> 表示节点 <code>ui</code> 和 <code>vi</code> 之间有一条边。</p><p>请你构造一个二维矩阵，满足以下条件：</p><ul><li>矩阵中每个格子 <strong>一一对应</strong> 图中 <code>0</code> 到 <code>n - 1</code> 的所有节点。</li><li>矩阵中两个格子相邻（<strong>横</strong> 的或者 <strong>竖</strong> 的）<strong>当且仅当</strong> 它们对应的节点在 <code>edges</code> 中有边连接。</li></ul><p>题目保证 <code>edges</code> 可以构造一个满足上述条件的二维矩阵。</p><p>请你返回一个符合上述要求的二维整数数组，如果存在多种答案，返回任意一个。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong> n = 4, edges = [[0,1],[0,2],[1,3],[2,3]]</p><p><strong>输出：</strong>[[3,1],[2,0]]</p><p><strong>解释：</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-07-59.png)</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong> n = 5, edges = [[0,1],[1,3],[2,3],[2,4]]</p><p><strong>输出：</strong>[[4,2,3,1,0]]</p><p><strong>解释：</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-06-02.png)</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]</p><p><strong>输出：</strong>[[8,6,3],[7,4,2],[1,0,5]]</p><p><strong>解释：</strong></p><p>![](https://assets.leetcode.com/uploads/2024/08/11/screenshot- from-2024-08-11-14-06-38.png)</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 5 * 10^4</code></li><li><code>1 &lt;= edges.length &lt;= 10^5</code></li><li><code>edges[i] = [ui, vi]</code></li><li><code>0 &lt;= ui &lt; vi &lt; n</code></li><li>图中的边互不相同。</li><li>输入保证 <code>edges</code> 可以形成一个符合上述条件的二维矩阵。</li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O()</code>，</li><li><strong>空间复杂度</strong>：<code>O()</code>，</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,51);function k(w,I){const a=r("font"),s=r("RouterLink"),d=r("ExternalLinkIcon");return i(),l("div",null,[h,e("p",null,[t("🔴 "),o(a,{color:"#ff334b"},{default:n(()=>[t("Hard")]),_:1}),t("  🔖  "),o(s,{to:"/tag/graph.html"},{default:n(()=>[u]),_:1}),t(),o(s,{to:"/tag/array.html"},{default:n(()=>[_]),_:1}),t(),o(s,{to:"/tag/hash-table.html"},{default:n(()=>[m]),_:1}),t(),o(s,{to:"/tag/matrix.html"},{default:n(()=>[f]),_:1}),t("  🔗 "),e("a",v,[x,o(d)]),t(),e("a",b,[y,o(d)])]),E])}const D=c(p,[["render",k],["__file","3311.html.vue"]]);export{D as default};
