import{_ as d,r as c,o as i,c as r,a as t,b as e,d as n,w as o,f as p,e as _}from"./app-AaR8dgoJ.js";const u={},h=t("h1",{id:"_236-二叉树的最近公共祖先",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_236-二叉树的最近公共祖先","aria-hidden":"true"},"#"),e(" 236. 二叉树的最近公共祖先")],-1),f=t("code",null,"树",-1),m=t("code",null,"深度优先搜索",-1),g=t("code",null,"二叉树",-1),k={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree",target:"_blank",rel:"noopener noreferrer"},b=t("code",null,"力扣",-1),y={href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",target:"_blank",rel:"noopener noreferrer"},x=t("code",null,"LeetCode",-1),v=t("h2",{id:"题目",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#题目","aria-hidden":"true"},"#"),e(" 题目")],-1),w=t("p",null,"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",-1),q={href:"https://en.wikipedia.org/wiki/Lowest_common_ancestor",target:"_blank",rel:"noopener noreferrer"},C=t("code",null,"p",-1),L=t("code",null,"q",-1),A=t("code",null,"T",-1),I=t("code",null,"p",-1),N=t("code",null,"q",-1),T=t("strong",null,"a node to be a descendant of itself",-1),E=_(`<p><strong>Example 1:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</p><p>Output: 3</p><p>Explanation: The LCA of nodes 5 and 1 is 3.</p></blockquote><p><strong>Example 2:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</p><p>Output: 5</p><p>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: root = [1,2], p = 1, q = 2</p><p>Output: 1</p></blockquote><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 10^5]</code>.</li><li><code>-10^9 &lt;= Node.val &lt;= 10^9</code></li><li>All <code>Node.val</code> are <strong>unique</strong>.</li><li><code>p != q</code></li><li><code>p</code> and <code>q</code> will exist in the tree.</li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>维基百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>这是一道经典的题目，寻找任意一个二叉树中两个结点的 LCA 最近公共祖先，考察递归。</p><p>从根节点开始，递归地向左子树和右子树搜索。递归的终止条件有几种情况：</p><ol><li>如果当前节点为 <code>null</code>，表示遍历到空节点，直接返回 <code>null</code>。</li><li>如果当前节点等于 <code>p</code> 或 <code>q</code>，表示找到了其中一个节点，直接返回当前节点。</li></ol><p>递归步骤如下：</p><ol><li>递归地在左子树中寻找 <code>p</code> 和 <code>q</code> 的最低共同祖先，结果存储在变量 <code>left</code> 中。</li><li>递归地在右子树中寻找 <code>p</code> 和 <code>q</code> 的最低共同祖先，结果存储在变量 <code>right</code> 中。</li></ol><p>然后，根据 <code>left</code> 和 <code>right</code> 的情况，可以得出以下结论：</p><ul><li>如果 <code>left</code> 和 <code>right</code> 都不为 <code>null</code>，说明 <code>p</code> 和 <code>q</code> 分别位于当前节点的左右子树，因此当前节点就是它们的最低共同祖先，直接返回当前节点。</li><li>如果只有 <code>left</code> 不为 <code>null</code>，说明 <code>p</code> 和 <code>q</code> 都在左子树，最低共同祖先在左子树中，返回 <code>left</code>。</li><li>如果只有 <code>right</code> 不为 <code>null</code>，说明 <code>p</code> 和 <code>q</code> 都在右子树，最低共同祖先在右子树中，返回 <code>right</code>。</li></ul><p>递归法的关键在于将大问题划分为规模较小的子问题，然后通过递归调用来解决子问题，最终得到整体的解决方案。在这里，递归调用的子问题是在左右子树中寻找 <code>p</code> 和 <code>q</code> 的最低共同祖先。</p><p>递归法的优点在于其简洁性和直观性，但需要注意避免重复计算，以提高性能。</p><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是树中节点的总数，因为在最坏的情况下，需要检查每个节点来找到最近公共祖先。</li><li><strong>空间复杂度</strong>：<code>O(h)</code>，其中 <code>h</code> 是树的高度，空间复杂度主要由递归调用栈的深度决定。 <ul><li>在平衡树中，递归深度为 <code>O(h)</code>，其中 <code>h</code> 是树的高度。</li><li>在最坏情况下（例如，树是完全不平衡的），递归的深度可以达到 <code>O(n)</code>，其中 <code>n</code> 是树中节点的总数。</li></ul></li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">p</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">q</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>

	<span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
	<span class="token keyword">return</span> left <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,28),M=t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"center"}},"题号"),t("th",{style:{"text-align":"left"}},"标题"),t("th",{style:{"text-align":"center"}},"题解"),t("th",{style:{"text-align":"left"}},"标签"),t("th",{style:{"text-align":"left"}},"难度")])],-1),O=t("td",{style:{"text-align":"center"}},"235",-1),V={style:{"text-align":"left"}},j={href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree",target:"_blank",rel:"noopener noreferrer"},z={style:{"text-align":"center"}},B={style:{"text-align":"left"}},R=t("code",null,"树",-1),G=t("code",null,"深度优先搜索",-1),H=t("code",null,"二叉搜索树",-1),S=t("code",null,"1+",-1),W={style:{"text-align":"left"}},D=t("td",{style:{"text-align":"center"}},"1257",-1),F={style:{"text-align":"left"}},J={href:"https://leetcode.com/problems/smallest-common-region",target:"_blank",rel:"noopener noreferrer"},K=t("td",{style:{"text-align":"center"}},null,-1),P={style:{"text-align":"left"}},Q=t("code",null,"树",-1),U=t("code",null,"深度优先搜索",-1),X=t("code",null,"广度优先搜索",-1),Y=t("code",null,"3+",-1),Z={style:{"text-align":"left"}},$=t("td",{style:{"text-align":"center"}},"1644",-1),tt={style:{"text-align":"left"}},et={href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii",target:"_blank",rel:"noopener noreferrer"},nt=t("td",{style:{"text-align":"center"}},null,-1),ot={style:{"text-align":"left"}},st=t("code",null,"树",-1),at=t("code",null,"深度优先搜索",-1),lt=t("code",null,"二叉树",-1),ct={style:{"text-align":"left"}},dt=t("td",{style:{"text-align":"center"}},"1650",-1),it={style:{"text-align":"left"}},rt={href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii",target:"_blank",rel:"noopener noreferrer"},pt=t("td",{style:{"text-align":"center"}},null,-1),_t={style:{"text-align":"left"}},ut=t("code",null,"树",-1),ht=t("code",null,"哈希表",-1),ft=t("code",null,"双指针",-1),mt=t("code",null,"1+",-1),gt={style:{"text-align":"left"}},kt=t("td",{style:{"text-align":"center"}},"1676",-1),bt={style:{"text-align":"left"}},yt={href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv",target:"_blank",rel:"noopener noreferrer"},xt=t("td",{style:{"text-align":"center"}},null,-1),vt={style:{"text-align":"left"}},wt=t("code",null,"树",-1),qt=t("code",null,"深度优先搜索",-1),Ct=t("code",null,"哈希表",-1),Lt=t("code",null,"1+",-1),At={style:{"text-align":"left"}},It=t("td",{style:{"text-align":"center"}},"2096",-1),Nt={style:{"text-align":"left"}},Tt={href:"https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another",target:"_blank",rel:"noopener noreferrer"},Et=t("td",{style:{"text-align":"center"}},null,-1),Mt={style:{"text-align":"left"}},Ot=t("code",null,"树",-1),Vt=t("code",null,"深度优先搜索",-1),jt=t("code",null,"字符串",-1),zt=t("code",null,"1+",-1),Bt={style:{"text-align":"left"}},Rt=t("td",{style:{"text-align":"center"}},"2225",-1),Gt={style:{"text-align":"left"}},Ht={href:"https://leetcode.com/problems/find-players-with-zero-or-one-losses",target:"_blank",rel:"noopener noreferrer"},St=t("td",{style:{"text-align":"center"}},null,-1),Wt={style:{"text-align":"left"}},Dt=t("code",null,"数组",-1),Ft=t("code",null,"哈希表",-1),Jt=t("code",null,"计数",-1),Kt=t("code",null,"1+",-1),Pt={style:{"text-align":"left"}},Qt=t("td",{style:{"text-align":"center"}},"2509",-1),Ut={style:{"text-align":"left"}},Xt={href:"https://leetcode.com/problems/cycle-length-queries-in-a-tree",target:"_blank",rel:"noopener noreferrer"},Yt=t("td",{style:{"text-align":"center"}},null,-1),Zt={style:{"text-align":"left"}},$t=t("code",null,"树",-1),te=t("code",null,"数组",-1),ee=t("code",null,"二叉树",-1),ne={style:{"text-align":"left"}};function oe(se,ae){const l=c("font"),s=c("RouterLink"),a=c("ExternalLinkIcon");return i(),r("div",null,[h,t("p",null,[e("🟠 "),n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1}),e("  🔖  "),n(s,{to:"/tag/tree.html"},{default:o(()=>[f]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[m]),_:1}),e(),n(s,{to:"/tag/binary-tree.html"},{default:o(()=>[g]),_:1}),e("  🔗 "),t("a",k,[b,n(a)]),e(),t("a",y,[x,n(a)])]),v,w,t("p",null,[e("According to the "),t("a",q,[e("definition of LCA on Wikipedia"),n(a)]),e(': "The lowest common ancestor is defined between two nodes '),C,e(" and "),L,e(" as the lowest node in "),A,e(" that has both "),I,e(" and "),N,e(" as descendants (where we allow "),T,e(' )."')]),E,p(" prettier-ignore "),t("table",null,[M,t("tbody",null,[t("tr",null,[O,t("td",V,[t("a",j,[e("二叉搜索树的最近公共祖先"),n(a)])]),t("td",z,[n(s,{to:"/problem/0235.html"},{default:o(()=>[e("[✓]")]),_:1})]),t("td",B,[n(s,{to:"/tag/tree.html"},{default:o(()=>[R]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[G]),_:1}),e(),n(s,{to:"/tag/binary-search-tree.html"},{default:o(()=>[H]),_:1}),e(),S]),t("td",W,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[D,t("td",F,[t("a",J,[e("最小公共区域 🔒"),n(a)])]),K,t("td",P,[n(s,{to:"/tag/tree.html"},{default:o(()=>[Q]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[U]),_:1}),e(),n(s,{to:"/tag/breadth-first-search.html"},{default:o(()=>[X]),_:1}),e(),Y]),t("td",Z,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[$,t("td",tt,[t("a",et,[e("二叉树的最近公共祖先 II 🔒"),n(a)])]),nt,t("td",ot,[n(s,{to:"/tag/tree.html"},{default:o(()=>[st]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[at]),_:1}),e(),n(s,{to:"/tag/binary-tree.html"},{default:o(()=>[lt]),_:1})]),t("td",ct,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[dt,t("td",it,[t("a",rt,[e("二叉树的最近公共祖先 III 🔒"),n(a)])]),pt,t("td",_t,[n(s,{to:"/tag/tree.html"},{default:o(()=>[ut]),_:1}),e(),n(s,{to:"/tag/hash-table.html"},{default:o(()=>[ht]),_:1}),e(),n(s,{to:"/tag/two-pointers.html"},{default:o(()=>[ft]),_:1}),e(),mt]),t("td",gt,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[kt,t("td",bt,[t("a",yt,[e("二叉树的最近公共祖先 IV 🔒"),n(a)])]),xt,t("td",vt,[n(s,{to:"/tag/tree.html"},{default:o(()=>[wt]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[qt]),_:1}),e(),n(s,{to:"/tag/hash-table.html"},{default:o(()=>[Ct]),_:1}),e(),Lt]),t("td",At,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[It,t("td",Nt,[t("a",Tt,[e("从二叉树一个节点到另一个节点每一步的方向"),n(a)])]),Et,t("td",Mt,[n(s,{to:"/tag/tree.html"},{default:o(()=>[Ot]),_:1}),e(),n(s,{to:"/tag/depth-first-search.html"},{default:o(()=>[Vt]),_:1}),e(),n(s,{to:"/tag/string.html"},{default:o(()=>[jt]),_:1}),e(),zt]),t("td",Bt,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[Rt,t("td",Gt,[t("a",Ht,[e("找出输掉零场或一场比赛的玩家"),n(a)])]),St,t("td",Wt,[n(s,{to:"/tag/array.html"},{default:o(()=>[Dt]),_:1}),e(),n(s,{to:"/tag/hash-table.html"},{default:o(()=>[Ft]),_:1}),e(),n(s,{to:"/tag/counting.html"},{default:o(()=>[Jt]),_:1}),e(),Kt]),t("td",Pt,[n(l,{color:"#ffb800"},{default:o(()=>[e("Medium")]),_:1})])]),t("tr",null,[Qt,t("td",Ut,[t("a",Xt,[e("查询树中环的长度"),n(a)])]),Yt,t("td",Zt,[n(s,{to:"/tag/tree.html"},{default:o(()=>[$t]),_:1}),e(),n(s,{to:"/tag/array.html"},{default:o(()=>[te]),_:1}),e(),n(s,{to:"/tag/binary-tree.html"},{default:o(()=>[ee]),_:1})]),t("td",ne,[n(l,{color:"#ff334b"},{default:o(()=>[e("Hard")]),_:1})])])])])])}const ce=d(u,[["render",oe],["__file","0236.html.vue"]]);export{ce as default};
