# [2625. 扁平化嵌套数组](https://leetcode.com/problems/flatten-deeply-nested-array)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/flatten-deeply-nested-array)

## 题目

<p>请你编写一个函数，它接收一个&nbsp;<strong>多维数组&nbsp;</strong><code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的&nbsp;<strong>扁平化&nbsp;</strong>后的结果。</p>

<p><strong>多维数组&nbsp;</strong>是一种包含整数或其他&nbsp;<strong>多维数组&nbsp;</strong>的递归数据结构。</p>

<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>

<p>请在没有使用内置方法&nbsp;<code>Array.flat</code> 的前提下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入</strong>
arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 0
<strong>输出</strong>
[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]

<strong>解释</strong>
传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入</strong>
arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 1
<strong>输出</strong>
[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]

<strong>解释</strong>
以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 [9,10,11] 其深度为 1 ，所以未被扁平化。</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入</strong>
arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 2
<strong>输出</strong>
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

<strong>解释</strong>
所有子数组的最大深度都为 1 。因此，它们都被扁平化了。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= arr 的元素个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr 的子数组个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>maxDepth &lt;= 1000</code></li>
	<li><code>-1000 &lt;= each number &lt;= 1000</code></li>
	<li><code><font face="monospace">0 &lt;= n &lt;= 1000</font></code></li>
</ul>


## 解题思路

1. 定义一个空数组 `result` 用于存储结果。
2. 定义内部递归函数 `flattenArray`，使用 `forEach` 遍历输入的嵌套数组。
3. 对于数组中的每个元素，：
   - 如果是其类型是数组且扁平化深度大于 0，递归调用 `flattenArray` 函数处理该数组。
   - 否则，直接将其添加到结果数组中。
4. 最后返回展平后的结果数组。

### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组中所有元素的总数，每个元素都需要被访问一次。
- **空间复杂度**：`O(n)`，用于存储结果数组。

## 代码

```javascript
/**
 * @param {Array} arr
 * @param {number} depth
 * @return {Array}
 */
var flat = function (arr, n) {
	let res = [];
	const flattenArray = (arr, n) => {
		arr.forEach((item) => {
			if (Array.isArray(item) && n > 0) {
				// 递归调用
				flattenArray(item, n - 1);
			} else {
				// 添加非数组元素
				res.push(item);
			}
		});
	};
	flattenArray(arr, n);
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2628 | [完全相等的 JSON 字符串](https://leetcode.com/problems/json-deep-equal) |  |  | <font color=#ffb800>Medium</font> |
| 2633 | [将对象转换为 JSON 字符串](https://leetcode.com/problems/convert-object-to-json-string) |  |  | <font color=#ffb800>Medium</font> |
| 2649 | [嵌套数组生成器](https://leetcode.com/problems/nested-array-generator) |  |  | <font color=#ffb800>Medium</font> |