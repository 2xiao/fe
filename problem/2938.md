# [2938. 区分黑球与白球](https://leetcode.com/problems/separate-black-and-white-balls)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/separate-black-and-white-balls)

## 题目

<p>桌子上有 <code>n</code> 个球，每个球的颜色不是黑色，就是白色。</p>

<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code>，其中 <code>1</code> 和 <code>0</code> 分别代表黑色和白色的球。</p>

<p>在每一步中，你可以选择两个相邻的球并交换它们。</p>

<p>返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 <strong>最小步数</strong>」。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "101"
<strong>输出：</strong>1
<strong>解释：</strong>我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "011"。
最开始，1 没有都在右侧，需要至少 1 步将其移到右侧。</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "100"
<strong>输出：</strong>2
<strong>解释：</strong>我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "010"。
- 交换 s[1] 和 s[2]，s = "001"。
可以证明所需的最小步数为 2 。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "0111"
<strong>输出：</strong>0
<strong>解释：</strong>所有黑色球都已经在右侧。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> 不是 <code>'0'</code>，就是 <code>'1'</code>。</li>
</ul>


## 解题思路

问题要求将所有黑色球（`1`）移到右侧，所有白色球（`0`）移到左侧，并计算最小的步数，在每次操作中，可以选择相邻的两个球进行交换。

解题的关键是计算白色球和黑色球之间的“错位”程度，因此，可以从左到右遍历字符串，并计算每个白色球被黑色球阻挡的步数。

1. 用 `curWhite` 记录遍历时白色球的数量，初始化为 `-1`，每遇到一个白色球，就增加 `curWhite` 计数。
2. 用 `minStep` 记录所有白色球需要的总移动步数，初始化为 `0`。
3. 从左到右遍历字符串 `s`，每当遇到一个白色球时：

- 将 `curWhite` 加 1，表示当前白色球数加一。
- 计算当前白色球应该在的位置与它当前所在的位置的差值，并加到 `minStep` 中。

4. 最终 `minStep` 的值就是将所有白色球移到左侧、所有黑色球移到右侧所需的最小步数。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。我们仅需遍历字符串一次，每次操作的复杂度为常数级。
- **空间复杂度**：`O(1)`，除了几个辅助变量外，没有额外使用其他空间。

## 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minimumSteps = function (s) {
	let curWhite = -1,
		minStep = 0;
	for (let i = 0; i < s.length; i++) {
		const char = s[i];
		if (char == '0') {
			curWhite++;
			minStep += i - curWhite;
		}
	}
	return minStep;
};
```
