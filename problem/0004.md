# [4. 寻找两个正序数组的中位数](https://leetcode.com/problems/median-of-two-sorted-arrays)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) [`分治`](/tag/divide-and-conquer.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/median-of-two-sorted-arrays)

## 题目

<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>

<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [1,3], nums2 = [2]
<strong>输出：</strong>2.00000
<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]
<strong>输出：</strong>2.50000
<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>nums1.length == m</code></li>
	<li><code>nums2.length == n</code></li>
	<li><code>0 &lt;= m &lt;= 1000</code></li>
	<li><code>0 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= m + n &lt;= 2000</code></li>
	<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>
</ul>


## 解题思路

这一题最容易想到的办法是把两个数组合并，然后取出中位数。但是合并有序数组的操作时间复杂度是 `O(m+n)` ，不符合题意。

由于题目要求的时间复杂度为 `O(log(m + n))`，这表明我们需要使用 **二分查找**。

可以将问题转化为 **在两个排序数组中寻找第 k 小的数**，其中 k 是 `(m + n) / 2` 或 `(m + n) / 2 + 1`，使用二分法来解决。

- 给定两个排序数组 `nums1` 和 `nums2`，需要找到第 `k` 小的数。
- 使用二分法来缩小查找范围：
  - 取两个数组中第 `k / 2` 个数，比较这两个数的大小。
  - 较小的那个数组的前 `k / 2` 个数不可能包含第 k 小的数，所以可以将这些数排除，并在剩余的部分继续查找。

**特殊情况处理**：

- 如果某一个数组为空，则直接返回另一个数组的中间值。
- 如果 k == 1，则返回两个数组的最小值。
- 总长度为偶数时，需要同时找到第 `(m + n) / 2` 和第 `(m + n) / 2 + 1` 小的数，并取它们的平均值作为中位数。

#### 复杂度分析

- **时间复杂度**：`O(log(min(m, n)))`，因为每次递归我们会排除掉 `k/2` 个元素，直到找到第 `k` 小的元素，整个过程是对较短数组长度的二分查找。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

## 代码

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function (nums1, nums2) {
	const findKth = (arr1, start1, arr2, start2, k) => {
		// 如果数组 1 已经全部被排除，则返回数组 2 中的第 k 小元素
		if (start1 >= arr1.length) {
			return arr2[start2 + k - 1];
		}

		// 如果数组 2 已经全部被排除，则返回数组 1 中的第 k 小元素
		if (start2 >= arr2.length) {
			return arr1[start1 + k - 1];
		}

		// 如果 k == 1，返回两个数组中最小的元素
		if (k == 1) {
			return Math.min(arr1[start1], arr2[start2]);
		}

		// 在两个数组中分别找出第 k/2 个元素
		let harfK = (k / 2) | 0,
			index1 = start1 + harfK - 1,
			index2 = start2 + harfK - 1,
			mid1 = index1 < arr1.length ? arr1[index1] : Infinity,
			mid2 = index2 < arr2.length ? arr2[index2] : Infinity;

		// 如果数组 1 的中间值较小，排除数组 1 中的前 k/2 个元素
		if (mid1 < mid2) {
			return findKth(arr1, start1 + harfK, arr2, start2, k - harfK);
		} else {
			// 否则排除数组 2 中的前 k/2 个元素
			return findKth(arr1, start1, arr2, start2 + harfK, k - harfK);
		}
	};

	const len = nums1.length + nums2.length;
	// 如果总长度为奇数，返回中间的那个数
	if (len % 2 == 1) {
		return findKth(nums1, 0, nums2, 0, ((len / 2) | 0) + 1);
	} else {
		// 如果总长度为偶数，返回中间两个数的平均值
		const left = findKth(nums1, 0, nums2, 0, len / 2);
		const right = findKth(nums1, 0, nums2, 0, len / 2 + 1);
		return (left + right) / 2;
	}
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2387 | [行排序矩阵的中位数](https://leetcode.com/problems/median-of-a-row-wise-sorted-matrix) |  |  [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) [`矩阵`](/tag/matrix.md) | <font color=#ffb800>Medium</font> |