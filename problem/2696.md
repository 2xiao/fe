# [2696. 删除子串后的字符串最小长度](https://leetcode.com/problems/minimum-string-length-after-removing-substrings)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`字符串`](/tag/string.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-string-length-after-removing-substrings)

## 题目

<p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p>

<p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>"AB"</code> 或 <code>"CD"</code> 子字符串。</p>

<p>通过执行操作，删除所有&nbsp;<code>"AB"</code> 和 <code>"CD"</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p>

<p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的&nbsp;<code>"AB"</code> 或 <code>"CD"</code> 子串。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "ABFCACDB"
<strong>输出：</strong>2
<strong>解释：</strong>你可以执行下述操作：
- 从 "<em><strong>AB</strong></em>FCACDB" 中删除子串 "AB"，得到 s = "FCACDB" 。
- 从 "FCA<em><strong>CD</strong></em>B" 中删除子串 "CD"，得到 s = "FCAB" 。
- 从 "FC<strong><em>AB</em></strong>" 中删除子串 "AB"，得到 s = "FC" 。
最终字符串的长度为 2 。
可以证明 2 是可获得的最小长度。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "ACBBD"
<strong>输出：</strong>5
<strong>解释：</strong>无法执行操作，字符串长度不变。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> 仅由大写英文字母组成</li>
</ul>


## 解题思路

1. **模拟移除过程**：  
   对于每次操作，我们需要查找并移除 `"AB"` 或 `"CD"`，这样在移除这些特定子串后，字符串会自动合并，形成新的字符串。这个过程可能导致出现新的可移除子串。因此，我们需要一直重复操作，直到再也无法找到 `"AB"` 或 `"CD"`。

2. **使用栈优化操作**：  
   使用栈来模拟这个过程。具体做法是从左到右遍历字符串的每个字符，将字符压入栈中，每次压入后检查栈顶的两个字符是否形成 `"AB"` 或 `"CD"`。如果形成，就将这两个字符弹出栈，模拟移除它们。这样，栈中的字符就是剩余未能被移除的部分。

3. **最终结果**：  
   遍历完成后，栈中的元素就是无法继续移除的字符，栈的长度就是最后剩下字符串的最小长度。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。我们只需遍历字符串一次，对于每个字符，压栈和弹栈的操作都是常数时间。
- **空间复杂度**：`O(n)`，最坏情况下，栈中会保留所有字符，因此需要 `O(n)` 的额外空间。

## 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minLength = function (s) {
	let stack = [];

	for (let char of s) {
		stack.push(char);

		// 检查栈顶的两个字符是否形成 "AB" 或 "CD"
		if (stack.length >= 2) {
			let lastTwo = stack[stack.length - 2] + stack[stack.length - 1];

			// 如果发现 "AB" 或 "CD"，则弹出这两个字符
			if (lastTwo === 'AB' || lastTwo === 'CD') {
				stack.pop(); // 移除栈顶字符
				stack.pop(); // 再移除栈顶字符
			}
		}
	}

	return stack.length; // 栈中剩余的字符就是最终字符串
};
```
