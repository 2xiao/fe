# [2636. Promise 对象池](https://leetcode.com/problems/promise-pool)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/promise-pool)

## 题目



## 解题思路

**池限制**的核心是控制并发数量，即同时只能有最多 `n` 个异步任务在执行，需要在一个任务执行完后，才能启动新的任务。

1. 定义一个调度器函数`executeNext`，它会递归地调用自身以确保所有任务按顺序执行。每次执行一个函数后，会继续执行下一个函数，直到函数数组为空。

2. 创建并发池，使用 `Array(n).fill(null)` 创建一个长度为 `n` 的数组，`map` 方法用来调用 `executeNext`，即启动 `n` 个并发任务。
3. `Promise.all` 会等待所有并发任务完成，确保 `promisePool` 函数在所有任务都执行完后才 resolve。

#### 复杂度分析

- **时间复杂度**: `O(m)`，其中 `m` 是 `functions` 的长度。每个任务的执行时间取决于各自的执行时间，总共会执行 `m` 个任务。
- **空间复杂度**: `O(n)`，因为最多会同时执行 `n` 个任务。

## 代码

```javascript
/**
 * @param {Function[]} functions
 * @param {Number} n
 * @return {Function}
 */
var promisePool = async function (functions, n) {
	const executeNext = async () => {
		if (functions.length === 0) return; // 所有函数都执行完毕
		const fn = functions.shift(); // 取出下一个要执行的函数
		await fn(); // 执行函数并等待其完成
		await executeNext(); // 递归调用，处理下一个任务
	};

	// 创建 n 个并发任务，开始执行
	const pool = Array(n).fill(null).map(executeNext);

	// 等待所有并发任务都完成
	await Promise.all(pool);
};

/**
 * Example usage:
 * const sleep = (time) => new Promise(resolve => setTimeout(resolve, time));
 *
 * promisePool([() => sleep(500), () => sleep(400), () => sleep(300)], 2)
 *   .then(() => console.log('All functions done'));
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2621 | [睡眠函数](https://leetcode.com/problems/sleep) | [[✓]](/problem/2621.md) |  | <font color=#15bd66>Easy</font> |
| 2622 | [有时间限制的缓存](https://leetcode.com/problems/cache-with-time-limit) | [[✓]](/problem/2622.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [有时间限制的 Promise 对象](https://leetcode.com/problems/promise-time-limit) | [[✓]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |
| 2676 | [节流](https://leetcode.com/problems/throttle) | [[✓]](/problem/2676.md) |  | <font color=#ffb800>Medium</font> |