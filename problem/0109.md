# [109. 有序链表转换二叉搜索树](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`链表`](/tag/linked-list.md) [`分治`](/tag/divide-and-conquer.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree)

## 题目

<p>给定一个单链表的头节点 &nbsp;<code>head</code>&nbsp;，其中的元素 <strong>按升序排序</strong> ，将其转换为 <span data-keyword="height-balanced">平衡</span> 二叉搜索树。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" style="height: 388px; width: 500px;" /></p>

<pre>
<strong>输入:</strong> head = [-10,-3,0,5,9]
<strong>输出:</strong> [0,-3,9,-10,null,5]
<strong>解释:</strong> 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> head = []
<strong>输出:</strong> []
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>head</code>&nbsp;中的节点数在<code>[0, 2 * 10<sup>4</sup>]</code>&nbsp;范围内</li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>


## 解题思路

可以通过递归的方式实现，使用快慢指针找到链表的中间节点，并以中间节点为根构建左右子树。

1. **找到链表的中间节点：** 为了构建平衡二叉搜索树，我们需要找到链表的中间节点作为根节点。可以通过快慢指针的方式，一个指针每次走两步，另一个指针每次走一步，直到快指针到达链表末尾，慢指针即为中间节点。在这个过程中，用一个 `prev` 指针指向中间节点的前一个节点，方便从中间切断链表。

2. **以中间节点为根构建左右子树：** 将找到的中间节点作为当前子树的根节点，然后递归地构建左子树和右子树。对于左子树，递归处理链表的前半部分；对于右子树，递归处理链表的后半部分。

3. **递归终止条件：** 在递归过程中，当链表为空或只有一个节点时，直接返回对应的树节点。这是递归的终止条件。

4. **返回根节点：** 最终返回根节点作为整棵平衡二叉搜索树的根。

## 代码

```javascript
/**
 * @param {ListNode} head
 * @return {TreeNode}
 */
var sortedListToBST = function (head) {
	if (!head) return null;

	// 使用快慢指针找到链表中间节点
	let slow = head;
	let fast = head;
	let prev = null;
	while (fast && fast.next) {
		prev = slow;
		slow = slow.next;
		fast = fast.next.next;
	}

	// 中间节点作为根节点
	let root = new TreeNode(slow.val);

	// 递归构建左右子树
	if (prev) {
		prev.next = null; // 切断链表
		root.left = sortedListToBST(head);
	}
	root.right = sortedListToBST(slow.next);

	return root;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 108 | [将有序数组转换为二叉搜索树](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree) | [[✓]](/problem/0108.md) |  [`树`](/tag/tree.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`数组`](/tag/array.md) `2+` | <font color=#15bd66>Easy</font> |
| 2196 | [根据描述创建二叉树](https://leetcode.com/problems/create-binary-tree-from-descriptions) | [[✓]](/problem/2196.md) |  [`树`](/tag/tree.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |