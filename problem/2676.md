# [2676. 节流](https://leetcode.com/problems/throttle)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/throttle)

## 题目



## 解题思路

这个 `throttle` 函数的核心思想是通过控制函数的执行频率，防止在短时间内频繁调用同一个函数。通过设置一个延迟时间 `t`，可以确保在某个时间窗口内，函数只会执行一次。如果在延迟期间再次调用函数，它会保存最新的参数，并在延迟结束后使用这些参数再次执行函数。

1. **初始化变量**：

   - `pending`: 用来标识当前是否有一个正在进行的延迟计时，如果为 `true`，意味着当前函数调用正在被节流，不允许立即再次调用。
   - `nestArgs`: 用来存储最新的函数参数，当节流期间再次调用函数时，它会保存最新传递的参数。

2. **立即执行**：

   - 在没有延迟的情况下（`pending` 为 `false`），立即调用传递的函数 `fn(...args)`，并将 `pending` 设为 `true`，表示此时函数进入节流状态。
   - 设置一个 `setTimeout`，确保在延迟 `t` 毫秒后，重置 `pending` 状态，以允许函数在延迟结束后再次执行。

3. **延迟期间存储最新参数**：
   - 当延迟时间内再次调用节流函数时，更新最新的参数到 `nestArgs`，确保最新的一次调用不会丢失。
4. **延迟结束后执行最新参数**：
   - 一旦延迟结束，检查是否存在存储的最新参数。如果存在，则再次递归调用节流函数，使用最新的参数进行调用。

#### 复杂度分析

- **时间复杂度**：`O(1)`，每次调用 `throttle` 函数的时间复杂度为 `O(1)`，因为它只是简单的检查计时器和存储参数。
- **空间复杂度**：`O(1)`，主要用于存储最新参数 `lastArgs`。

## 代码

```javascript
/**
 * @param {Function} fn
 * @param {number} t milliseconds
 * @return {Function}
 */
var throttle = function (fn, t) {
	let pending = false,
		nestArgs;
	const throttleFn = function (...args) {
		// 更新最新的参数
		nestArgs = args;
		if (!pending) {
			// 立即调用
			fn(...args);
			pending = true;
			nestArgs = undefined;
			setTimeout(() => {
				pending = false;
				// 在延迟结束后，使用最新参数递归调用节流函数
				if (nestArgs) {
					throttleFn(...nestArgs);
				}
			}, t);
		}
	};
	return throttleFn;
};

/**
 * const throttled = throttle(console.log, 100);
 * throttled("log"); // logged immediately.
 * throttled("log"); // logged at t=100ms.
 */

/**
 * // 测试函数
 * function runTest() {
 * 	const calls = [
 * 		{ t: 50, inputs: [1] },
 * 		{ t: 75, inputs: [2] },
 * 		{ t: 90, inputs: [8] },
 * 		{ t: 140, inputs: [5, 7] },
 * 		{ t: 300, inputs: [9, 4] }
 * 	];
 *
 * 	const results = [];
 * 	const start = performance.now();
 * 	const throttledLog = throttle((...args) => {
 * 		const time = performance.now();
 * 		results.push({ t: Math.floor(time), inputs: args });
 * 		console.log(`Executed at ${time - start}ms with arguments:`, args);
 * 	}, 70);
 *
 * 	calls.forEach((call) => {
 * 		setTimeout(() => {
 * 			throttledLog(...call.inputs);
 * 		}, call.t);
 * 	});
 *
 * 	// 延迟300ms后打印结果
 * 	setTimeout(() => {
 * 		console.log('Final Results:', results);
 * 	}, 400);
 * }
 * runTest();
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2627 | [函数防抖](https://leetcode.com/problems/debounce) | [[✓]](/problem/2627.md) |  | <font color=#ffb800>Medium</font> |
| 2636 | [Promise 对象池](https://leetcode.com/problems/promise-pool) | [[✓]](/problem/2636.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [有时间限制的 Promise 对象](https://leetcode.com/problems/promise-time-limit) | [[✓]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |