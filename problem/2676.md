# [2676. 节流](https://leetcode.com/problems/throttle)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/throttle)

## 题目

<p>现给定一个函数 <code>fn</code> 和一个以毫秒为单位的时间 <code>t</code> ，请你返回该函数的 <strong>节流</strong> 版本。</p>

<p><strong>节流</strong> 函数首先立即被调用，然后在 <code>t</code> 毫秒的时间间隔内不能再次执行，但应该存储最新的函数参数，以便在延迟结束后使用这些参数调用 <code>fn</code> 。</p>

<p>例如，<code>t = 50ms</code> ，并且函数在 <code>30ms</code> 、 <code>40ms</code> 和 <code>60ms</code> 时被调用。</p>

<p>在 <code>30ms</code>，<strong>节流</strong> 函数 <code>fn</code>&nbsp;会以这些函数调用，并且对 <strong>节流</strong> 函数&nbsp;<code>fn</code> 的调用在接下来的&nbsp;<code>t</code> 毫秒会被阻塞。</p>

<p>在 <code>40ms</code>，函数应当只是存储参数。</p>

<p>在 <code>60ms</code>，参数应该覆盖第二次调用中当前存储的参数，因为第二次和第三次调用是在 <code>80ms</code> 之前进行的。延迟结束后，应该使用延迟期间提供的最新参数来调用 <strong>节流</strong> 函数 <code>fn</code>，并且它还应该创建另一个 <code>80ms + t</code> 的延迟。</p>

<p><img alt="Throttle Diagram" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2600-2699/2676.Throttle/images/screen-shot-2023-04-08-at-120313-pm.png" style="width: 1156px; height: 372px;" />上面的图示展示了节流如何转换事件。每个矩形代表100毫秒，节流时间为400毫秒。每种颜色代表不同的输入集合。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<b>输入：</b>t = 100, 
calls = [
&nbsp; {"t":20,"inputs":[1]}
]
<b>输出：</b>[{"t":20,"inputs":[1]}]
<b>解释：</b>第一次调用总是立即执行，没有延迟。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<b>输入：</b>t = 50, 
calls = [
  {"t":50,"inputs":[1]},
  {"t":75,"inputs":[2]}
]
<b>输出：</b>[{"t":50,"inputs":[1]},{"t":100,"inputs":[2]}]
<b>解释：</b>
第一次调用立即执行带有参数 (1) 的函数。 
第二次调用发生在 75毫秒 时，在延迟期间内，因为 50毫秒 + 50毫秒 = 100毫秒，所以下一次调用可以在 100毫秒 时执行。因此，我们保存第二次调用的参数，以便在第一次调用的回调函数中使用。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<b>输入：</b>t = 70, 
calls = [
  {"t":50,"inputs":[1]},
  {"t":75,"inputs":[2]},
  {"t":90,"inputs":[8]},
  {"t": 140, "inputs":[5,7]},
  {"t": 300, "inputs": [9,4]}
]
<b>输出：</b>[{"t":50,"inputs":[1]},{"t":120,"inputs":[8]},{"t":190,"inputs":[5,7]},{"t":300,"inputs":[9,4]}]
<b>解释：</b>
第一次调用立即执行带有参数 (1) 的函数。 
第二次调用发生在 75毫秒 时，在延迟期间内，因为 50毫秒 + 70毫秒 = 120毫秒，所以它只应保存参数。 
第三次调用也在延迟期间内，因为我们只需要最新的函数参数，所以覆盖之前的参数。延迟期过后，在 120毫秒时进行回调，并使用保存的参数进行调用。该回调会创建另一个延迟期间，时长为 120毫秒 + 70毫秒 = 190毫秒，以便下一个函数可以在 190毫秒时调用。 
第四次调用发生在 140毫秒，在延迟期间内，因此应在190毫秒时作为回调进行调用。这将创建另一个延迟期间，时长为 190毫秒 + 70毫秒 = 260毫秒。 
第五次调用发生在 300毫秒，但它是在 260毫秒 之后，所以应立即调用，并创建另一个延迟期间，时长为 300毫秒 + 70毫秒 = 370毫秒。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= t &lt;= 1000</code></li>
	<li><code>1 &lt;= calls.length &lt;= 10</code></li>
	<li><code>0 &lt;= calls[i].t &lt;= 1000</code></li>
	<li><code>0 &lt;= calls[i].inputs[i], calls[i].inputs.length &lt;= 10</code></li>
</ul>

## 解题思路

这个 `throttle` 函数的核心思想是通过控制函数的执行频率，防止在短时间内频繁调用同一个函数。通过设置一个延迟时间 `t`，可以确保在某个时间窗口内，函数只会执行一次。如果在延迟期间再次调用函数，它会保存最新的参数，并在延迟结束后使用这些参数再次执行函数。

1. **初始化变量**：

   - `pending`: 用来标识当前是否有一个正在进行的延迟计时，如果为 `true`，意味着当前函数调用正在被节流，不允许立即再次调用。
   - `nestArgs`: 用来存储最新的函数参数，当节流期间再次调用函数时，它会保存最新传递的参数。

2. **立即执行**：

   - 在没有延迟的情况下（`pending` 为 `false`），立即调用传递的函数 `fn(...args)`，并将 `pending` 设为 `true`，表示此时函数进入节流状态。
   - 设置一个 `setTimeout`，确保在延迟 `t` 毫秒后，重置 `pending` 状态，以允许函数在延迟结束后再次执行。

3. **延迟期间存储最新参数**：
   - 当延迟时间内再次调用节流函数时，更新最新的参数到 `nestArgs`，确保最新的一次调用不会丢失。
4. **延迟结束后执行最新参数**：
   - 一旦延迟结束，检查是否存在存储的最新参数。如果存在，则再次递归调用节流函数，使用最新的参数进行调用。

#### 复杂度分析

- **时间复杂度**：`O(1)`，每次调用 `throttle` 函数的时间复杂度为 `O(1)`，因为它只是简单的检查计时器和存储参数。
- **空间复杂度**：`O(1)`，主要用于存储最新参数 `lastArgs`。

## 代码

```javascript
/**
 * @param {Function} fn
 * @param {number} t milliseconds
 * @return {Function}
 */
var throttle = function (fn, t) {
	let pending = false,
		nestArgs;
	const throttleFn = function (...args) {
		// 更新最新的参数
		nestArgs = args;
		if (!pending) {
			// 立即调用
			fn(...args);
			pending = true;
			nestArgs = undefined;
			setTimeout(() => {
				pending = false;
				// 在延迟结束后，使用最新参数递归调用节流函数
				if (nestArgs) {
					throttleFn(...nestArgs);
				}
			}, t);
		}
	};
	return throttleFn;
};

/**
 * const throttled = throttle(console.log, 100);
 * throttled("log"); // logged immediately.
 * throttled("log"); // logged at t=100ms.
 */

/**
 * // 测试函数
 * function runTest() {
 * 	const calls = [
 * 		{ t: 50, inputs: [1] },
 * 		{ t: 75, inputs: [2] },
 * 		{ t: 90, inputs: [8] },
 * 		{ t: 140, inputs: [5, 7] },
 * 		{ t: 300, inputs: [9, 4] }
 * 	];
 *
 * 	const results = [];
 * 	const start = performance.now();
 * 	const throttledLog = throttle((...args) => {
 * 		const time = performance.now();
 * 		results.push({ t: Math.floor(time), inputs: args });
 * 		console.log(`Executed at ${time - start}ms with arguments:`, args);
 * 	}, 70);
 *
 * 	calls.forEach((call) => {
 * 		setTimeout(() => {
 * 			throttledLog(...call.inputs);
 * 		}, call.t);
 * 	});
 *
 * 	// 延迟300ms后打印结果
 * 	setTimeout(() => {
 * 		console.log('Final Results:', results);
 * 	}, 400);
 * }
 * runTest();
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2627 | [函数防抖](https://leetcode.com/problems/debounce) | [[✓]](/problem/2627.md) |  | <font color=#ffb800>Medium</font> |
| 2636 | [Promise 对象池](https://leetcode.com/problems/promise-pool) | [[✓]](/problem/2636.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [有时间限制的 Promise 对象](https://leetcode.com/problems/promise-time-limit) | [[✓]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |