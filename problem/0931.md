# [931. 下降路径最小和](https://leetcode.com/problems/minimum-falling-path-sum)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) [`矩阵`](/tag/matrix.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-falling-path-sum)

## 题目

<p>给你一个 <code>n x n</code> 的<strong> 方形 </strong>整数数组&nbsp;<code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong><em> </em>的<strong> </strong><strong>最小和</strong> 。</p>

<p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg" style="height: 500px; width: 499px;" /></p>

<pre>
<strong>输入：</strong>matrix = [[2,1,3],[6,5,4],[7,8,9]]
<strong>输出：</strong>13
<strong>解释：</strong>如图所示，为和最小的两条下降路径
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg" style="height: 365px; width: 164px;" /></p>

<pre>
<strong>输入：</strong>matrix = [[-19,57],[-40,-5]]
<strong>输出：</strong>-59
<strong>解释：</strong>如图所示，为和最小的下降路径
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>


## 解题思路

这是一个典型的动态规划问题。可以采用自底向上的方法，从矩阵的倒数第二行开始，逐行更新，直到第一行。

定义状态 `dp[i][j]` 为从第一行（`matrix[0][..]`）向下落，落到位置 `matrix[i][j]` 的最小路径和为 `dp[i][j]`。那么，`dp[i][j]` 的值可以通过考虑从 `dp[i-1][j-1]`，`dp[i-1][j]` 和 `dp[i-1][j+1]` 这三个路径和中，选择其中路径和最小的一个。

具体的状态转移方程为：

`dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])`

最终，我们只需从 `dp` 数组的最后一行中找到最小的路径和，即为最终的答案：

`return Math.min(...dp[m - 1]);`

由于 `dp[i][j]` 只和 `dp[i - 1][...]` 有关，所以可以进一步优化空间复杂度，除了可以将 `dp` 数组降维以外，甚至可以不使用 `dp` 数组，直接原地修改 `matrix` 数组。

#### 复杂度分析

- **时间复杂度**：`O(m * n)`，其中 `m` 为矩阵行数，`n` 为矩阵列数，需要遍历整个矩阵。
- **空间复杂度**：`O(1)`，原地修改矩阵。

## 代码

```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var minFallingPathSum = function (matrix) {
	const m = matrix.length;
	const n = matrix[0].length;

	// 从倒数第二行开始逐行更新
	for (let i = 1; i < m; i++) {
		for (let j = 0; j < n; j++) {
			// 考虑边界情况
			if (j == 0) {
				matrix[i][j] =
					Math.min(matrix[i - 1][j], matrix[i - 1][j + 1]) + matrix[i][j];
			} else if (j == n - 1) {
				matrix[i][j] =
					Math.min(matrix[i - 1][j - 1], matrix[i - 1][j]) + matrix[i][j];
			} else {
				matrix[i][j] =
					Math.min(
						matrix[i - 1][j - 1],
						matrix[i - 1][j],
						matrix[i - 1][j + 1]
					) + matrix[i][j];
			}
		}
	}
	// 返回最后一行的最小路径和
	return Math.min(...matrix[m - 1]);
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1289 | [下降路径最小和  II](https://leetcode.com/problems/minimum-falling-path-sum-ii) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) [`矩阵`](/tag/matrix.md) | <font color=#ff334b>Hard</font> |