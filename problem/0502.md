# [502. IPO](https://leetcode.com/problems/ipo)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`排序`](/tag/sorting.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/ipo)

## 题目

<p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p>

<p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code><strong> </strong>，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p>

<p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>

<p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p>

<p>答案保证在 32 位有符号整数范围内。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
<strong>输出：</strong>4
<strong>解释：
</strong>由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
<strong>输出：</strong>6
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>
	<li><code>n == profits.length</code></li>
	<li><code>n == capital.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>
</ul>


## 解题思路

可以通过优先队列（堆）来解决。我们可以维护一个大顶堆。每次将总资本允许的条件下所有项目的利润加入堆中，并弹出堆顶元素，将其加入到总利润中，直到做完了 `k` 个不同项目，最终返回总利润。

1. 将项目的成本和利润成对加入到数组 `vp` 中，并按照成本升序排序；
2. 构建一个大顶堆 heap ，堆中的每个元素是项目的利润；
3. 重复以下步骤 `k` 次：
   - 将所有成本 `capital` 小于总资本 `totalProfit` 的项目加入堆中；
   - 弹出堆顶元素，并将更新加入总资本 `totalProfit` 中；
4. 返回总资本 `totalProfit`；

## 代码

```javascript
/**
 * @param {number} k
 * @param {number} w
 * @param {number[]} profits
 * @param {number[]} capital
 * @return {number}
 */
var findMaximizedCapital = function (k, w, profits, capital) {
	let heap = [];
	const insert = (value) => {
		heap.push(value);
		heapifyUp(heap.length - 1);
	};

	const pop = () => {
		if (heap.length == 0) return null;
		const max = heap[0],
			min = heap.pop();
		if (heap.length > 0) {
			heap[0] = min;
			heapifyDown(0);
		}
		return max;
	};

	const heapifyUp = (i) => {
		while (i) {
			const parent = ((i - 1) / 2) | 0;
			if (heap[i] > heap[parent]) {
				[heap[i], heap[parent]] = [heap[parent], heap[i]];
				i = parent;
			} else {
				break;
			}
		}
	};

	const heapifyDown = (i) => {
		let left = i * 2 + 1,
			right = i * 2 + 2,
			min = i;
		if (left < heap.length && heap[left] > heap[min]) {
			min = left;
		}
		if (right < heap.length && heap[right] > heap[min]) {
			min = right;
		}
		if (min !== i) {
			[heap[min], heap[i]] = [heap[i], heap[min]];
			heapifyDown(min);
		}
	};

	let vp = [],
		len = profits.length;

	for (let i = 0; i < len; i++) {
		vp.push([capital[i], profits[i]]);
	}
	vp.sort((a, b) => a[0] - b[0]);

	let totalProfit = w,
		count = 0;
	for (let i = 0; i < k; i++) {
		while (count < len && vp[count][0] <= totalProfit) {
			insert(vp[count][1]);
			count++;
		}
		if (heap.length == 0) {
			break;
		}
		totalProfit += pop();
	}
	return totalProfit;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2542 | [最大子序列的分数](https://leetcode.com/problems/maximum-subsequence-score) |  |  [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`排序`](/tag/sorting.md) `1+` | <font color=#ffb800>Medium</font> |
| 2813 | [子序列最大优雅度](https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence) |  |  [`栈`](/tag/stack.md) [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) `3+` | <font color=#ff334b>Hard</font> |