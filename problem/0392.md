# [392. 判断子序列](https://leetcode.com/problems/is-subsequence)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/is-subsequence)

## 题目

<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>

<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p>

<p><strong>进阶：</strong></p>

<p>如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>

<p><strong>致谢：</strong></p>

<p>特别感谢<strong> </strong><a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "abc", t = "ahbgdc"
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "axc", t = "ahbgdc"
<strong>输出：</strong>false
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 <= s.length <= 100</code></li>
	<li><code>0 <= t.length <= 10^4</code></li>
	<li>两个字符串都只由小写字符组成。</li>
</ul>


## 解题思路

### 思路一：双指针

使用两个指针 `i`、`j` 分别指向字符串 `s` 和 `t`，然后对两个字符串进行遍历，时间复杂度 `O(n)`。

- 遇到 `s[i] == t[j]` 的情况，则 `i` 向右移。
- 不断右移 `j`。
- 如果超过 `s` 或 `t` 的长度则跳出。
- 最后判断指针 `i` 是否指向了 `s` 的末尾，即：判断 `i` 是否等于 `s` 的长度。如果等于，则说明 `s` 是 `t` 的子序列，如果不等于，则不是。

### 进阶：二分思路

二分思路主要是对 `t` 进行预处理，用一个字典将每个字符出现的索引位置按顺序存储下来，比如 `"abacb"` 的字典为：`{a: [0, 1], b: [1, 4], c: [3]}` ，这样我们不需要每次都遍历 `t` ，只需查看字典中，是否有满足要求的索引即可。

## 代码

::: code-tabs
@tab 双指针

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function (s, t) {
	let i = 0;
	let j = 0;
	while (i < s.length && j < t.length) {
		if (s[i] == t[j]) {
			i++;
		}
		j++;
	}
	return i == s.length;
};
```

@tab 进阶：二分法

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function (s, t) {
	let indexMap = {};
	for (let i = 0; i < t.length; i++) {
		if (!indexMap[t[i]]) {
			indexMap[t[i]] = new Array();
		}
		indexMap[t[i]].push(i);
	}
	// 串 t 上的指针
	let j = 0;
	for (let i = 0; i < s.length; i++) {
		// 整个 t 压根儿没有这个字符
		if (!indexMap[s[i]]) return false;
		let pos = left_bound(indexMap[s[i]], j);
		console.log(s[i], pos, j);
		// 二分搜索区间中没有找到字符 c
		if (pos == -1) return false;
		// 向前移动指针 j
		j = indexMap[s[i]][pos] + 1;
	}
	return true;
};

// 查找左侧边界的二分查找
var left_bound = function (arr, target) {
	let left = 0,
		right = arr.length;
	while (left < right) {
		let mid = left + Math.floor((right - left) / 2);
		if (target > arr[mid]) {
			left = mid + 1;
		} else {
			right = mid;
		}
	}
	// 如果 left 越界 说明数组中不存在 target
	if (left == arr.length) {
		return -1;
	}
	return left;
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 792 | [匹配子序列的单词数](https://leetcode.com/problems/number-of-matching-subsequences) |  |  [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) `4+` | <font color=#ffb800>Medium</font> |
| 1055 | [形成字符串的最短路径](https://leetcode.com/problems/shortest-way-to-form-string) |  |  [`贪心`](/tag/greedy.md) [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) `1+` | <font color=#ffb800>Medium</font> |
| 2486 | [追加字符以获得子序列](https://leetcode.com/problems/append-characters-to-string-to-make-subsequence) |  |  [`贪心`](/tag/greedy.md) [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) | <font color=#ffb800>Medium</font> |
| 2825 | [循环增长使字符串子序列等于另一个字符串](https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments) |  |  [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) | <font color=#ffb800>Medium</font> |