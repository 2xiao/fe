# [101. 对称二叉树](https://leetcode.com/problems/symmetric-tree)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/symmetric-tree)

## 题目

<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" style="width: 354px; height: 291px;" />
<pre>
<strong>输入：</strong>root = [1,2,2,3,4,4,3]
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" style="width: 308px; height: 258px;" />
<pre>
<strong>输入：</strong>root = [1,2,2,null,3,null,3]
<strong>输出：</strong>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>


## 解题思路

### 思路一：递归

二叉树轴对称需要满足：

- 根节点的左子节点和右子节点对称相等
- 左子节点的左子节点与右子节点的右子节点对称相等
- 左子节点的右子节点与右子节点的左子节点对称相等

递归地去判断每一层是否满足以上三个条件。

---

### 思路二：迭代

使用队列来对比左子树和右子树上每一个对称的节点对。

---

### 思路三：翻转二叉树

这道题是[第 226 题 翻转二叉树](./0226.md) 和 [第 100 题 判断两颗树是否完全相等](./0100.md)的综合题，可以将根节点的左子树翻转，然后再和根节点的右子树进行比较，是否完全相等。

## 代码

::: code-tabs
@tab 递归

```javascript
var isSymmetric = function (root) {
	if (root == null) return true;
	const isMirror = (left, right) => {
		if (!left && !right) return true;
		if (!left || !right) return false;
		return (
			left.val == right.val &&
			isMirror(left.left, right.right) &&
			isMirror(left.right, right.left)
		);
	};
	return isMirror(root.left, root.right);
};
```

@tab 迭代

```javascript
var isSymmetric = function (root) {
	if (!root) return true;
	let queue = [[root.left, root.right]];
	while (queue.length) {
		const [left, right] = queue.shift();
		if (!left && !right) continue;
		if (!left || !right || left.val !== right.val) return false;
		queue.push([left.left, right.right]);
		queue.push([left.right, right.left]);
	}
	return true;
};
```

@tab 翻转二叉树

```javascript
var isSymmetric = function (root) {
	if (root == null) return true;

	// 翻转二叉树
	const invert = (root) => {
		if (root == null) return null;
		let temp = root.left;
		root.left = invert(root.right);
		root.right = invert(temp);
		return root;
	};

	// 两棵树是否全等
	const isSame = (p, q) => {
		if (p == null && q == null) return true;
		else if (p != null && q != null) {
			if (p.val != q.val) return false;
			return isSame(p.left, q.left) && isSame(p.right, q.right);
		}
		return false;
	};

	return isSame(invert(root.left), root.right);
};
```

:::
