# [2631. 分组](https://leetcode.com/problems/group-by)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/group-by)

## 题目

<p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>

<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>

<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>

<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>

<p>请在不使用 lodash 的&nbsp;<code>_.groupBy</code> 函数的前提下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<b>输入：</b>
array = [
&nbsp; {"id":"1"},
&nbsp; {"id":"1"},
&nbsp; {"id":"2"}
], 
fn = function (item) { 
&nbsp; return item.id; 
}
<b>输出：</b>
{ 
&nbsp; "1": [{"id": "1"}, {"id": "1"}], &nbsp; 
&nbsp; "2": [{"id": "2"}] 
}
<strong>解释：</strong>
输出来自函数 array.groupBy(fn)。
分组选择方法是从数组中的每个项中获取 "id" 。
有两个 "id" 为 1 的对象。所以将这两个对象都放在第一个数组中。
有一个 "id" 为 2 的对象。所以该对象被放到第二个数组中。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<b>输入：</b>
array = [
&nbsp; [1, 2, 3],
&nbsp; [1, 3, 5],
&nbsp; [1, 5, 9]
]
fn = function (list) { 
&nbsp; return String(list[0]); 
}
<b>输出：</b>
{ 
&nbsp; "1": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] 
}
<strong>解释：</strong>
数组可以是任何类型的。在本例中，分组选择方法是将键定义为数组中的第一个元素。
所有数组的第一个元素都是1，所以它们被组合在一起。
{
  "1": [[1, 2, 3], [1, 3, 5], [1, 5, 9]]
}
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<b>输出：</b>
array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
fn = function (n) { 
&nbsp; return String(n &gt; 5);
}
<strong>输入：</strong>
{
&nbsp; "true": [6, 7, 8, 9, 10],
&nbsp; "false": [1, 2, 3, 4, 5]
}
<strong>解释：</strong>
分组选择方法是根据每个数字是否大于 5 来分割数组。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= array.length &lt;= 10<sup>5</sup></code></li>
	<li><code>fn 返回一个字符串</code></li>
</ul>


## 解题思路

1. **创建结果对象**：使用一个空对象来存储分组结果。
2. **遍历数组**：使用 `forEach` 方法遍历调用 `groupBy` 的数组。
3. **使用分组函数**：对于每个元素，调用 `fn(item)` 函数以获取分组键。
4. **构建分组结果**：
   - 检查结果对象中是否已有该分组键。如果没有，创建一个新的数组。
   - 将当前元素添加到相应的分组中。
5. **返回结果对象**：最后返回分组后的结果对象。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度，因为需要遍历整个数组。
- **空间复杂度**：`O(n)`，在最坏情况下，所有元素可能会被分到一个组中。

## 代码

```javascript
/**
 * @param {Function} fn
 * @return {Object}
 */
Array.prototype.groupBy = function (fn) {
	let res = {};
	this.forEach((item) => {
		const key = fn(item);
		if (!res[key]) {
			res[key] = [];
		}
		res[key].push(item);
	});
	return res;
};

/**
 * [1,2,3].groupBy(String) // {"1":[1],"2":[2],"3":[3]}
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2624 | [蜗牛排序](https://leetcode.com/problems/snail-traversal) | [[✓]](/problem/2624.md) |  | <font color=#ffb800>Medium</font> |
| 2626 | [数组归约运算](https://leetcode.com/problems/array-reduce-transformation) | [[✓]](/problem/2626.md) |  | <font color=#15bd66>Easy</font> |
| 2634 | [过滤数组中的元素](https://leetcode.com/problems/filter-elements-from-array) | [[✓]](/problem/2634.md) |  | <font color=#15bd66>Easy</font> |
| 2635 | [转换数组中的每个元素](https://leetcode.com/problems/apply-transform-over-each-element-in-array) | [[✓]](/problem/2635.md) |  | <font color=#15bd66>Easy</font> |
| 2774 | [数组的上界](https://leetcode.com/problems/array-upper-bound) |  |  | <font color=#15bd66>Easy</font> |