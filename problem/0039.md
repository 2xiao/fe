# [39. 组合总和](https://leetcode.com/problems/combination-sum)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/combination-sum)

## 题目

<p>给你一个 <strong>无重复元素</strong> 的整数数组&nbsp;<code>candidates</code> 和一个目标整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中可以使数字和为目标数&nbsp;<code>target</code> 的 所有<em>&nbsp;</em><strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>

<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。&nbsp;</p>

<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的不同组合数少于 <code>150</code> 个。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>candidates = <code>[2,3,6,7]</code>, target = <code>7</code>
<strong>输出：</strong>[[2,2,3],[7]]
<strong>解释：</strong>
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8
<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入: </strong>candidates = <code>[2], </code>target = 1
<strong>输出: </strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
	<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
	<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
	<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>


## 解题思路

这个问题使用回溯法来解决。回溯法是一种通过不断尝试生成问题的所有解的算法，如果解不符合要求，就撤销上一步甚至上几步的计算，再通过其他可能的分支寻找正确的解。具体步骤如下：

1. **定义回溯函数：** 定义一个回溯函数 `backtrack`，接收一个起始索引 `start` 作为参数，表示从候选数组的哪个位置开始考虑，避免重复组合。

2. **回溯过程：** 在回溯的过程中，不断选择当前位置的数字，并更新当前组合的和 `sum`。如果 `sum` 等于目标值 `target`，则将当前组合添加到结果集中。

3. **递归调用：** 如果 `sum` 小于 `target`，则继续在当前位置和之后的位置进行递归。如果 `sum` 大于 `target`，说明当前组合不满足条件，需要撤销当前选择，返回上一层继续尝试其他分支。

4. **限制条件：** 在递归的过程中，通过判断 `sum` 是否等于 `target` 来确保生成的组合是符合要求的。递归时传入 `i` 作为参数，表示从当前位置开始尝试，以确保可以重复使用当前数字。

5. **返回结果：** 最终通过调用 `backtrack` 函数得到所有符合条件的组合，返回这些组合的数组作为结果。

#### 复杂度分析

- **时间复杂度**：`O(n^t)`，`n` 为 `candidates` 长度，`t = target / 最小候选数`，主要由递归树的深度和每层递归中循环次数决定。
  - 递归树的每一层代表从数组 `candidates` 中选择一个数字加入到组合中的过程。每个数字都可以重复使用，因此递归树的深度最大为 `target / 最小候选数`。
  - 在最坏情况下，递归树的每个节点都要进行 `n` 次循环操作来选择候选数，因此递归树的节点总数最多为 `n^(target / 最小候选数)`。
- **空间复杂度**：`O(t)`，`t = target / 最小候选数`，主要由递归深度决定，递归树的深度可能达到 `target / 最小候选数`。

## 代码

```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
	const len = candidates.length;
	let res = [];
	let track = [];
	let sum = 0;

	const backtrack = (start) => {
		// 满足条件
		if (sum == target) {
			res.push([...track]);
			return;
		}
		// 剪枝
		if (sum > target) {
			return;
		}
		for (let i = start; i < len; i++) {
			track.push(candidates[i]);
			sum += candidates[i];

			// 注意这里传入的参数是 i 而不是 i + 1，表示可以重复使用当前的数字
			backtrack(i);

			track.pop();
			sum -= candidates[i];
		}
	};
	backtrack(0);
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 17 | [电话号码的字母组合](https://leetcode.com/problems/letter-combinations-of-a-phone-number) | [[✓]](/problem/0017.md) |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 40 | [组合总和 II](https://leetcode.com/problems/combination-sum-ii) | [[✓]](/problem/0040.md) |  [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 77 | [组合](https://leetcode.com/problems/combinations) | [[✓]](/problem/0077.md) |  [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 216 | [组合总和 III](https://leetcode.com/problems/combination-sum-iii) | [[✓]](/problem/0216.md) |  [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 254 | [因子的组合](https://leetcode.com/problems/factor-combinations) |  |  [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 377 | [组合总和 Ⅳ](https://leetcode.com/problems/combination-sum-iv) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |
| 3183 | [达到总和的方法数量](https://leetcode.com/problems/the-number-of-ways-to-make-the-sum) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |