# [2583. 二叉树中的第 K 大层和](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`二叉树`](/tag/binary-tree.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree)

## 题目

<p>给你一棵二叉树的根节点 <code>root</code> 和一个正整数 <code>k</code> 。</p>

<p>树中的 <strong>层和</strong> 是指 <strong>同一层</strong> 上节点值的总和。</p>

<p>返回树中第 <code>k</code> 大的层和（不一定不同）。如果树少于 <code>k</code> 层，则返回 <code>-1</code> 。</p>

<p><strong>注意</strong>，如果两个节点与根节点的距离相同，则认为它们在同一层。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;" /></p>

<pre>
<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], k = 2
<strong>输出：</strong>13
<strong>解释：</strong>树中每一层的层和分别是：
- Level 1: 5
- Level 2: 8 + 9 = 17
- Level 3: 2 + 1 + 3 + 7 = 13
- Level 4: 4 + 6 = 10
第 2 大的层和等于 13 。
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png" style="width: 181px; height: 181px;" /></p>

<pre>
<strong>输入：</strong>root = [1,2,null,3], k = 1
<strong>输出：</strong>3
<strong>解释：</strong>最大的层和是 3 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中的节点数为 <code>n</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>


## 解题思路

1. **宽度优先搜索（BFS）**：使用 BFS 遍历二叉树，计算同一层上节点的层和。

2. **收集路径和**：在遍历过程中，将每一层的层和存储在一个数组中。

3. **排序并选择**：对层和进行降序排序，以找到第 `k` 大的层和。

4. **边界条件**：注意如果树少于 `k` 层，则返回 `-1`。

#### 复杂度分析

- **时间复杂度**：`O(n log n)`，其中 `n` 是树中节点的数量。BFS 的遍历时间为 `O(n)`，然后对路径和进行排序需要 `O(n log n)` 的时间。
- **空间复杂度**：`O(n)`，用于存储路径和的数组。

## 代码

```javascript
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestLevelSum = function (root, k) {
	let queue = [root],
		levelSum = [];

	// BFS
	while (queue.length) {
		const len = queue.length;
		let sum = 0;
		for (let i = 0; i < len; i++) {
			const node = queue.shift();
			sum += node.val;
			if (node.left) queue.push(node.left);
			if (node.right) queue.push(node.right);
		}
		levelSum.push(sum);
	}
	// 如果树少于 k 层，则返回 -1
	if (levelSum.length < k) return -1;

	// 按降序排序，返回第 k 大的层和
	return levelSum.sort((a, b) => b - a)[k - 1];
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 144 | [二叉树的前序遍历](https://leetcode.com/problems/binary-tree-preorder-traversal) | [[✓]](/problem/0144.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `1+` | <font color=#15bd66>Easy</font> |
| 1161 | [最大层内元素和](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | <font color=#ffb800>Medium</font> |
| 3157 | [找到具有最小和的树的层数](https://leetcode.com/problems/find-the-level-of-tree-with-minimum-sum) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | <font color=#ffb800>Medium</font> |