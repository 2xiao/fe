# [605. 种花问题](https://leetcode.com/problems/can-place-flowers)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/can-place-flowers)

## 题目

<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>

<p>给你一个整数数组&nbsp;<code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数&nbsp;<code>n</code><strong> </strong>，能否在不打破种植规则的情况下种入&nbsp;<code>n</code><strong>&nbsp;</strong>朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 1
<strong>输出：</strong>true
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 2
<strong>输出：</strong>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>
	<li><code>flowerbed</code> 中不存在相邻的两朵花</li>
	<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>
</ul>

## 解题思路

1. **遍历花坛**：

   - 使用一个循环遍历整个 `flowerbed` 数组，寻找可以种花的位置。可以种花的位置是指当前位置为 `0`，且左右相邻的位置也为 `0`（或在边界位置）。

2. **判断种花条件**：

   - 对于每个位置 `i`，判断以下条件：
     - `flowerbed[i] === 0`（当前位置为空）
     - `i === 0 || flowerbed[i - 1] === 0`（左边没有花或在边界）
     - `i === flowerbed.length - 1 || flowerbed[i + 1] === 0`（右边没有花或在边界）
   - 如果以上条件成立，则可以在当前位置种花。

3. **更新花数**：

   - 每次成功种花后，将 `count` 加一，并将当前位置标记为 `1`（种花）。

4. **判断是否满足条件**：
   - 在遍历结束后，检查 `count` 是否大于或等于 `n`；
   - 如果是，返回 `true`；否则返回 `false`。

#### 复杂度分析

- **时间复杂度**：`O(m)`，其中 `m` 是 `flowerbed` 数组的长度，只需遍历一次花坛。
- **空间复杂度**：`O(1)`，只使用常量空间来存储状态。

## 代码

```javascript
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function (flowerbed, n) {
	let count = 0;

	flowerbed.forEach((item, i) => {
		// 检查当前位置是否可以种花
		if (
			flowerbed[i] === 0 &&
			(i === 0 || flowerbed[i - 1] === 0) &&
			(i === flowerbed.length - 1 || flowerbed[i + 1] === 0)
		) {
			flowerbed[i] = 1; // 种花
			count++; // 记录种花数量
		}
	});

	// 检查是否能种下 n 朵花
	return count >= n;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 495 | [提莫攻击](https://leetcode.com/problems/teemo-attacking) |  |  [`数组`](/tag/array.md) [`模拟`](/tag/simulation.md) | <font color=#15bd66>Easy</font> |
| 735 | [小行星碰撞](https://leetcode.com/problems/asteroid-collision) |  |  [`栈`](/tag/stack.md) [`数组`](/tag/array.md) [`模拟`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |