# [259. 较小的三数之和](https://leetcode.com/problems/3sum-smaller)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) [`二分查找`](/tag/binary-search.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/3sum-smaller)

## 题目

<p>给定一个长度为 <code>n</code> 的整数数组和一个目标值 <code>target</code>&nbsp;，寻找能够使条件&nbsp;<code>nums[i] + nums[j] + nums[k] &lt; target</code>&nbsp;成立的三元组&nbsp; <code>i, j, k</code>&nbsp;个数（<code>0 &lt;= i &lt; j &lt; k &lt; n</code>）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入: </strong><em>nums</em> = <code>[-2,0,1,3]</code>, <em>target</em> = 2
<strong>输出: </strong>2 
<strong>解释: </strong>因为一共有两个三元组满足累加和小于 2:
&nbsp;    [-2,0,1]
     [-2,0,3]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入: </strong><em>nums</em> = <code>[]</code>, <em>target</em> = 0
<strong>输出: </strong>0 </pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入: </strong><em>nums</em> = <code>[0]</code>, <em>target</em> = 0
<strong>输出: </strong>0 </pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>0 &lt;= n &lt;= 3500</code></li>
	<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>-100 &lt;= target &lt;= 100</code></li>
</ul>

## 解题思路

- 这道题是 3Sum 问题的一个变形，与 [第 15 题](./0015.md)、[第 16 题](./0016.md) 类似，不过此题不需要排除数值相等的情况。
- 也可以使用对撞指针；
- 先将数组排序，i 从后往前扫描，j，k 两个指针开始一前一后对撞，j 从数组首位开始，k 为 i 的前一个数字；
- 若三数之和大于等于 target，则 k 向左移动，继续判断；
- 若三数之和小于 target，则 j 与 k 之间的所有数做为 k，都满足 `nums[i] + nums[j] + nums[k] < target`，此时将 j 向右移动，继续判断；

## 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumSmaller = function (nums, target) {
	nums = nums.sort((a, b) => a - b);
	const len = nums.length;
	let res = 0;
	for (let i = len - 1; i > 1; i--) {
		let j = 0;
		let k = i - 1;
		while (j < k) {
			let sum = nums[i] + nums[j] + nums[k];
			if (sum >= target) {
				k--;
			} else {
				res += k - j;
				j++;
			}
		}
	}
	return res;
};
```
