# [962. 最大宽度坡](https://leetcode.com/problems/maximum-width-ramp)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`数组`](/tag/array.md) [`单调栈`](/tag/monotonic-stack.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/maximum-width-ramp)

## 题目

<p>给定一个整数数组&nbsp;<code>A</code>，<em>坡</em>是元组&nbsp;<code>(i, j)</code>，其中&nbsp;&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>A[i] &lt;= A[j]</code>。这样的坡的宽度为&nbsp;<code>j - i</code>。</p>

<p>找出&nbsp;<code>A</code>&nbsp;中的坡的最大宽度，如果不存在，返回 0 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>[6,0,8,2,1,5]
<strong>输出：</strong>4
<strong>解释：</strong>
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>[9,8,1,0,1,9,4,0,4,1]
<strong>输出：</strong>7
<strong>解释：</strong>
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li><code>2 &lt;= A.length &lt;= 50000</code></li>
	<li><code>0 &lt;= A[i] &lt;= 50000</code></li>
</ol>

<p>&nbsp;</p>


## 解题思路

1. **单调递减栈法**：

   - 通过维护一个 **单调递减栈** 存储可能成为坡起点的索引 `i`，确保栈顶元素对应的值 `nums[i]` 是比其后的任何值都要大或相等的。
   - 当从左到右遍历数组时，如果当前元素 `nums[i]` 比栈顶元素对应的值小，那么就将其索引 `i` 压入栈中，这保证了栈中存储的是可能成为坡的起点的索引。

2. **从右向左遍历寻找最大坡**：
   - 构建好单调递减栈之后，从右向左遍历数组，尝试找到满足条件 `nums[i] <= nums[j]` 的最大坡宽度。
   - 如果发现当前元素 `nums[j]` 大于或等于栈顶索引对应的元素 `nums[stack顶]`，那么计算 `j - i` 的差值，并更新最大坡宽度。此时，弹出栈顶元素，因为它已经形成了最宽的坡，无法再与后续的 `j` 配对。

#### 复杂度分析

- **时间复杂度**：`O(n)`，遍历数组两次，一次是构建单调栈，一次是从右向左检查坡的宽度。
- **空间复杂度**：`O(n)`，栈最多会存储 `n` 个索引。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxWidthRamp = function (nums) {
	let stack = [],
		maxWidth = 0;

	for (let i = 0; i < nums.length; i++) {
		if (stack.length == 0 || nums[stack[stack.length - 1]] > nums[i]) {
			stack.push(i);
		}
	}

	for (let j = nums.length - 1; j >= 0; j--) {
		while (stack.length && nums[j] >= nums[stack[stack.length - 1]]) {
			maxWidth = Math.max(maxWidth, j - stack.pop());
		}
	}
	return maxWidth;
};
```
