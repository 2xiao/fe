# [29. 两数相除](https://leetcode.com/problems/divide-two-integers)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`位运算`](/tag/bit-manipulation.md) [`数学`](/tag/math.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/divide-two-integers)

## 题目

<p>给你两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。</p>

<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。</p>

<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的 <strong>商</strong> 。</p>

<p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>2<sup>31&nbsp;</sup>− 1</code> ，则返回 <code>2<sup>31&nbsp;</sup>− 1</code> ；如果商 <strong>严格小于</strong> <code>-2<sup>31</sup></code> ，则返回 <code>-2<sup>31</sup></code><sup> </sup>。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre>
<strong>输入:</strong> dividend = 10, divisor = 3
<strong>输出:</strong> 3
<strong>解释: </strong>10/3 = 3.33333.. ，向零截断后得到 3 。</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入:</strong> dividend = 7, divisor = -3
<strong>输出:</strong> -2
<strong>解释:</strong> 7/-3 = -2.33333.. ，向零截断后得到 -2 。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>divisor != 0</code></li>
</ul>


## 解题思路

1. **处理符号问题**：

   - 首先判断结果的符号：如果 `dividend` 和 `divisor` 中只有一个是负数，结果是负的，否则结果为正的。
   - 可以通过将 `dividend` 和 `divisor` 取绝对值来处理后续的无符号整数运算。

2. **倍增法**：

   - 为了模拟除法，我们可以用**减法**模拟。直接进行减法会超时，因此采用**倍增法**提高效率。
   - 基本思想是将除数（`divisor`）不断翻倍（即乘以 2），直到超过被除数（`dividend`）。这相当于不断减去更大的除数倍数（2 的幂次）来逼近结果。
   - 每次当倍增的除数能从被除数中减去时，记录下对应的倍数（即商的部分），直到被除数小于除数为止。

3. **处理边界情况**：

   - 如果 `divisor == 0`，不能除零，直接返回。
   - 如果 `dividend == -2^31` 且 `divisor == -1`，会导致溢出，这种情况下直接返回 `2^31 - 1`（即 `2147483647`）。

4. **返回结果**：
   - 根据之前判断的符号情况，返回商的正负值。

#### 复杂度分析

- **时间复杂度**：`O(logn)`，其中 n 是 `dividend` 的大小。每次倍增都将被除数缩小到原来的一半，故时间复杂度为对数级别。
- **空间复杂度**：`O(1)`，除了存储变量外，所需的额外空间是常数级的。

## 代码

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function (dividend, divisor) {
	// 处理特殊情况
	if (divisor == 0) return Infinity; // 除数为 0
	if (dividend == -Math.pow(2, 31) && divisor == -1) return Math.pow(2, 31) - 1; // 溢出情况

	// 判断结果符号
	let isNegative = dividend > 0 !== divisor > 0;
	// 取绝对值，处理负数问题
	dividend = Math.abs(dividend);
	divisor = Math.abs(divisor);

	let res = 0;
	// 倍增法
	while (dividend >= divisor) {
		let temp = divisor,
			multi = 1;
		while (dividend >= 2 * temp) {
			temp *= 2; // 除数翻倍
			multi *= 2; // 倍数也翻倍
		}
		dividend -= temp; // 减去翻倍后的除数
		res += multi; // 商加上相应的倍数
	}

	// 返回结果，处理符号
	return isNegative ? -res : res;
};
```
