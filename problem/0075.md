# [75. 颜色分类](https://leetcode.com/problems/sort-colors)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/sort-colors)

## 题目

<p>给定一个包含红色、白色和蓝色、共&nbsp;<code>n</code><em> </em>个元素的数组<meta charset="UTF-8" />&nbsp;<code>nums</code>&nbsp;，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a>&nbsp;</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>

<p>我们使用整数 <code>0</code>、&nbsp;<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>

<ul>
</ul>

<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,0,2,1,1,0]
<strong>输出：</strong>[0,0,1,1,2,2]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,0,1]
<strong>输出：</strong>[0,1,2]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong></p>

<ul>
	<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>


## 解题思路

可以通过使用 **荷兰国旗算法** 来解决，这个算法是由 Edsger W. Dijkstra 提出的，核心思想是使用**三指针**来对数组进行分类。

1. **定义三个指针**：

   - `low` 指针：用于追踪 0 的位置。
   - `high` 指针：用于追踪 2 的位置。
   - `cur` 指针：用于遍历数组。

2. **处理过程**：

   - 遍历数组，使用 `cur` 指针。
   - 如果 `cur` 指向的元素是：

     - **0**：将其与 `low` 位置的元素交换，然后移动 `low` 和 `cur` 指针。
     - **1**：不做处理，直接移动 `cur` 指针。
     - **2**：将其与 `high` 位置的元素交换，并将 `high` 指针左移（交换后 `cur` 指向的元素仍需要处理，因此不能移动 `cur` 指针）。

   - 完成遍历后，数组中的 0 将位于前面，1 位于中间，2 位于最后。

#### 复杂度分析

- **时间复杂度**：`O(n)`，数组只遍历了一次，每次迭代中执行常数次的交换或指针移动操作。
- **空间复杂度**：`O(1)`，排序是原地进行的，使用了常量额外空间。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function (nums) {
	let cur = 0,
		low = 0,
		high = nums.length - 1;
	while (cur <= high) {
		if (nums[cur] == 0) {
			[nums[cur], nums[low]] = [nums[low], nums[cur]];
			cur++;
			low++;
		} else if (nums[cur] == 1) {
			cur++;
		} else {
			[nums[cur], nums[high]] = [nums[high], nums[cur]];
			high--;
		}
	}
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 148 | [排序链表](https://leetcode.com/problems/sort-list) | [[✓]](/problem/0148.md) |  [`链表`](/tag/linked-list.md) [`双指针`](/tag/two-pointers.md) [`分治`](/tag/divide-and-conquer.md) `2+` | <font color=#ffb800>Medium</font> |
| 280 | [摆动排序](https://leetcode.com/problems/wiggle-sort) |  |  [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`排序`](/tag/sorting.md) | <font color=#ffb800>Medium</font> |
| 324 | [摆动排序 II](https://leetcode.com/problems/wiggle-sort-ii) |  |  [`贪心`](/tag/greedy.md) [`数组`](/tag/array.md) [`分治`](/tag/divide-and-conquer.md) `2+` | <font color=#ffb800>Medium</font> |