# [30. 串联所有单词的子串](https://leetcode.com/problems/substring-with-concatenation-of-all-words)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`滑动窗口`](/tag/sliding-window.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/substring-with-concatenation-of-all-words)

## 题目

<p>给定一个字符串&nbsp;<code>s</code><strong>&nbsp;</strong>和一个字符串数组&nbsp;<code>words</code><strong>。</strong>&nbsp;<code>words</code>&nbsp;中所有字符串 <strong>长度相同</strong>。</p>

<p>&nbsp;<code>s</code><strong>&nbsp;</strong>中的 <strong>串联子串</strong> 是指一个包含&nbsp;&nbsp;<code>words</code>&nbsp;中所有字符串以任意顺序排列连接起来的子串。</p>

<ul>
	<li>例如，如果&nbsp;<code>words = ["ab","cd","ef"]</code>， 那么&nbsp;<code>"abcdef"</code>，&nbsp;<code>"abefcd"</code>，<code>"cdabef"</code>，&nbsp;<code>"cdefab"</code>，<code>"efabcd"</code>， 和&nbsp;<code>"efcdab"</code> 都是串联子串。&nbsp;<code>"acdbef"</code> 不是串联子串，因为他不是任何&nbsp;<code>words</code>&nbsp;排列的连接。</li>
</ul>

<p>返回所有串联子串在&nbsp;<code>s</code><strong>&nbsp;</strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "barfoothefoobarman", words = ["foo","bar"]
<strong>输出：</strong><code>[0,9]</code>
<strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
<code><strong>输出：</strong>[]</code>
<strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
<strong>输出：</strong>[6,9,12]
<strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words.length &lt;= 5000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
	<li><code>words[i]</code>&nbsp;和&nbsp;<code>s</code> 由小写英文字母组成</li>
</ul>


## 解题思路

此题是 [第 438 题 找到字符串中所有字母异位词](./0438.md) 的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词，可以用类似的滑动窗口方法来解此题。

1. 使用双指针中的左右指针，初始化 `left = right = 0`，把索引左闭右开区间 `[left, right)` 称为一个「窗口」；
2. 不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `words.length * words[0].length` 个字符）；
3. 停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求；
4. 每次窗口中的字符串长度符合要求时，都要通过`isConcatenatedString`函数，判断窗口中的字符串是否符合题目要求，并更新一轮结果；
5. 重复第 2 和第 3 步，直到 `right` 到达字符串 `s2` 的尽头；

#### 复杂度分析

- **时间复杂度**：`O(l×n)`，其中 `l` 是输入 `s` 的长度，`n` 是 `words` 中每个单词的长度。需要做 `n` 次滑动窗口，每次需要遍历一次 `s`。
- **空间复杂度**：`O(m×n)`，其中 `m` 是 `words` 的单词数，`n` 是 `words` 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次。

## 代码

```javascript
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function (s, words) {
	let window = '',
		need = {};
	for (let i of words) {
		need[i] = (need[i] || 0) + 1;
	}

	const len = words.length * words[0].length;

	let left = 0,
		right = 0,
		// 记录结果
		res = [];

	while (right < s.length) {
		// 进行窗口内数据的一系列更新
		window += s[right];
		right++;

		// 判断左侧窗口是否要收缩
		while (window.length > len) {
			left++;
			// 进行窗口内数据的一系列更新
			window = window.substring(1, window.length);
		}

		// 当窗口符合条件时，把起始索引加入 res
		if (isConcatenatedString(window, words, need)) {
			res.push(left);
		}
	}
	return res;
};

// 判断 str 是否为 words 的串联子串
var isConcatenatedString = function (str, words, need) {
	let obj = {},
		valid = 0;

	const n = words[0].length,
		m = words.length;
	if (str.length !== m * n) return false;

	for (let i = 0; i < m; i++) {
		let word = str.slice(i * n, (i + 1) * n);
		if (need[word]) {
			obj[word] = (obj[word] || 0) + 1;
			if (obj[word] == need[word]) {
				valid += 1;
			}
		}
	}

	return valid == Object.keys(need).length;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 76 | [最小覆盖子串](https://leetcode.com/problems/minimum-window-substring) | [[✓]](/problem/0076.md) |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`滑动窗口`](/tag/sliding-window.md) | <font color=#ff334b>Hard</font> |