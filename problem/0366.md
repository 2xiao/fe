# [366. 寻找二叉树的叶子节点](https://leetcode.com/problems/find-leaves-of-binary-tree)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/find-leaves-of-binary-tree)

## 题目

<p>给你一棵二叉树的 <code>root</code> 节点，请按照以下方式收集树的节点：</p>

<ul>
	<li>收集所有的叶子节点。</li>
	<li>移除所有的叶子节点。</li>
	<li>重复以上步骤，直到树为空。</li>
</ul>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0366.Find%20Leaves%20of%20Binary%20Tree/images/remleaves-tree.jpg" style="width: 500px; height: 215px;" />
<pre>
<strong>输入：</strong>root = [1,2,3,4,5]
<strong>输出：</strong>[[4,5,3],[2],[1]]
<strong>解释：</strong>
[[3,5,4],[2],[1]] 和 [[3,4,5],[2],[1]] 也被视作正确答案，因为每一层返回元素的顺序不影响结果。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点的数量在<code>[1, 100]</code>范围内。</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

## 解题思路

二叉树节点的高度的定义是：节点到叶子节点的最长路径（边数），可以发现返回数组其实是按照二叉树的高度来分组的，只需求出每个节点左右子树的最大深度 - 1，即是该节点的高度。

## 代码

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var findLeaves = function (root) {
	if (!root) return [];
	let res = [];
	const maxDepth = (root) => {
		if (!root) return 0;
		let depth = Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
		res[depth - 1].push(root.val);
		return depth;
	};
	maxDepth(root);
	return res;
};
```
