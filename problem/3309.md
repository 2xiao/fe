# [3309. 连接二进制表示可形成的最大数值](https://leetcode.com/problems/maximum-possible-number-by-binary-concatenation)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`位运算`](/tag/bit-manipulation.md) [`数组`](/tag/array.md) [`枚举`](/tag/enumeration.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/maximum-possible-number-by-binary-concatenation)

## 题目

<p>给你一个长度为 <code>3</code> 的整数数组 <code>nums</code>。</p>

<p>现以某种顺序<strong> 连接 </strong>数组 <code>nums</code> 中所有元素的 <strong>二进制表示</strong> ，请你返回可以由这种方法形成的 <strong>最大 </strong>数值。</p>

<p><strong>注意</strong> 任何数字的二进制表示<em> </em><strong>不含</strong><em> </em>前导零。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1:</strong></p>

<div class="example-block">
<p><strong>输入:</strong> <span class="example-io">nums = [1,2,3]</span></p>

<p><strong>输出:</strong> 30</p>

<p><strong>解释:</strong></p>

<p>按照顺序 <code>[3, 1, 2]</code> 连接数字的二进制表示，得到结果 <code>"11110"</code>，这是 30 的二进制表示。</p>
</div>

<p><strong class="example">示例 2:</strong></p>

<div class="example-block">
<p><strong>输入:</strong> <span class="example-io">nums = [2,8,16]</span></p>

<p><strong>输出:</strong> 1296</p>

<p><strong>解释:</strong></p>

<p>按照顺序 <code>[2, 8, 16]</code> 连接数字的二进制表述，得到结果 <code>"10100010000"</code>，这是 1296 的二进制表示。</p>
</div>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>nums.length == 3</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 127</code></li>
</ul>


## 解题思路

本题的关键在于如何比较两个数 `a` 和 `b` 的拼接顺序。我们需要比较 `a+b` 和 `b+a`，判断哪种拼接方式会生成更大的数。通过这样的比较来决定排序的优先级。

1. 将每个整数转换为二进制字符串。
2. 使用自定义的排序函数来比较两两拼接的结果，按从大到小的顺序排序。
3. 排序完成后，将这些二进制字符串拼接在一起。

#### 复杂度分析

- **时间复杂度**：`O(m * n log n)`，其中 `n` 是数组的长度，`m` 是二进制字符串的平均长度，排序的时间复杂度为 `O(n log n)`，由于每次比较涉及字符串操作，故总体时间复杂度为 `O(m * n log n)`
- **空间复杂度**：`O(n)`，额外空间主要用于存储二进制字符串。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxGoodNumber = function (nums) {
	let binaryArr = nums.map((num) => num.toString(2));
	binaryArr.sort((a, b) => b + a - (a + b));
	return parseInt(binaryArr.join(''), 2);
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1680 | [连接连续二进制数字](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers) |  |  [`位运算`](/tag/bit-manipulation.md) [`数学`](/tag/math.md) [`模拟`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |