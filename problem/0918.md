# [918. 环形子数组的最大和](https://leetcode.com/problems/maximum-sum-circular-subarray)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`队列`](/tag/queue.md) [`数组`](/tag/array.md) [`分治`](/tag/divide-and-conquer.md) [`动态规划`](/tag/dynamic-programming.md) [`单调队列`](/tag/monotonic-queue.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/maximum-sum-circular-subarray)

## 题目

<p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong>&nbsp;<code>nums</code>&nbsp;，返回<em>&nbsp;<code>nums</code>&nbsp;的非空 <strong>子数组</strong> 的最大可能和&nbsp;</em>。</p>

<p><strong>环形数组</strong><em>&nbsp;</em>意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code>&nbsp;的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p>

<p><strong>子数组</strong> 最多只能包含固定缓冲区&nbsp;<code>nums</code>&nbsp;中的每个元素一次。形式上，对于子数组&nbsp;<code>nums[i], nums[i + 1], ..., nums[j]</code>&nbsp;，不存在&nbsp;<code>i &lt;= k1, k2 &lt;= j</code>&nbsp;其中&nbsp;<code>k1 % n == k2 % n</code>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,-2,3,-2]
<strong>输出：</strong>3
<strong>解释：</strong>从子数组 [3] 得到最大和 3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [5,-3,5]
<strong>输出：</strong>10
<strong>解释：</strong>从子数组 [5,5] 得到最大和 5 + 5 = 10
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,-2,2,-3]
<strong>输出：</strong>3
<strong>解释：</strong>从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-3 * 10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code>​​​​​​​</li>
</ul>


## 解题思路

要解决这个问题，可以考虑两种情况：

- **普通子数组**：可以直接使用经典的 **Kadane’s Algorithm** 来找到非循环的最大子数组和。
- **跨越首尾的子数组**：这个子数组可以被理解为，总和减去一个最小的子数组和（即，找到整个数组的和，再减去中间的一个子数组，保留数组两端部分作为最大子数组和）。要实现这一点，需要求出最小子数组和。

因此，解题分为三步：

1. **计算非循环子数组的最大和**：使用 Kadane's 算法来找到子数组的最大和 `maxSum`.
2. **计算最小子数组和**：使用 Kadane's 算法的变种，找出子数组的最小和 `minSum`，然后用整个数组的和 `totalSum` 减去该最小和。这样得到跨越首尾的子数组和 `totalSum - minSum`。
3. **考虑特殊情况**：当所有元素都是负数时，跨越首尾的子数组和可能会无效，因为整个数组的和 `totalSum` 会等于 `minSum`。在这种情况下，返回 `maxSum` 即可。

#### 复杂度分析

- **时间复杂度**：`O(n)`，因为只遍历数组三次（分别求最大子数组和、最小子数组和，以及总和），每次遍历需要 `O(n)` 时间。
- **空间复杂度**：`O(1)`，因为只使用了常数空间来存储若干变量，不需要额外的数组或其他数据结构。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubarraySumCircular = function (nums) {
	const totalSum = nums.reduce((a, b) => a + b, 0);

	const getMaxSum = () => {
		let max = nums[0],
			maxEndingHere = nums[0];
		for (let i = 1; i < nums.length; i++) {
			maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
			max = Math.max(maxEndingHere, max);
		}
		return max;
	};

	const getMinSum = () => {
		let min = nums[0],
			minEndingHere = nums[0];
		for (let i = 1; i < nums.length; i++) {
			minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);
			min = Math.min(minEndingHere, min);
		}
		return min;
	};

	const maxSum = getMaxSum();
	const minSum = getMinSum();

	if (maxSum < 0) return maxSum;
	return Math.max(maxSum, totalSum - minSum);
};
```
