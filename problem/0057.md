# [57. 插入区间](https://leetcode.com/problems/insert-interval)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/insert-interval)

## 题目

<p>给你一个<strong> 无重叠的</strong><em> ，</em>按照区间起始端点排序的区间列表 <code>intervals</code>，其中&nbsp;<code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个区间的开始和结束，并且&nbsp;<code>intervals</code>&nbsp;按照&nbsp;<code>start<sub>i</sub></code>&nbsp;升序排列。同样给定一个区间&nbsp;<code>newInterval = [start, end]</code>&nbsp;表示另一个区间的开始和结束。</p>

<p>在&nbsp;<code>intervals</code> 中插入区间&nbsp;<code>newInterval</code>，使得&nbsp;<code>intervals</code>&nbsp;依然按照&nbsp;<code>start<sub>i</sub></code>&nbsp;升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p>

<p>返回插入之后的&nbsp;<code>intervals</code>。</p>

<p><strong>注意</strong> 你不需要原地修改&nbsp;<code>intervals</code>。你可以创建一个新数组然后返回它。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>输出：</strong>[[1,5],[6,9]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
<strong>输出：</strong>[[1,2],[3,10],[12,16]]
<strong>解释：</strong>这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code>&nbsp;重叠。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>0 &lt;=&nbsp;start<sub>i</sub> &lt;=&nbsp;end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals</code> 根据 <code>start<sub>i</sub></code> 按 <strong>升序</strong> 排列</li>
	<li><code>newInterval.length == 2</code></li>
	<li><code>0 &lt;=&nbsp;start &lt;=&nbsp;end &lt;= 10<sup>5</sup></code></li>
</ul>


## 解题思路

1. 遍历区间数组，取出当前区间 `[b1, b2]` ，依次与插入区间 `[a1, a2]` 对比，可能有如下三种情况：

![](../image/57.png)

- 情况一，两区间不相交且 `a1 > b2`，直接将当前区间 `[b1, b2]` 放入返回数组，继续对比后续区间；
- 情况二，两区间不相交且 `a2 < b1`，说明已经找到了插入区间 `[a1, a2]` 的位置，将插入区间和后续没有对比过的区间都放入返回数组，并跳出循环；
- 情况三，两个区间相交，此时需要将两个区间合并，将合并后的区间作为新的插入区间与后续区间对比。合并后的区间分为四种情况，根据上图可以发现规律，只需更新 `a1` 和 `a2` 为：
  - `a1 = min(a1, b1)`
  - `a2 = max(a2, b2)`

2. 注意边界情况

- 1. 若区间数组为空（例如：`intervals = [], newInterval = [1,2]`），则直接返回 `newInterval`；
- 2. 当循环遍历到区间数组的最后一个时（例如：`intervals = [[2,3]], newInterval = [1,4]`），由于后面不会再出现情况 2 了，所以最后要将合并后的区间放入返回数组中。

## 代码

```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function (intervals, newInterval) {
	// 边界情况一
	if (intervals.length == 0) return [newInterval];
	let res = [],
		a1 = newInterval[0],
		a2 = newInterval[1];
	for (let i = 0; i < intervals.length; i++) {
		let b1 = intervals[i][0],
			b2 = intervals[i][1];
		// 情况一
		if (a1 > b2) {
			res.push(intervals[i]);
		}
		// 情况二
		else if (a2 < b1) {
			res.push([a1, a2]);
			res.push(...intervals.slice(i, intervals.length));
			break;
		}
		// 情况三
		else {
			a1 = Math.min(a1, b1);
			a2 = Math.max(a2, b2);
		}
		// 边界情况二
		if (i == intervals.length - 1) {
			res.push([a1, a2]);
		}
	}
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 56 | [合并区间](https://leetcode.com/problems/merge-intervals) | [[✓]](/problem/0056.md) |  [`数组`](/tag/array.md) [`排序`](/tag/sorting.md) | <font color=#ffb800>Medium</font> |
| 715 | [Range 模块](https://leetcode.com/problems/range-module) |  |  [`设计`](/tag/design.md) [`线段树`](/tag/segment-tree.md) [`有序集合`](/tag/ordered-set.md) | <font color=#ff334b>Hard</font> |
| 2276 | [统计区间中的整数数目](https://leetcode.com/problems/count-integers-in-intervals) |  |  [`设计`](/tag/design.md) [`线段树`](/tag/segment-tree.md) [`有序集合`](/tag/ordered-set.md) | <font color=#ff334b>Hard</font> |