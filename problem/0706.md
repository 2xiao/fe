# [706. 设计哈希映射](https://leetcode.com/problems/design-hashmap)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) [`哈希函数`](/tag/hash-function.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/design-hashmap)

## 题目

<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>

<p>实现 <code>MyHashMap</code> 类：</p>

<ul>
	<li><code>MyHashMap()</code> 用空映射初始化对象</li>
	<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>
	<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>
	<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入</strong>：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>输出</strong>：
[null, null, null, 1, -1, null, 1, null, -1]

<strong>解释</strong>：
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>
	<li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>
</ul>


## 解题思路

本题与 [第 705 题](./0705.md) 解法接近，唯一的区别在于存储的不是 `key` 本身，而是 `(key,value)` 对，其他代码都一样。

链地址法：

- 设哈希表的大小为 `base`，则可以设计一个简单的哈希函数：`hash(x) = x mod base`；
- 开辟一个大小为 `base` 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中；
- 由于使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 `base` 取为一个质数，如 `base = 769`；

![](../image/705.png)

#### 复杂度分析

- **时间复杂度**：`O(n / b)`。其中 `n` 为哈希表中的元素数量，`b` 为链表的数量，假设哈希值是均匀分布的，则每个链表大概长度为 `n / b`；
- **空间复杂度**：`O(n+b)`。

## 代码

```javascript
class MyHashMap {
	constructor() {
		this.base = 769;
		this.data = new Array(this.base).fill(0).map(() => new Array());
	}

	// @param {number} key
	// @return {number}
	hash(key) {
		return key % this.base;
	}

	// @param {number} key
	// @param {number} value
	// @return {void}
	put(key, value) {
		const h = this.hash(key);
		for (let item of this.data[h]) {
			if (item[0] === key) {
				item[1] = value;
				return;
			}
		}
		this.data[h].push([key, value]);
	}

	// @param {number} key
	// @return {number}
	get(key) {
		const h = this.hash(key);
		for (let item of this.data[h]) {
			if (item[0] === key) return item[1];
		}
		return -1;
	}

	// @param {number} key
	// @return {void}
	remove(key) {
		const h = this.hash(key);
		const hList = this.data[h];
		for (let i = 0; i < hList.length; i++) {
			if (hList[i][0] === key) {
				hList.splice(i, 1);
				return;
			}
		}
	}
}
/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 705 | [设计哈希集合](https://leetcode.com/problems/design-hashset) | [[✓]](/problem/0705.md) |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) `2+` | <font color=#15bd66>Easy</font> |
| 1206 | [设计跳表](https://leetcode.com/problems/design-skiplist) |  |  [`设计`](/tag/design.md) [`链表`](/tag/linked-list.md) | <font color=#ff334b>Hard</font> |