# [951. 翻转等价二叉树](https://leetcode.com/problems/flip-equivalent-binary-trees)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/flip-equivalent-binary-trees)

## 题目

<p>我们可以为二叉树 <strong>T</strong> 定义一个&nbsp;<strong>翻转操作&nbsp;</strong>，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>

<p>只要经过一定次数的翻转操作后，能使 <strong>X</strong> 等于 <strong>Y</strong>，我们就称二叉树 <strong>X</strong> <em>翻转 等价&nbsp;</em>于二叉树 <strong>Y</strong>。</p>

<p>这些树由根节点&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;给出。如果两个二叉树是否是<em>翻转 等价&nbsp;</em>的函数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="Flipped Trees Diagram" src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" /></p>

<pre>
<strong>输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
<strong>输出：</strong>true
<strong>解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入:</strong> root1 = [], root2 = []
<strong>输出:</strong> true
</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> root1 = [], root2 = [1]
<strong>输出:</strong> false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>每棵树节点数在&nbsp;<code>[0, 100]</code> 范围内</li>
	<li>每棵树中的每个值都是唯一的、在 <code>[0, 99]</code>&nbsp;范围内的整数</li>
</ul>


## 解题思路

翻转等价的定义意味着可以通过一系列的翻转操作，使得两个二叉树结构相同，可以使用递归的方法来解决这个问题。

1. **递归比较**：递归比较两个节点的值和结构:

   - 如果两个节点都为 `null`，返回 `true`，表示两个树在这一位置相同；
   - 如果只有一个节点为 `null`，返回 `false`，表示树结构不同；
   - 如果两个节点的值不相等，直接返回 `false`；
   - 如果两个节点的值相等，则递归检查左右子树；

2. **递归检查子树**：

   - 对于当前节点的左右子树，可以有两种比较方式：
     - **不翻转**：直接比较左子树与左子树，右子树与右子树。
     - **翻转**：比较左子树与右子树，右子树与左子树。
   - 如果两种方式中任意一种成立，则返回 `true`。

#### 复杂度分析

- **时间复杂度**：`O(n)`，在最坏情况下，需要访问每个节点一次。
- **空间复杂度**：`O(h)`，其中 `h` 是树的高度。使用了递归，递归调用栈的深度与树的高度有关：
  - 在平衡的情况下，空间复杂度是 `O(log n)`；
  - 而在极度不平衡的情况下（如链表），空间复杂度为 `O(n)`。

## 代码

```javascript
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var flipEquiv = function (root1, root2) {
	if (!root1 && !root2) return true; // 都是 null
	if (!root1 || !root2) return false; // 其中一个是 null
	if (root1.val !== root2.val) return false; // 检查当前节点的值是否相等

	// 检查左右子树是否相等（翻转 or 不翻转）
	return (
		(flipEquiv(root1.left, root2.left) &&
			flipEquiv(root1.right, root2.right)) ||
		(flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left))
	);
};
```
