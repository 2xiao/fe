# [33. 搜索旋转排序数组](https://leetcode.com/problems/search-in-rotated-sorted-array)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/search-in-rotated-sorted-array)

## 题目

<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>

<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code> 。</p>

<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回&nbsp;<code>-1</code>&nbsp;。</p>

<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0
<strong>输出：</strong>4
</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3
<strong>输出：</strong>-1</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1], target = 0
<strong>输出：</strong>-1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
	<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>


## 解题思路

由于数组是部分有序的，可以利用 **二分查找** 的思想来解决这个问题。与普通的二分查找不同，这里数组被旋转过，所以需要通过额外的判断来确定二分查找的方向。

1. 首先，数组依然可以通过中间值 `mid` 将左右部分分为有序和无序两部分。
2. 每次找到中间位置 `mid`，先检查 `nums[mid]` 是否等于目标值。如果相等，直接返回索引。
3. 通过 `nums[left]` 和 `nums[mid]` 的大小关系来判断哪一部分是有序的。

   - 通过比较 `nums[left]` 和 `nums[mid]` 可以判断左半部分是否有序。
   - 如果 `nums[left] <= nums[mid]`，说明左半部分是有序的，否则右半部分有序。

4. 判断目标值的位置：

   - 如果左半部分有序，且目标值落在 `nums[left]` 到 `nums[mid]` 之间，那么缩小搜索范围至左半部分，否则去右半部分继续查找。
   - 如果右半部分有序，且目标值落在 `nums[mid]` 到 `nums[right]` 之间，那么缩小搜索范围至右半部分，否则去左半部分继续查找。

5. 不断缩小查找区间，直到找到目标值，或者使得 `left > right`时返回 `-1`。

#### 复杂度分析

- **时间复杂度**：`O(log n)`，这是二分查找的时间复杂度，每次查找时将搜索范围缩小一半。
- **空间复杂度**：`O(1)`，只用了常量级的额外空间。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
	let left = 0;
	let right = nums.length - 1;

	while (left <= right) {
		let mid = Math.floor((left + right) / 2);

		// 找到目标值
		if (nums[mid] === target) {
			return mid;
		}

		// 判断左半部分是否有序
		if (nums[left] <= nums[mid]) {
			// 如果 target 在左半部分的范围内
			if (nums[left] <= target && target < nums[mid]) {
				right = mid - 1; // 缩小到左半部分
			} else {
				left = mid + 1; // 否则缩小到右半部分
			}
		}
		// 否则右半部分有序
		else {
			// 如果 target 在右半部分的范围内
			if (nums[mid] < target && target <= nums[right]) {
				left = mid + 1; // 缩小到右半部分
			} else {
				right = mid - 1; // 否则缩小到左半部分
			}
		}
	}

	// 没有找到目标值
	return -1;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 81 | [搜索旋转排序数组 II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii) | [[✓]](/problem/0081.md) |  [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) | <font color=#ffb800>Medium</font> |
| 153 | [寻找旋转排序数组中的最小值](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array) | [[✓]](/problem/0153.md) |  [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) | <font color=#ffb800>Medium</font> |
| 2137 | [通过倒水操作让所有的水桶所含水量相等](https://leetcode.com/problems/pour-water-between-buckets-to-make-water-levels-equal) |  |  [`数组`](/tag/array.md) [`二分查找`](/tag/binary-search.md) | <font color=#ffb800>Medium</font> |