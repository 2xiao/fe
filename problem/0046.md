# [46. 全排列](https://leetcode.com/problems/permutations)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/permutations)

## 题目

<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,1]
<strong>输出：</strong>[[0,1],[1,0]]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1]
<strong>输出：</strong>[[1]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 6</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>


## 解题思路

这是一个经典的回溯问题，可以通过深度优先搜索（DFS）来解决。

1. 使用一个数组 `used` 来标记数字是否已经被使用过，确保每个数字在排列中只使用一次，初始时都为 `false`。
2. 定义一个 `backtrack` 函数，用于搜索所有可能的排列。在函数中进行如下操作：
   - 如果当前排列的长度等于输入序列的长度，说明已经得到一个完整的排列，将其添加到结果数组中。
   - 否则，遍历输入序列的每个数字，如果当前数字没有被使用过，就将其加入当前排列中，并标记为已使用。
   - 然后递归调用 `backtrack` 函数，继续搜索下一个位置的数字。
   - 在递归完成后，需要回溯，即将当前数字从排列中移除，并标记为未使用，使其可以在其他位置被使用。
3. 最后返回结果数组。

#### 复杂度分析

- **时间复杂度**：`O(n * n!)`，其中 `n` 是 `nums` 的长度。主要由递归调用栈的深度决定，递归深度（即排列的数量 `n!`）乘以每次操作的时间复杂度 `O(n)`，总时间复杂度为 `O(n * n!)`。
- **空间复杂度**：`O(n)`（不包含结果数组使用的空间）递归调用栈的深度为 `n`，`used` 数组的大小为 `n`。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
	const n = nums.length;
	let res = [];
	let used = new Array(n).fill(false);

	const backtrack = (track) => {
		if (track.length == n) {
			res.push([...track]);
			return;
		}

		for (let i = 0; i < n; i++) {
			if (used[i]) {
				continue;
			}

			// 做选择
			track.push(nums[i]);
			used[i] = true;

			// 递归
			backtrack(track);

			// 撤销选择，回溯
			track.pop();
			used[i] = false;
		}
	};

	backtrack([]);
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 31 | [下一个排列](https://leetcode.com/problems/next-permutation) | [[✓]](/problem/0031.md) |  [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) | <font color=#ffb800>Medium</font> |
| 47 | [全排列 II](https://leetcode.com/problems/permutations-ii) | [[✓]](/problem/0047.md) |  [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |
| 60 | [排列序列](https://leetcode.com/problems/permutation-sequence) |  |  [`递归`](/tag/recursion.md) [`数学`](/tag/math.md) | <font color=#ff334b>Hard</font> |
| 77 | [组合](https://leetcode.com/problems/combinations) | [[✓]](/problem/0077.md) |  [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |