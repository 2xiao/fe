# [2626. 数组归约运算](https://leetcode.com/problems/array-reduce-transformation)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/array-reduce-transformation)

## 题目

<p>给定一个整数数组 <code>nums</code>、一个 reducer 函数 <code>fn</code> 和一个初始值 <code>init</code>，返回通过依次对数组的每个元素执行 <code>fn</code> 函数得到的最终结果。</p>

<p>通过以下操作实现这个结果：<code>val = fn(init, nums[0])，val = fn(val, nums[1])，val = fn(val, nums[2])，...</code> 直到处理数组中的每个元素。然后返回 <code>val</code> 的最终值。</p>

<p>如果数组的长度为 0，则函数应返回 <code>init</code>。</p>

<p>请你在不使用内置数组方法的&nbsp;<code>Array.reduce</code>&nbsp;前提下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>
nums = [1,2,3,4]
fn = function sum(accum, curr) { return accum + curr; }
init = 0
<strong>输出：</strong>10
<strong>解释：</strong>
初始值为 init=0 。
(0) + nums[0] = 1
(1) + nums[1] = 3
(3) + nums[2] = 6
(6) + nums[3] = 10
Val 最终值为 10。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong> 
nums = [1,2,3,4]
fn = function sum(accum, curr) { return accum + curr * curr; }
init = 100
<strong>输出：</strong>130
<strong>解释：</strong>
初始值为 init=100 。
(100) + nums[0]^2 = 101
(101) + nums[1]^2 = 105
(105) + nums[2]^2 = 114
(114) + nums[3]^2 = 130
Val 最终值为 130。
</pre>

<p><strong class="example">示例3:</strong></p>

<pre>
<strong>输入：</strong> 
nums = []
fn = function sum(accum, curr) { return 0; }
init = 25
<strong>输出：</strong>25
<b>解释：</b>这是一个空数组，所以返回 init 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= init &lt;= 1000</code></li>
</ul>


## 解题思路

这道题主要考察如何实现 `reduce` 函数，模拟 JavaScript 内置的 `Array.prototype.reduce` 方法，逐一处理数组中的元素并将其与当前聚合值结合，最终返回聚合的结果，其关键在于遍历数组并不断更新聚合值，操作非常常见，尤其在处理数据时常用于累加、最大最小值计算等场景。

1. **初始化结果**：将 `init` 作为初始的聚合值 `res`。
2. **遍历数组**：从数组的第一个元素开始，依次将当前聚合值 `res` 和数组元素 `nums[i]` 传入回调函数 `fn`，并将 `fn` 返回的结果作为新的聚合值。
3. **返回结果**：遍历结束后，返回聚合后的最终值。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组 `nums` 的长度，需要遍历整个数组，每个元素执行一次 `fn` 操作。
- **空间复杂度**：`O(1)`，因为只需要常量空间来存储聚合结果和计数器。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function (nums, fn, init) {
	let res = init;
	for (let i = 0; i < nums.length; i++) {
		res = fn(res, nums[i]);
	}
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2631 | [分组](https://leetcode.com/problems/group-by) | [[✓]](/problem/2631.md) |  | <font color=#ffb800>Medium</font> |
| 2634 | [过滤数组中的元素](https://leetcode.com/problems/filter-elements-from-array) | [[✓]](/problem/2634.md) |  | <font color=#15bd66>Easy</font> |
| 2635 | [转换数组中的每个元素](https://leetcode.com/problems/apply-transform-over-each-element-in-array) | [[✓]](/problem/2635.md) |  | <font color=#15bd66>Easy</font> |