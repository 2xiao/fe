# [38. 外观数列](https://leetcode.com/problems/count-and-say)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/count-and-say)

## 题目

<p>「外观数列」是一个数位字符串序列，由递归公式定义：</p>

<ul>
	<li><code>countAndSay(1) = "1"</code></li>
	<li><code>countAndSay(n)</code> 是&nbsp;<code>countAndSay(n-1)</code> 的行程长度编码。</li>
</ul>

<p>&nbsp;</p>

<ul>
</ul>

<p><a href="https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940">行程长度编码</a>（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串&nbsp;<code>"3322251"</code>&nbsp;，我们将&nbsp;<code>"33"</code>&nbsp;用&nbsp;<code>"23"</code>&nbsp;替换，将&nbsp;<code>"222"</code>&nbsp;用&nbsp;<code>"32"</code>&nbsp;替换，将&nbsp;<code>"5"</code>&nbsp;用&nbsp;<code>"15"</code>&nbsp;替换并将&nbsp;<code>"1"</code>&nbsp;用&nbsp;<code>"11"</code>&nbsp;替换。因此压缩后字符串变为 <code>"23321511"</code>。</p>

<p>给定一个整数&nbsp;<code>n</code>&nbsp;，返回&nbsp;<strong>外观数列</strong>&nbsp;的第&nbsp;<code>n</code>&nbsp;个元素。</p>

<p><strong>示例 1：</strong></p>

<div class="example-block">
<p><strong>输入：</strong>n = 4</p>

<p><strong>输出：</strong>"1211"</p>

<p><strong>解释：</strong></p>

<p>countAndSay(1) = "1"</p>

<p>countAndSay(2) = "1" 的行程长度编码 = "11"</p>

<p>countAndSay(3) = "11" 的行程长度编码 = "21"</p>

<p>countAndSay(4) = "21" 的行程长度编码 = "1211"</p>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><strong>输入：</strong><span class="example-io">n = 1</span></p>

<p><strong>输出：</strong><span class="example-io">"1"</span></p>

<p><strong>解释：</strong></p>

<p>这是基本情况。</p>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 30</code></li>
</ul>

<p>&nbsp;</p>
<strong>进阶：</strong>你能迭代解决该问题吗？

## 解题思路

这个题的核心思路是模拟生成报数序列。我们需要从第 1 项开始，逐步生成后面的每一项，直到生成第 `n` 项为止。

1. 初始化：第 1 项是固定的，直接设置为 `"1"`。
2. 迭代生成：从第 2 项开始，每次根据前一项生成新的一项。我们通过遍历前一项的字符，统计连续相同字符的个数，然后将其转化为描述性的字符串。
3. 遍历字符串：对于每一项的生成，我们遍历当前项的字符串，对于每一组连续相同的数字，记录下它们的数量和数字本身，形成新的项。
4. 循环直到 `n`：我们从第 1 项逐步生成到第 `n` 项。

#### 复杂度分析

- **时间复杂度**：`O(m * n)`，其中 `n` 是给定的项数，`m` 是报数序列中最长的字符串的长度。对于每一项，我们需要遍历前一项的字符串生成新的一项，字符串的长度随着 `n` 逐渐增长。
- **空间复杂度**：`O(m)`，`m` 是最长的字符串长度，因为我们只需要存储当前项和下一项的字符串。

## 代码

```javascript
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function (n) {
	// 初始项是 "1"
	let res = '1';

	// 迭代生成从第2项到第n项
	for (let i = 2; i <= n; i++) {
		let temp = '', // 存储当前生成的项
			count = 1; // 计数相同字符的数量

		// 遍历上一个结果的字符
		for (let j = 1; j < res.length; j++) {
			if (res[j] == res[j - 1]) {
				// 如果当前字符与前一个相同，计数增加
				count++;
			} else {
				// 否则，将前面的数字和计数添加到结果字符串中
				temp += count + res[j - 1];
				count = 1; // 重置计数
			}
		}

		// 处理最后一个数字
		temp += count + res[res.length - 1];

		// 更新当前项
		res = temp;
	}

	// 返回第n项
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 271 | [字符串的编码与解码](https://leetcode.com/problems/encode-and-decode-strings) |  |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`字符串`](/tag/string.md) | <font color=#ffb800>Medium</font> |
| 443 | [压缩字符串](https://leetcode.com/problems/string-compression) | [[✓]](/problem/0443.md) |  [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) | <font color=#ffb800>Medium</font> |