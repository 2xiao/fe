# [190. 颠倒二进制位](https://leetcode.com/problems/reverse-bits)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`位运算`](/tag/bit-manipulation.md) [`分治`](/tag/divide-and-conquer.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/reverse-bits)

## 题目

<p>颠倒给定的 32 位无符号整数的二进制位。</p>

<p><strong>提示：</strong></p>

<ul>
	<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
	<li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong>&nbsp;中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 00000010100101000001111010011100
<strong>输出：</strong>964176192 (00111001011110000010100101000000)
<strong>解释：</strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，
    </strong> 因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 11111111111111111111111111111101
<strong>输出：</strong>3221225471 (10111111111111111111111111111111)
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，
   &nbsp; 因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>输入是一个长度为 <code>32</code> 的二进制字符串</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶</strong>: 如果多次调用这个函数，你将如何优化你的算法？</p>


## 解题思路

1. **`result` 初始化为 0**：用于存储反转后的结果。
2. **循环 32 次**：每次提取最低位并将其添加到 `result` 中。
3. **`result << 1`**：将结果左移一位，为下一位的填充腾出空间。
4. **`n & 1`**：获取当前 `n` 的最低位。
5. **`n >>= 1`**：将 `n` 右移一位，准备提取下一个位。
6. **`result >>> 0`**：确保返回值是一个无符号整数（在 JavaScript 中用 `>>>` 表示无符号右移）。

#### 复杂度分析

- **时间复杂度**：`O(1)`，因为处理的位数固定为 32 位。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

## 代码

```javascript
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function (n) {
	let result = 0;
	for (let i = 0; i < 32; i++) {
		// 取 n 的最低位
		result = (result << 1) | (n & 1);
		// 右移 n
		n >>= 1;
	}
	return result >>> 0; // 确保返回无符号整数
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 7 | [整数反转](https://leetcode.com/problems/reverse-integer) | [[✓]](/problem/0007.md) |  [`数学`](/tag/math.md) | <font color=#ffb800>Medium</font> |
| 191 | [位1的个数](https://leetcode.com/problems/number-of-1-bits) | [[✓]](/problem/0191.md) |  [`位运算`](/tag/bit-manipulation.md) [`分治`](/tag/divide-and-conquer.md) | <font color=#15bd66>Easy</font> |
| 2119 | [反转两次的数字](https://leetcode.com/problems/a-number-after-a-double-reversal) |  |  [`数学`](/tag/math.md) | <font color=#15bd66>Easy</font> |