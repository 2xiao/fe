# [2623. 记忆函数](https://leetcode.com/problems/memoize)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/memoize)

## 题目

<p>请你编写一个函数 <code>fn</code>，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>

<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>

<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>

<ul>
	<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。假设如果参数 <code>(b, a)</code> 已经缓存了值，其中 <code>a != b</code>，它不能用于参数 <code>(a, b)</code>。例如，如果参数是 <code>(3, 2)</code> 和 <code>(2, 3)</code>，则应进行两个单独的调用。</li>
	<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>
	<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>
fnName = "sum"
actions = ["call","call","getCallCount","call","getCallCount"]
values = [[2,2],[2,2],[],[1,2],[]]
<strong>输出：</strong>[4,4,1,3,2]
<strong>解释：</strong>
const sum = (a, b) =&gt; a + b;
const memoizedSum = memoize(sum);
memoizedSum (2, 2);// "call" - 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。
memoizedSum (2, 2);// "call" - 返回 4。没有调用 sum()，因为前面有相同的输入。
// "getCallCount" - 总调用数： 1
memoizedSum(1, 2);// "call" - 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。
// "getCallCount" - 总调用数： 2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：
</strong>fnName = "factorial"
actions = ["call","call","call","getCallCount","call","getCallCount"]
values = [[2],[3],[2],[],[3],[]]
<strong>输出：</strong>[2,6,2,2,6,2]
<strong>解释：</strong>
const factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));
const memoFactorial = memoize(factorial);
memoFactorial(2); // "call" - 返回 2。
memoFactorial(3); // "call" - 返回 6。
memoFactorial(2); // "call" - 返回 2。 没有调用 factorial()，因为前面有相同的输入。
// "getCallCount" -  总调用数：2
memoFactorial(3); // "call" - 返回 6。 没有调用 factorial()，因为前面有相同的输入。
// "getCallCount" -  总调用数：2
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：
</strong>fnName = "fib"
actions = ["call","getCallCount"]
values = [[5],[]]
<strong>输出：</strong>[8,1]
<strong>解释：
</strong>fib(5) = 8 // "call"
// "getCallCount" -&nbsp;总调用数：1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>actions.length === values.length</code></li>
	<li><code>actions[i]</code> 为&nbsp;"call" 和 "getCallCount" 中的一个</li>
	<li><code>fnName </code>为 "sum", "factorial" 和 "fib" 中的一个</li>
</ul>


## 解题思路

记忆化 (Memoization) 是一种优化技术，用于加速函数的执行，特别是对于有相同输入时可以重用结果的函数。其核心思想是使用一个缓存结构来存储之前的计算结果，以避免对相同的输入进行多次计算。

1. 创建一个哈希表 `cache` 来存储已经计算过的结果，键是输入参数，值是对应的输出结果。
2. 将输入参数通过 JSON 序列化转换为字符串，用作缓存的键 `key = JSON.stringify(args)`。
3. 每次调用函数时，检查该输入参数是否已经存在于缓存中：
   - 如果存在，直接返回缓存中的结果。
   - 如果不存在，计算该输入的结果，并将其存入缓存以供下次使用。

#### 复杂度分析

- **时间复杂度**：`O(1)`，每次调用时都会在缓存中进行查找（`Map` 的查找时间复杂度为 `O(1)`）。如果缓存命中，直接返回；如果没有命中，进行一次计算并存储结果。
- **空间复杂度**：`O(n)`，取决于不同输入的数量。缓存会根据函数的输入参数存储结果，因此空间消耗随调用的不同输入增多。

## 代码

```javascript
/**
 * @param {Function} fn
 * @return {Function}
 */
function memoize(fn) {
	const cache = new Map(); // 创建缓存

	return function (...args) {
		const key = JSON.stringify(args); // 将参数序列化作为键

		if (cache.has(key)) {
			return cache.get(key); // 如果缓存存在结果，直接返回
		}

		const result = fn(...args); // 计算结果
		cache.set(key, result); // 存入缓存
		return result; // 返回计算结果
	};
}

/**
 * let callCount = 0;
 * const memoizedFn = memoize(function (a, b) {
 *	 callCount += 1;
 *   return a + b;
 * })
 * memoizedFn(2, 3) // 5
 * memoizedFn(2, 3) // 5
 * console.log(callCount) // 1
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2620 | [计数器](https://leetcode.com/problems/counter) | [[✓]](/problem/2620.md) |  | <font color=#15bd66>Easy</font> |
| 2629 | [复合函数](https://leetcode.com/problems/function-composition) | [[✓]](/problem/2629.md) |  | <font color=#15bd66>Easy</font> |
| 2630 | [记忆函数 II](https://leetcode.com/problems/memoize-ii) |  |  | <font color=#ff334b>Hard</font> |
| 2632 | [柯里化](https://leetcode.com/problems/curry) |  |  | <font color=#ffb800>Medium</font> |