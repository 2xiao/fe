# [514. 自由之路](https://leetcode.com/problems/freedom-trail)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/freedom-trail)

## 题目

<p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>

<p>给定一个字符串&nbsp;<code>ring</code>&nbsp;，表示刻在外环上的编码；给定另一个字符串&nbsp;<code>key</code>&nbsp;，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>

<p>最初，<strong>ring&nbsp;</strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使&nbsp;<strong>key&nbsp;</strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完&nbsp;<strong><code>key</code>&nbsp;</strong>中的所有字符。</p>

<p>旋转&nbsp;<code>ring</code><strong>&nbsp;</strong>拼出 key 字符&nbsp;<code>key[i]</code><strong>&nbsp;</strong>的阶段中：</p>

<ol>
	<li>您可以将&nbsp;<strong>ring&nbsp;</strong>顺时针或逆时针旋转&nbsp;<strong>一个位置&nbsp;</strong>，计为1步。旋转的最终目的是将字符串&nbsp;<strong><code>ring</code>&nbsp;</strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符&nbsp;<strong><code>key[i]</code> 。</strong></li>
	<li>如果字符&nbsp;<strong><code>key[i]</code>&nbsp;</strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作&nbsp;<strong>1 步</strong>。按完之后，您可以开始拼写&nbsp;<strong>key&nbsp;</strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>
</ol>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2018/10/22/ring.jpg" style="height: 450px; width: 450px;" /></p>

<center>&nbsp;</center>

<pre>
<strong>输入:</strong> ring = "godding", key = "gd"
<strong>输出:</strong> 4
<strong>解释:</strong>
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> ring = "godding", key = "godding"
<strong>输出:</strong> 13
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>
	<li><code>ring</code>&nbsp;和&nbsp;<code>key</code>&nbsp;只包含小写英文字母</li>
	<li><strong>保证</strong> 字符串&nbsp;<code>key</code>&nbsp;一定可以由字符串 &nbsp;<code>ring</code>&nbsp;旋转拼出</li>
</ul>


## 解题思路

1. **构建映射**：首先构建一个映射 `map`，将每个字符在 `ring` 中的出现位置记录下来。

2. **动态规划递归**：使用递归的方式进行动态规划。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示指针在 `ring[i]` 时，到 `key[j]` 最少需要几步操作。

3. **递归函数**：定义递归函数 `helper(i, j)`，表示当指针在 `ring[i]` 位置，需要匹配 `key[j]` 时的最小操作步数。

4. **递归结束条件**：当 `j` 等于 `n` 时，表示已经匹配完整个 `key` 字符串，返回 0。

5. **递归过程**：遍历 `key[j]` 对应的所有可能位置 `k`，计算旋转次数 `rotate`，然后递归调用 `helper(k, j + 1)`，加上当前的旋转次数和 1，取最小值作为结果。

6. **记忆化搜索**：为了避免重复计算，使用数组 `dp` 进行记忆化搜索，记录已经计算过的状态。

- **时间复杂度**: `O(m * n)` - 其中 `m` 是 `ring` 的长度，`n` 是 `key` 的长度。对于 `key` 中的每个字符，都会考虑 `ring` 中的所有可能位置。
- **空间复杂度**: `O(m * n)` - 使用了一个二维数组来存储中间状态。

## 代码

```javascript
/**
 * @param {string} ring
 * @param {string} key
 * @return {number}
 */
var findRotateSteps = function (ring, key) {
	const m = ring.length;
	const n = key.length;
	const map = new Map();

	// 构建映射
	for (let i = 0; i < m; i++) {
		let temp = map.get(ring[i]) || [];
		temp.push(i);
		map.set(ring[i], temp);
	}

	// 初始化动态规划数组
	const dp = new Array(m).fill(0).map(() => new Array(n).fill(-1));

	// 定义递归函数
	const helper = (i, j) => {
		// 递归结束条件
		if (j == n) return 0;
		// 记忆化搜索
		if (dp[i][j] !== -1) return dp[i][j];

		let res = Infinity;
		// 遍历 key[j] 对应的所有可能位置
		for (let k of map.get(key[j])) {
			// 计算旋转表盘次数
			const rotate = Math.min(Math.abs(k - i), m - Math.abs(k - i));
			// 递归调用，加上当前的旋转次数和 1，取最小值
			res = Math.min(res, 1 + rotate + helper(k, j + 1));
		}
		dp[i][j] = res;
		return res;
	};

	// 返回结果
	return helper(0, 0);
};
```
