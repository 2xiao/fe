# [518. 零钱兑换 II](https://leetcode.com/problems/coin-change-ii)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/coin-change-ii)

## 题目

<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>

<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>

<p>假设每一种面额的硬币有无限个。 </p>

<p>题目数据保证结果符合 32 位带符号整数。</p>

<p> </p>

<ul>
</ul>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>amount = 5, coins = [1, 2, 5]
<strong>输出：</strong>4
<strong>解释：</strong>有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>amount = 3, coins = [2]
<strong>输出：</strong>0
<strong>解释：</strong>只用面额 2 的硬币不能凑成总金额 3 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>amount = 10, coins = [10] 
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 300</code></li>
	<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
	<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>
	<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>


## 解题思路

### 思路一：动态规划

- 使用二维数组 `dp`，其中 `dp[i][j]` 表示在前 `i` 种硬币中凑成金额 `j` 的组合数。
- 初始化第一列，表示凑成金额为 0 的组合数都为 1。
- 状态转移方程：`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]`
  - 其中，`coins[i - 1]` 表示第 `i` 种硬币的面值。
- 遍历硬币种类和金额，根据状态转移方程更新 `dp[i][j]` 的值。

  - 对于每一种硬币 `coins[i - 1]`，遍历金额 `j`。
  - 如果 `j - coins[i - 1] >= 0`，则更新 `dp[i][j]` 的值，否则保持 `dp[i][j]` 不变。

#### 复杂度分析

- **时间复杂度**：`O(n * amount)`，其中 `n` 是硬币的种类。
- **空间复杂度**：`O(n * amount)`，使用了一个二维动态规划数组。

---

### 思路二：压缩状态的动态规划

- 使用一维数组 `dp`，其中 `dp[j]` 表示凑成金额 `j` 的组合数。
- 初始化 `dp[0]` 为 1，表示凑成金额为 0 的组合数为 1。
- 状态转移方程：`dp[j] += dp[j - coin]`，其中，`coin` 表示当前硬币的面值。
- 遍历硬币种类和金额，根据状态转移方程更新 `dp[j]` 的值。

  - 对于每一种硬币 `coin`，遍历金额 `j`。
  - 如果 `j - coin >= 0`，则更新 `dp[j]` 的值。

#### 复杂度分析

- **时间复杂度**：`O(n * amount)`，其中 `n` 是硬币的种类。
- **空间复杂度**：`O(amount)`，使用了一个一维动态规划数组。

## 代码

::: code-tabs

@tab 动态规划

```javascript
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function (amount, coins) {
	const n = coins.length;
	const dp = new Array(n + 1).fill(0).map(() => new Array(amount + 1).fill(0));
	for (let i = 0; i <= n; i++) {
		dp[i][0] = 1;
	}
	for (let i = 1; i <= n; i++) {
		for (let j = 1; j <= amount; j++) {
			if (j - coins[i - 1] >= 0) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
			} else {
				dp[i][j] = dp[i - 1][j];
			}
		}
	}

	return dp[n][amount];
};
```

@tab 压缩状态的动态规划

```javascript
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function (amount, coins) {
	const dp = new Array(amount + 1).fill(0);
	dp[0] = 1;
	for (let coin of coins) {
		for (let j = 1; j <= amount; j++) {
			if (j - coin >= 0) {
				dp[j] += dp[j - coin];
			}
		}
	}

	return dp[amount];
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2218 | [从栈中取出 K 个硬币的最大面值和](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) [`前缀和`](/tag/prefix-sum.md) | <font color=#ff334b>Hard</font> |
| 2585 | [获得分数的方法数](https://leetcode.com/problems/number-of-ways-to-earn-points) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ff334b>Hard</font> |
| 2902 | [和带限制的子多重集合的数目](https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum) |  |  [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`动态规划`](/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> |
| 2915 | [和为目标值的最长子序列的长度](https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |
| 3183 | [达到总和的方法数量](https://leetcode.com/problems/the-number-of-ways-to-make-the-sum) |  |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |