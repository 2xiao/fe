# [114. 二叉树展开为链表](https://leetcode.com/problems/flatten-binary-tree-to-linked-list)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`链表`](/tag/linked-list.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/flatten-binary-tree-to-linked-list)

## 题目

<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>

<ul>
	<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
	<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" target="_blank"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" style="width: 500px; height: 226px;" />
<pre>
<strong>输入：</strong>root = [1,2,5,3,4,null,6]
<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = [0]
<strong>输出：</strong>[0]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>


## 解题思路

### 思路一：迭代

使用一个栈来模拟先序遍历。从根节点开始，将右子节点和左子节点入栈。出栈时，将当前节点的右子节点指向栈顶节点，同时将左子节点设为 `null`，以满足展开的要求。不断重复这个过程，直到栈为空，即完成了二叉树的展开。展开后的链表即为二叉树的先序遍历结果。

---

### 思路二：递归

通过递归先展开左右子树，然后将根节点的右子树连接到已经展开的左子树的末尾。

## 代码

::: code-tabs

@tab 迭代

```javascript
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function (root) {
	if (!root) return null;
	let stack = [root];
	while (stack.length) {
		let node = stack.pop();
		if (node.right) stack.push(node.right);
		if (node.left) stack.push(node.left);
		node.left = null;
		node.right = stack[stack.length - 1] || null;
	}
};
```

@tab 递归

```javascript
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function (root) {
	if (!root) return null;

	flatten(root.left);
	flatten(root.right);

	let rightSubtree = root.right;
	root.right = root.left;
	root.left = null;

	let end = root;
	while (end.right) {
		end = end.right;
	}
	end.right = rightSubtree;
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 430 | [扁平化多级双向链表](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list) | [[✓]](/problem/0430.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`链表`](/tag/linked-list.md) [`双向链表`](/tag/doubly-linked-list.md) | <font color=#ffb800>Medium</font> |
| 1660 | [纠正二叉树](https://leetcode.com/problems/correct-a-binary-tree) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `2+` | <font color=#ffb800>Medium</font> |