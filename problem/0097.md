# [97. 交错字符串](https://leetcode.com/problems/interleaving-string)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/interleaving-string)

## 题目

<p>给定三个字符串&nbsp;<code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证&nbsp;<code>s3</code>&nbsp;是否是由&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code><em> </em><strong>交错 </strong>组成的。</p>

<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> <span data-keyword="substring-nonempty">子字符串</span>：</p>

<ul>
	<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>
	<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>
	<li><code>|n - m| &lt;= 1</code></li>
	<li><strong>交错</strong> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>
</ul>

<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" />
<pre>
<strong>输入：</strong>s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
<strong>输出：</strong>false
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s1 = "", s2 = "", s3 = ""
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>
	<li><code>0 &lt;= s3.length &lt;= 200</code></li>
	<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>


## 解题思路

### 思路一：动态规划

1. **动态规划**：

   - 使用一个二维布尔数组 `dp`，其中 `dp[i][j]` 表示 `s3` 的前 `i + j` 个字符可以由 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符交错形成。

2. **状态转移**：

   - 初始化 `dp[0][0]` 为 `true`，表示空字符串可以由两个空字符串交错形成。
   - 然后填充 `dp` 表：
     - 如果 `s1[i-1]` 和 `s3[i+j-1]` 相等，则 `dp[i][j]` 可以从 `dp[i-1][j]` 转移而来。
     - 如果 `s2[j-1]` 和 `s3[i+j-1]` 相等，则 `dp[i][j]` 可以从 `dp[i][j-1]` 转移而来。

3. **最终结果**：
   - `dp[s1.length][s2.length]` 表示 `s3` 是否可以由 `s1` 和 `s2` 交错形成。

#### 复杂度分析

- **时间复杂度**：`O(m * n)`，需要填充整个 `dp` 数组。
- **空间复杂度**：`O(m * n)`，使用的 DP 数组。

---

### 思路二：动态规划+压缩状态

要通过使用一维数组代替二维数组，可以将思路一的空间复杂度优化到 `O(n)`。

- 我们只需要保留当前行的信息，因此可以用一个长度为 `n + 1` 的一维数组来存储状态。
- 创建一个长度为 `n + 1` 的一维数组 `dp`，并初始化 `dp[0]` 为 `true`。
- 处理 `s2` 的字符，初始化 `dp` 的第一行。
- 处理 `s1` 的字符，更新 `dp` 数组。
- 在更新时，从后向前更新，以防止覆盖之前的数据。使用当前 `dp[j]` 和 `dp[j - 1]` 来判断是否可以交错形成 `s3` 的相应部分。

#### 复杂度分析

- **时间复杂度**：`O(m * n)`，与之前相同。
- **空间复杂度**：`O(n)`，通过使用一维数组代替二维数组来减少空间使用。

### 总结：

## 代码

::: code-tabs

@tab 动态规划

```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function (s1, s2, s3) {
	const m = s1.length,
		n = s2.length;

	if (m + n !== s3.length) return false;

	let dp = new Array(m + 1).fill(0).map((i) => new Array(n + 1).fill(false));
	dp[0][0] = true;

	for (let i = 0; i <= m; i++) {
		for (let j = 0; j <= n; j++) {
			if (i > 0 && s1[i - 1] == s3[i - 1 + j]) {
				dp[i][j] = dp[i][j] || dp[i - 1][j];
			}
			if (j > 0 && s2[j - 1] == s3[i + j - 1]) {
				dp[i][j] = dp[i][j] || dp[i][j - 1];
			}
		}
	}

	return dp[m][n];
};
```

@tab 动态规划+压缩状态

```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function (s1, s2, s3) {
	const m = s1.length,
		n = s2.length;
	if (m + n !== s3.length) return false;

	let dp = new Array(n + 1);
	dp[0] = true;

	for (let j = 0; j <= n; j++) {
		dp[j] = j === 0 || (dp[j - 1] && s2[j - 1] === s3[j - 1]);
	}

	for (let i = 1; i <= m; i++) {
		dp[0] = dp[0] && s1[i - 1] === s3[i - 1];
		for (let j = 1; j <= n; j++) {
			dp[j] =
				(dp[j] && s1[i - 1] === s3[i + j - 1]) ||
				(dp[j - 1] && s2[j - 1] === s3[i + j - 1]);
		}
	}

	return dp[n];
};
```

:::
