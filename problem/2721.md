# [2721. 并行执行异步函数](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel)

## 题目

<p>给定一个异步函数数组 <code>functions</code>，返回一个新的 promise 对象&nbsp;<code>promise</code>。数组中的每个函数都不接受参数并返回一个 promise。所有的 promise 都应该并行执行。</p>

<p><code>promise</code> resolve 条件：</p>

<ul>
	<li>当所有从 <code>functions</code> 返回的 promise 都成功的并行解析时。<code>promise</code> 的解析值应该是一个按照它们在 <code>functions</code> 中的顺序排列的 promise 的解析值数组。<code>promise</code> 应该在数组中的所有异步函数并行执行完成时解析。</li>
</ul>

<p><code>promise</code>&nbsp;reject 条件：</p>

<ul>
	<li>当任何从 <code>functions</code> 返回的 promise 被拒绝时。<code>promise</code> 也会被拒绝，并返回第一个拒绝的原因。</li>
</ul>

<p>请在不使用内置的 <code>Promise.all</code> 函数的情况下解决。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<b>输入：</b>functions = [
&nbsp; () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 200))
]
<b>输出：</b>{"t": 200, "resolved": [5]}
<b>解释：</b>
promiseAll(functions).then(console.log); // [5]

单个函数在 200 毫秒后以值 5 成功解析。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<b>输入：</b>functions = [
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 200)), 
    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject("Error"), 100))
]
<b>输出：</b>{"t": 100, "rejected": "Error"}
<b>解释：</b>由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<b>输入：</b>functions = [
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(4), 50)), 
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 150)), 
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(16), 100))
]
<b>输出：</b>{"t": 150, "resolved": [4, 10, 16]}
<b>解释：</b>所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>函数 <code>functions</code> 是一个返回 promise 的函数数组</li>
	<li><code>1 &lt;= functions.length &lt;= 10</code></li>
</ul>


## 解题思路

为了并行执行数组中的异步函数并返回一个 `Promise`，需要手动实现 `Promise.all` 的功能。`Promise.all` 的行为是当数组中的所有 `Promise` 都成功时，返回所有的结果；如果有任何 `Promise` 失败，则立即拒绝。

1. **创建一个新的 `Promise`**：该 Promise 将在所有异步函数都成功时解析，或在其中任何一个被拒绝时拒绝。
2. **创建一个结果数组**，用于保存每个函数的结果，以确保最终的结果顺序与输入顺序一致。
3. **手动维护一个计数器**，用于跟踪已完成的 Promise 数量。
4. **遍历 `functions` 数组**：对于每个函数，手动执行它并对其返回的 Promise 进行处理。

   - 若成功，将函数的成功结果存储在 `results` 数组中，计数器 `count` 递增，当所有函数都成功执行时，解析 `results` 数组。
   - 若任何一个函数返回的 Promise 被拒绝，则立即拒绝整个 `Promise`，并且抛出第一个错误原因。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是 `functions` 的数量，需要遍历所有函数并触发它们的执行。
- **空间复杂度**：`O(n)`，用于存储函数的结果。

## 代码

```javascript
/**
 * @param {Array<Function>} functions
 * @return {Promise<any>}
 */
var promiseAll = function (functions) {
	return new Promise((resolve, reject) => {
		let result = [],
			count = 0;
		functions.map((fn, i) => {
			fn()
				.then((res) => {
					result[i] = res;
					count++;

					// 当所有函数都成功解析时，解析整个结果
					if (count == functions.length) {
						resolve(result);
					}
				})
				.catch((err) => reject(err)); // 一旦有任何函数被拒绝，立即拒绝整个 promise
		});
	});
};

/**
 * const promise = promiseAll([() => new Promise(res => res(42))])
 * promise.then(console.log); // [42]
 */
```
