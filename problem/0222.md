# [222. 完全二叉树的节点个数](https://leetcode.com/problems/count-complete-tree-nodes)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`位运算`](/tag/bit-manipulation.md) [`树`](/tag/tree.md) [`二分查找`](/tag/binary-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/count-complete-tree-nodes)

## 题目

<p>给你一棵<strong> 完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>

<p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2<sup>h</sup></code> 个节点。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" style="width: 372px; height: 302px;" />
<pre>
<strong>输入：</strong>root = [1,2,3,4,5,6]
<strong>输出：</strong>6
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>0
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点的数目范围是<code>[0, 5 * 10<sup>4</sup>]</code></li>
	<li><code>0 <= Node.val <= 5 * 10<sup>4</sup></code></li>
	<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p>


## 解题思路

### 思路一：层序遍历

按照层序遍历一次树，然后把每一层的结点个数相加即可。

---

### 思路二：递归

关键思想是比较左右子树的深度。如果它们相等，左子树是一个满二叉树，节点总数可以直接计算 (`2 ^ i - 1`)。如果深度不相等，右子树是一个满二叉树，节点总数也可以根据深度计算。递归调用处理两个子树，直到达到基本情况（一个空节点）。

- `countNodes` 函数以完全二叉树的根节点作为输入，递归计算节点的数量。
- `getDepth` 函数通过遍历左孩子直到叶子节点，计算给定节点的深度。

## 代码

::: code-tabs

@tab 层序遍历

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
	let res = 0;
	if (!root) return res;
	let queue = [root];
	while (queue.length) {
		let len = queue.length;
		for (let i = 0; i < len; i++) {
			if (queue[i].left) queue.push(queue[i].left);
			if (queue[i].right) queue.push(queue[i].right);
			res++;
		}
		queue = queue.slice(len);
	}
	return res;
};
```

@tab 递归

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
	if (!root) return 0;

	const getDepth = (node) => {
		let depth = 0;
		while (node) {
			node = node.left;
			depth++;
		}
		return depth;
	};

	let leftDepth = getDepth(root.left);
	let rightDepth = getDepth(root.right);

	if (leftDepth == rightDepth)
		return Math.pow(2, leftDepth) + countNodes(root.right);
	return Math.pow(2, rightDepth) + countNodes(root.left);
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 270 | [最接近的二叉搜索树值](https://leetcode.com/problems/closest-binary-search-tree-value) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `2+` | <font color=#15bd66>Easy</font> |