# [216. 组合总和 III](https://leetcode.com/problems/combination-sum-iii)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/combination-sum-iii)

## 题目

<p>找出所有相加之和为&nbsp;<code>n</code><em> </em>的&nbsp;<code>k</code><strong>&nbsp;</strong>个数的组合，且满足下列条件：</p>

<ul>
	<li>只使用数字1到9</li>
	<li>每个数字&nbsp;<strong>最多使用一次</strong>&nbsp;</li>
</ul>

<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> <em><strong>k</strong></em> = 3, <em><strong>n</strong></em> = 7
<strong>输出:</strong> [[1,2,4]]
<strong>解释:</strong>
1 + 2 + 4 = 7
没有其他符合的组合了。</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> <em><strong>k</strong></em> = 3, <em><strong>n</strong></em> = 9
<strong>输出:</strong> [[1,2,6], [1,3,5], [2,3,4]]
<strong>解释:
</strong>1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> k = 4, n = 1
<strong>输出:</strong> []
<strong>解释:</strong> 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= 9</code></li>
	<li><code>1 &lt;= n &lt;= 60</code></li>
</ul>


## 解题思路

可以通过回溯算法和递归找到所有满足给定条件的组合：

1. 定义结果数组 `res` 用于存储符合条件的组合，以及路径数组 `track` 用于暂时存储当前组合的数字。
2. 使用 `backtrack` 函数进行递归搜索，其中 `start` 参数表示搜索的起始数字，保证每个数字最多使用一次。
3. 在递归的过程中，判断当前组合的长度是否等于 `k` 且组合的和是否等于目标值 `n`，如果满足条件，则将当前组合加入结果数组。
4. 在递归的过程中，进行剪枝：
   - 如果当前组合的和超过目标值 `n`，则直接返回，因为后续的数字只会更大，无法满足条件。
   - 如果当前组合的长度超过 `k`，则直接返回，因为组合中的数字过多。
5. 循环遍历数字 `i`，将其加入当前组合，并更新组合的和。然后递归调用 `backtrack` 函数，并在递归完成后将数字 `i` 弹出组合，同时更新组合的和，以便回溯到上一层。
6. 最终返回结果数组 `res`。

## 代码

```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function (k, n) {
	let res = [];
	let track = [];
	let sum = 0;

	const backtrack = (start) => {
		// 找到一个满足条件的组合
		if (track.length == k && sum == n) {
			res.push([...track]);
			return;
		}
		// 当前组合的和超过 n ，剪枝
		if (sum > n) {
			return;
		}
		// 当前组合的长度超过 k ，剪枝
		if (track.length > k) {
			return;
		}
		for (let i = start; i <= 9; i++) {
			track.push(i);
			sum += i;
			backtrack(i + 1);
			track.pop();
			sum -= i;
		}
	};
	backtrack(1);
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 39 | [组合总和](https://leetcode.com/problems/combination-sum) | [[✓]](/problem/0039.md) |  [`数组`](/tag/array.md) [`回溯`](/tag/backtracking.md) | <font color=#ffb800>Medium</font> |