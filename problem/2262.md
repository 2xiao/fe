# [2262. 字符串的总引力](https://leetcode.com/problems/total-appeal-of-a-string)

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/total-appeal-of-a-string)

## 题目

<p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p>

<ul>
	<li>例如，<code>"abbca"</code> 的引力为 <code>3</code> ，因为其中有 <code>3</code> 个不同字符 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 。</li>
</ul>

<p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> <strong>。</strong></p>

<p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "abbca"
<strong>输出：</strong>28
<strong>解释：</strong>"abbca" 的子字符串有：
- 长度为 1 的子字符串："a"、"b"、"b"、"c"、"a" 的引力分别为 1、1、1、1、1，总和为 5 。
- 长度为 2 的子字符串："ab"、"bb"、"bc"、"ca" 的引力分别为 2、1、2、2 ，总和为 7 。
- 长度为 3 的子字符串："abb"、"bbc"、"bca" 的引力分别为 2、2、3 ，总和为 7 。
- 长度为 4 的子字符串："abbc"、"bbca" 的引力分别为 3、3 ，总和为 6 。
- 长度为 5 的子字符串："abbca" 的引力为 3 ，总和为 3 。
引力总和为 5 + 7 + 7 + 6 + 3 = 28 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "code"
<strong>输出：</strong>20
<strong>解释：</strong>"code" 的子字符串有：
- 长度为 1 的子字符串："c"、"o"、"d"、"e" 的引力分别为 1、1、1、1 ，总和为 4 。
- 长度为 2 的子字符串："co"、"od"、"de" 的引力分别为 2、2、2 ，总和为 6 。
- 长度为 3 的子字符串："cod"、"ode" 的引力分别为 3、3 ，总和为 6 。
- 长度为 4 的子字符串："code" 的引力为 4 ，总和为 4 。
引力总和为 4 + 6 + 6 + 4 = 20 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> 由小写英文字母组成</li>
</ul>


## 解题思路

对于每个字符，它会出现在某些子字符串中，并对这些子字符串的吸引力有贡献。可以跟踪每个字符最后一次出现的位置，并计算从该字符的最后出现位置到当前字符之间的子字符串的吸引力变化。

为了避免遍历所有子字符串，可以使用动态更新的方式计算某个字符对当前子字符串的贡献。通过记录每个字符最后一次出现的位置，可以快速计算该字符的贡献。

1. **初始化**：

   - 使用数组 `lastIndex` 来记录每个字符的最后一次出现位置，初始值设为 `-1`，表示还没有出现过。
   - 变量 `dp` 用来跟踪从第一个字符到当前字符的所有子字符串的总吸引力。
   - 变量 `res` 用来存储所有子字符串的吸引力总和。

2. **遍历字符串**：

   - 对于字符串中的每个字符，首先通过 `lastIndex` 找到该字符上一次出现的位置。如果当前字符上一次出现在位置 `j`，那么从 `j+1` 到 `i` 的所有子字符串都会包含当前字符，因此当前字符对这些子字符串的吸引力都有贡献。
   - 计算当前字符的贡献并更新 `dp` 和 `res`。

3. **更新索引**：
   - 每次处理完当前字符后，将其最后出现的位置更新为当前索引 `i`。

#### 复杂度分析

- **时间复杂度**： `O(n)`，因为只遍历了一遍字符串，且每个字符的操作都是常数时间。
- **空间复杂度**： `O(1)`（考虑字符集大小为 26 个字母）。

通过记录每个字符的最后出现位置，可以高效地计算出每个字符对总吸引力的贡献，避免了暴力遍历所有子字符串的复杂度，从而达到了线性时间的复杂度。

## 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var appealSum = function (s) {
	let res = 0,
		dp = 0;
	// 用于记录每个字符最后一次出现的位置
	let lastIndex = new Array(26).fill(-1);
	for (let i = 0; i < s.length; i++) {
		// 将字符转换为数组索引
		let charIndex = s[i].charCodeAt() - 'a'.charCodeAt();
		// 更新当前子串的总吸引力
		dp += i - lastIndex[charIndex];
		// 累加到总吸引力
		res += dp;
		// 更新字符的最后出现位置
		lastIndex[charIndex] = i;
	}
	return res;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 828 | [统计子串中的唯一字符](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string) |  |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md) | <font color=#ff334b>Hard</font> |
| 2062 | [统计字符串中的元音子字符串](https://leetcode.com/problems/count-vowel-substrings-of-a-string) |  |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) | <font color=#15bd66>Easy</font> |
| 2063 | [所有子字符串中的元音](https://leetcode.com/problems/vowels-of-all-substrings) |  |  [`数学`](/tag/math.md) [`字符串`](/tag/string.md) [`动态规划`](/tag/dynamic-programming.md) `1+` | <font color=#ffb800>Medium</font> |
| 3134 | [找出唯一性数组的中位数](https://leetcode.com/problems/find-the-median-of-the-uniqueness-array) |  |  [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`二分查找`](/tag/binary-search.md) `1+` | <font color=#ff334b>Hard</font> |