# [1047. 删除字符串中的所有相邻重复项](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string)

## 题目

<p>给出由小写字母组成的字符串&nbsp;<code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>

<p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p>

<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>"abbaca"
<strong>输出：</strong>"ca"
<strong>解释：</strong>
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> 仅由小写英文字母组成。</li>
</ol>


## 解题思路

用栈模拟，类似“对对碰”；

- 遍历输入的字符串，用栈来存储字符；
- 如果栈不为空，且新遍历到的字符与栈顶的字符一样的话，就弹出栈顶字符；
- 否则将新遍历到的字符放入栈顶；
- 直至扫完整个字符串，栈中剩下的字符串就是最终要输出的结果。

## 代码

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function (s) {
	let stack = [];
	for (let i = 0; i < s.length; i++) {
		let len = stack.length;
		if (len != 0 && stack[len - 1] == s[i]) {
			stack.pop();
		} else {
			stack.push(s[i]);
		}
	}
	return stack.join('');
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1209 | [删除字符串中的所有相邻重复项 II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii) |  |  [`栈`](/tag/stack.md) [`字符串`](/tag/string.md) | <font color=#ffb800>Medium</font> |
| 2390 | [从字符串中移除星号](https://leetcode.com/problems/removing-stars-from-a-string) |  |  [`栈`](/tag/stack.md) [`字符串`](/tag/string.md) [`模拟`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |
| 2716 | [最小化字符串长度](https://leetcode.com/problems/minimize-string-length) |  |  [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) | <font color=#15bd66>Easy</font> |