# [173. 二叉搜索树迭代器](https://leetcode.com/problems/binary-search-tree-iterator)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`二叉树`](/tag/binary-tree.md) [`迭代器`](/tag/iterator.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/binary-search-tree-iterator)

## 题目

实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
<div class="original__bRMd">
<div>
<ul>
	<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
	<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>
	<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>
</ul>

<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
</div>
</div>

<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>

<p> </p>

<p><strong>示例：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />
<pre>
<strong>输入</strong>
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>输出</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>解释</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>
</ul>

<p> </p>

<p><strong>进阶：</strong></p>

<ul>
	<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>
</ul>


## 解题思路

可以采用中序遍历的方式，通过队列来模拟递归过程。

因为题目要求调用 `next()` 返回下一个最小的数，即按照从小到大的顺序返回元素，这正好符合二叉搜索树中序遍历的特性，二叉搜索树（BST）的中序遍历能够按照升序顺序输出树中的所有节点值。

1. 在构造函数中，调用 `_inorder()` 方法对整个树进行中序遍历，将遍历结果按顺序存入 `queue`。
2. `next()` 方法：返回并移除队列中的第一个元素。
3. `hasNext()` 方法：判断队列是否还有剩余元素。

#### 复杂度分析

- **时间复杂度**：

  - **初始化 (`constructor`)**: `O(n)`，其中 `n` 是树中节点的数量。因为 `_inorder()` 方法会遍历树中的每一个节点，并将它们按中序顺序存入队列，整体是线性时间复杂度。
  - **`next()` 操作**: `O(1)`，因为只需要从队列中移除并返回第一个元素。
  - **`hasNext()` 操作**: `O(1)`，仅仅检查队列的长度是否大于 0。

- **空间复杂度**：
  - **初始化 (`constructor`)**: `O(n)`，队列需要存储树中的所有节点，因此空间复杂度与节点数 `n` 成正比。
  - **`next()` 和 `hasNext()` 操作**：`O(1)`，因为这些操作只需要访问或修改队列，不需要额外的空间。

## 代码

```javascript
class BSTIterator {
	// @param {TreeNode} root
	constructor(root) {
		this.queue = [];
		this._inorder(root);
	}
	// 中序遍历
	_inorder(root) {
		if (!root) return null;
		this._inorder(root.left);
		this.queue.push(root.val);
		this._inorder(root.right);
	}
	// @return {number}
	next() {
		return this.queue.shift();
	}
	// @return {boolean}
	hasNext() {
		return this.queue.length > 0;
	}
}
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 94 | [二叉树的中序遍历](https://leetcode.com/problems/binary-tree-inorder-traversal) | [[✓]](/problem/0094.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `1+` | <font color=#15bd66>Easy</font> |
| 251 | [展开二维向量](https://leetcode.com/problems/flatten-2d-vector) |  |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) `1+` | <font color=#ffb800>Medium</font> |
| 281 | [锯齿迭代器](https://leetcode.com/problems/zigzag-iterator) |  |  [`设计`](/tag/design.md) [`队列`](/tag/queue.md) [`数组`](/tag/array.md) `1+` | <font color=#ffb800>Medium</font> |
| 284 | [窥视迭代器](https://leetcode.com/problems/peeking-iterator) |  |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`迭代器`](/tag/iterator.md) | <font color=#ffb800>Medium</font> |
| 285 | [二叉搜索树中的中序后继](https://leetcode.com/problems/inorder-successor-in-bst) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) `1+` | <font color=#ffb800>Medium</font> |
| 1586 | [二叉搜索树迭代器 II](https://leetcode.com/problems/binary-search-tree-iterator-ii) |  |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) `3+` | <font color=#ffb800>Medium</font> |