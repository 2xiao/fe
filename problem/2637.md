# [2637. 有时间限制的 Promise 对象](https://leetcode.com/problems/promise-time-limit)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/promise-time-limit)

## 题目

<p>请你编写一个函数，它接受一个异步函数 <code>fn</code>&nbsp;和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。函数 <code>fn</code> 接受提供给 <strong>限时</strong> 函数的参数。</p>

<p><strong>限时</strong> 函数应遵循以下规则：</p>

<ul>
	<li>如果 <code>fn</code> 在 <code>t</code> 毫秒的时间限制内完成，<strong>限时</strong> 函数应返回结果。</li>
	<li>如果 <code>fn</code> 的执行超过时间限制，<strong>限时&nbsp;</strong>函数应拒绝并返回字符串 <code>"Time Limit Exceeded"</code> 。</li>
</ul>

<p>&nbsp;</p>

<p><b>示例 1：</b></p>

<pre>
<strong>输入：</strong>
fn = async (n) =&gt; { 
&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); 
&nbsp; return n * n; 
}
inputs = [5]
t = 50
<strong>输出：</strong>{"rejected":"Time Limit Exceeded","time":50}
<strong>解释：</strong>
const limited = timeLimit(fn, t)
const start = performance.now()
let result;
try {
&nbsp; &nbsp;const res = await limited(...inputs)
&nbsp; &nbsp;result = {"resolved": res, "time": Math.floor(performance.now() - start)};
} catch (err) {
&nbsp;  result = {"rejected": err, "time": Math.floor(performance.now() - start)};
}
console.log(result) // 输出结果
<b>
</b>提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。
</pre>

<p><b>示例 2：</b></p>

<pre>
<strong>输入：</strong>
fn = async (n) =&gt; { 
&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); 
&nbsp; return n * n; 
}
inputs = [5]
t = 150
<strong>输出：</strong>{"resolved":25,"time":100}
<strong>解释：</strong>
在 t=100ms 时执行 5*5=25 ，没有达到超时时间。
</pre>

<p><b>示例 3：</b></p>

<pre>
<strong>输入：</strong>
fn = async (a, b) =&gt; { 
&nbsp; await new Promise(res =&gt; setTimeout(res, 120)); 
&nbsp; return a + b; 
}
inputs = [5,10]
t = 150
<strong>输出：</strong>{"resolved":15,"time":120}
<strong>解释：</strong><b>
</b>在 t=120ms 时执行 5+10=15，没有达到超时时间。
</pre>

<p><b>示例 4：</b></p>

<pre>
<strong>输入：</strong>
fn = async () =&gt; { 
&nbsp; throw "Error";
}
inputs = []
t = 1000
<strong>输出：</strong>{"rejected":"Error","time":0}
<strong>解释：</strong>
此函数始终丢出 Error</pre>

<p>&nbsp;</p>

<p><b>提示：</b></p>

<ul>
	<li><code>0 &lt;= inputs.length &lt;= 10</code></li>
	<li><code>0 &lt;= t &lt;= 1000</code></li>
	<li><code>fn</code> 返回一个 Promise 对象</li>
</ul>


## 解题思路

1. 在 `timeLimit` 中返回了一个新的异步函数，并通过 `Promise` 来控制结果的返回。
2. 设置一个定时器 `setTimeout` 用来判断 `fn` 是否超时，当超过给定的时间 `t` 时，定时器将触发，拒绝 Promise 并返回 `"Time Limit Exceeded"`。
3. 执行异步函数 `fn`，如果 `fn` 在规定时间内完成，无论是成功还是失败，都清理定时器以确保其不会再次执行。

#### 复杂度分析

- **时间复杂度**：取决于传入的 `fn` 的复杂度，假设为 `O(fn)`。
- **空间复杂度**：`O(1)`，仅有定时器和 Promise 相关的内存开销。

## 代码

```javascript
/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var timeLimit = function (fn, t) {
	return async function (...args) {
		return new Promise((resolve, reject) => {
			// 超时后拒绝 Promise
			const timer = setTimeout(() => reject('Time Limit Exceeded'), t);

			// 执行异步函数 fn
			fn(...args)
				.then((result) => {
					clearTimeout(timer); // 成功时清除定时器
					resolve(result);
				})
				.catch((err) => {
					clearTimeout(timer); // 失败时清除定时器
					reject(err);
				});
		});
	};
};

/**
 * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);
 * limited(150).catch(console.log) // "Time Limit Exceeded" at t=100ms
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2621 | [睡眠函数](https://leetcode.com/problems/sleep) | [[✓]](/problem/2621.md) |  | <font color=#15bd66>Easy</font> |
| 2622 | [有时间限制的缓存](https://leetcode.com/problems/cache-with-time-limit) | [[✓]](/problem/2622.md) |  | <font color=#ffb800>Medium</font> |
| 2627 | [函数防抖](https://leetcode.com/problems/debounce) | [[✓]](/problem/2627.md) |  | <font color=#ffb800>Medium</font> |
| 2636 | [Promise 对象池](https://leetcode.com/problems/promise-pool) | [[✓]](/problem/2636.md) |  | <font color=#ffb800>Medium</font> |
| 2676 | [节流](https://leetcode.com/problems/throttle) | [[✓]](/problem/2676.md) |  | <font color=#ffb800>Medium</font> |