# [3319. 第 K 大的完美二叉子树的大小](https://leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree)

## 题目

<p>给你一棵 <strong>二叉树 </strong>的根节点 <code>root</code> 和一个整数<code>k</code>。</p>

<p>返回第 <code>k</code> 大的 <strong>完美二叉</strong><span data-keyword="subtree"><strong>子树</strong> </span>的大小，如果不存在则返回 <code>-1</code>。</p>

<p><strong>完美二叉树 </strong>是指所有叶子节点都在同一层级的树，且每个父节点恰有两个子节点。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2</span></p>

<p><strong>输出：</strong> <span class="example-io">3</span></p>

<p><strong>解释：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmpresl95rp-1.png" style="width: 400px; height: 173px;" /></p>

<p>完美二叉子树的根节点在图中以黑色突出显示。它们的大小按非递增顺序排列为 <code>[3, 3, 1, 1, 1, 1, 1, 1]</code>。<br />
第 <code>2</code> 大的完美二叉子树的大小是 3。</p>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">root = [1,2,3,4,5,6,7], k = 1</span></p>

<p><strong>输出：</strong> <span class="example-io">7</span></p>

<p><strong>解释：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmp_s508x9e-1.png" style="width: 300px; height: 189px;" /></p>

<p>完美二叉子树的大小按非递增顺序排列为 <code>[7, 3, 3, 1, 1, 1, 1]</code>。最大的完美二叉子树的大小是 7。</p>
</div>

<p><strong class="example">示例 3：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">root = [1,2,3,null,4], k = 3</span></p>

<p><strong>输出：</strong> <span class="example-io">-1</span></p>

<p><strong>解释：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmp74xnmpj4-1.png" style="width: 250px; height: 225px;" /></p>

<p>完美二叉子树的大小按非递增顺序排列为 <code>[1, 1]</code>。完美二叉子树的数量少于 3。</p>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中的节点数目在 <code>[1, 2000]</code> 范围内。</li>
	<li><code>1 &lt;= Node.val &lt;= 2000</code></li>
	<li><code>1 &lt;= k &lt;= 1024</code></li>
</ul>


## 解题思路

完美子树是指该树的所有叶子节点在同一层，且每个非叶子节点都有两个子节点。因此可以使用递归来遍历二叉树，检查每个节点的子树是否是完美子树。

在递归过程中，判断某个节点的左右子树是否高度相同且都是完美的。如果是，可以计算当前子树的节点数。

使用一个数组存储所有完美子树的大小。然后在递归完成后，排序该数组，并找到第 `k` 大的完美子树的大小。

如果数组的大小小于 `k`，返回 `-1`，否则返回数组中第 `k` 大的元素。

#### 复杂度分析

- **时间复杂度**：`O(n)`，每个节点遍历一次。
- **空间复杂度**：`O(n)`，用于存储所有完美子树的大小。

## 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestPerfectSubtree = function (root, k) {
	let sizes = findPerfectSubtree(root);
	if (sizes.length < k) return -1;

	// 按降序排序
	sizes.sort((a, b) => b - a);
	return sizes[k - 1];
};

var findPerfectSubtree = function (root) {
	let sizes = [];

	// 递归函数，返回当前子树的高度、节点数和是否为完美二叉树
	const dfs = (root) => {
		if (!root) return [0, 0, true];
		const [leftHeight, leftCount, isLeftPerfect] = dfs(root.left);
		const [rightHeight, rightCount, isRightPerfect] = dfs(root.right);

		const rootCount = leftCount + rightCount + 1;

		// 检查是否为完美子树
		if (leftHeight == rightHeight && isLeftPerfect && isRightPerfect) {
			sizes.push(rootCount);
			return [leftHeight + 1, rootCount, true];
		}
		return [Math.max(leftHeight, rightHeight) + 1, rootCount, false];
	};

	dfs(root);
	return sizes;
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 110 | [平衡二叉树](https://leetcode.com/problems/balanced-binary-tree) | [[✓]](/problem/0110.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md) | <font color=#15bd66>Easy</font> |