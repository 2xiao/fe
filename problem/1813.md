# [1813. 句子相似性 III](https://leetcode.com/problems/sentence-similarity-iii)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/sentence-similarity-iii)

## 题目

<p>给定两个字符串&nbsp;<code>sentence1</code>&nbsp;和&nbsp;<code>sentence2</code>，每个表示由一些单词组成的一个句子。句子是一系列由&nbsp;<strong>单个 </strong>空格分隔的&nbsp;<strong>单词</strong>，且开头和结尾没有多余空格。每个单词都只包含大写和小写英文字母。</p>

<p>如果两个句子&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong>&nbsp;。<strong>注意</strong>，插入的句子必须与现有单词用空白隔开。&nbsp;</p>

<p>比方说，</p>

<ul>
	<li><code>s1 = "Hello Jane"</code> 与&nbsp;<code>s2 = "Hello my name is Jane"</code>，我们可以往 <code>s1</code>&nbsp;中&nbsp;<code>"Hello"</code> 和&nbsp;<code>"Jane"</code>&nbsp;之间插入&nbsp;<code>"my name is"</code>&nbsp;得到 <code>s2</code>&nbsp;。</li>
	<li><code>s1 = "Frog cool"</code>&nbsp;与 <code>s2 = "Frogs are cool"</code>&nbsp;不是相似的，因为尽管往&nbsp;<code>s1</code>&nbsp;中插入&nbsp;<code>"s are"</code>，它没有与&nbsp;<code>"Frog"</code>&nbsp;用空格隔开。</li>
</ul>

<p>给你两个句子&nbsp;<code>sentence1</code> 和&nbsp;<code>sentence2</code>&nbsp;，如果<em>&nbsp;</em><code>sentence1</code> 和<em>&nbsp;</em><code>sentence2</code> 是 <strong>相似</strong> 的，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<div class="example-block"><b>输入：</b>sentence1 = "My name is Haley", sentence2 = "My Haley"</div>

<div class="example-block"><b>输出：</b>true</div>

<div class="example-block"><b>解释：</b>可以往 <code>sentence2</code> 中 "My" 和 "Haley" 之间插入 "name is" ，得到 <code>sentence1</code> 。</div>

<div class="example-block">&nbsp;</div>

<p><strong>示例 2：</strong></p>

<div class="example-block"><b>输入：</b>sentence1 = "of", sentence2 = "A lot of words"</div>

<div class="example-block"><b>输出：</b>false</div>

<div class="example-block"><strong>解释：</strong>没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</div>

<div class="example-block">&nbsp;</div>

<p><strong>示例 3：</strong></p>

<div class="example-block"><b>输入：</b>sentence1 = "Eating right now", sentence2 = "Eating"</div>

<div class="example-block"><b>输出：</b>true</div>

<div class="example-block"><b>解释：</b>可以往 <code>sentence2</code> 的结尾插入 "right now" 得到 <code>sentence1</code> 。</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>
	<li><code>sentence1</code>&nbsp;和&nbsp;<code>sentence2</code>&nbsp;都只包含大小写英文字母和空格。</li>
	<li><code>sentence1</code>&nbsp;和&nbsp;<code>sentence2</code>&nbsp;中的单词都只由单个空格隔开。</li>
</ul>


## 解题思路

1. **初始化**：首先将 `sentence1` 和 `sentence2` 按空格拆分为单词数组 `arr1` 和 `arr2`。
2. **双指针匹配前缀**：使用指针 `i` 从头开始比较 `arr1` 和 `arr2`，找到从头部匹配的最大长度。
3. **双指针匹配后缀**：使用指针 `j` 从尾部开始比较 `arr1` 和 `arr2`，找到从尾部匹配的最大长度。
4. **判断**：如果前缀和后缀加起来的长度能够覆盖 `arr2` 中的全部元素，或者 `arr1` 中的全部元素（即中间部分可以删除），则返回 `true`，否则返回 `false`。

#### 复杂度分析

- **时间复杂度**：`O(min(n, m))`，其中 `n` 是 `sentence1` 中单词的数量，`m` 是 `sentence2` 中单词的数量。我们最多遍历两者中较短的句子的所有单词。
- **空间复杂度**：`O(n + m)`，我们需要额外的空间来存储 `sentence1` 和 `sentence2` 的单词数组。

## 代码

```javascript
/**
 * @param {string} sentence1
 * @param {string} sentence2
 * @return {boolean}
 */
var areSentencesSimilar = function (sentence1, sentence2) {
	const arr1 = sentence1.split(' '),
		arr2 = sentence2.split(' '),
		len1 = arr1.length,
		len2 = arr2.length;

	let i = 0,
		j = 0;

	// 从头部开始匹配前缀
	while (i < len1 && i < len2 && arr1[i] == arr2[i]) {
		i++;
	}

	// 从尾部开始匹配后缀
	while (
		j < len1 - i &&
		j < len2 - i &&
		arr1[len1 - 1 - j] == arr2[len2 - 1 - j]
	) {
		j++;
	}

	// 如果匹配的前缀和后缀长度加起来能够覆盖较短句子的所有元素，则相似
	return i + j >= Math.min(len1, len2);
};
```
