# [355. 设计推特](https://leetcode.com/problems/design-twitter)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/design-twitter)

## 题目

<p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 <code>10</code> 条推文。</p>

<p>实现 <code>Twitter</code> 类：</p>

<ul>
	<li><code>Twitter()</code> 初始化简易版推特对象</li>
	<li><code>void postTweet(int userId, int tweetId)</code> 根据给定的 <code>tweetId</code> 和 <code>userId</code> 创建一条新推文。每次调用此函数都会使用一个不同的 <code>tweetId</code> 。</li>
	<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> 检索当前用户新闻推送中最近&nbsp; <code>10</code> 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 <strong>按照时间顺序由最近到最远排序</strong> 。</li>
	<li><code>void follow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户开始关注 ID 为 <code>followeeId</code> 的用户。</li>
	<li><code>void unfollow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户不再关注 ID 为 <code>followeeId</code> 的用户。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入</strong>
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
<strong>输出</strong>
[null, null, [5], null, null, [6, 5], null, [5]]

<strong>解释</strong>
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文
twitter.follow(1, 2);    // 用户 1 关注了用户 2
twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -&gt; [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的
twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2
twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>
	<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>
	<li>所有推特的 ID 都互不相同</li>
	<li><code>postTweet</code>、<code>getNewsFeed</code>、<code>follow</code> 和 <code>unfollow</code> 方法最多调用 <code>3 * 10<sup>4</sup></code> 次</li>
</ul>


## 解题思路

可以使用哈希表和优先队列（或者堆）来存储用户的推文和关注关系。

1. 可以使用一个哈希表来存储用户的推文。哈希表的键是用户的 ID，值是一个优先队列（或者堆），用于按照时间戳存储用户的推文。每个推文可以包含推文的 ID 和时间戳。

2. 当用户发布推文时，将推文添加到相应用户的优先队列中。为了保证推文按照时间顺序排序，可以使用时间戳作为排序的依据。

3. 获取新闻推送时，需要获取当前用户关注的人的推文，并将这些推文进行合并。为了方便合并，我们可以使用一个大顶堆，每次从堆中取出最大的时间戳的推文，同时将该推文所属用户的其他推文加入堆中。

4. 用户关注和取消关注可以通过维护关注关系的哈希表来实现。哈希表的键是关注者的 ID，值是一个集合，包含该关注者关注的人的 ID。

## 代码

```javascript
class Twitter {
	constructor() {
		this.tweets = new Map(); // 用户推文的哈希表
		this.following = new Map(); // 关注关系的哈希表
		this.timestamp = 0; // 时间戳，用于推文的排序
	}

	postTweet(userId, tweetId) {
		if (!this.tweets.has(userId)) {
			this.tweets.set(userId, []);
		}
		this.tweets.get(userId).push({ tweetId, timestamp: this.timestamp++ });
	}

	getNewsFeed(userId) {
		const heap = new MaxHeap();

		// 加入自己的推文
		if (this.tweets.has(userId)) {
			this.tweets.get(userId).forEach((tweet) => heap.insert(tweet));
		}

		// 加入关注者的推文
		if (this.following.has(userId)) {
			this.following.get(userId).forEach((followeeId) => {
				if (this.tweets.has(followeeId)) {
					this.tweets.get(followeeId).forEach((tweet) => heap.insert(tweet));
				}
			});
		}

		const result = [];
		while (!heap.isEmpty() && result.length < 10) {
			const tweet = heap.extractMax();
			result.push(tweet.tweetId);
		}

		return result;
	}

	follow(followerId, followeeId) {
		if (!this.following.has(followerId)) {
			this.following.set(followerId, new Set());
		}
		this.following.get(followerId).add(followeeId);
	}

	unfollow(followerId, followeeId) {
		if (this.following.has(followerId)) {
			this.following.get(followerId).delete(followeeId);
		}
	}
}

class MaxHeap {
	constructor() {
		this.heap = [];
	}

	insert(value) {
		this.heap.push(value);
		this.heapifyUp();
	}

	extractMax() {
		if (this.isEmpty()) {
			return null;
		}

		const max = this.heap[0];
		const last = this.heap.pop();

		if (this.heap.length > 0) {
			this.heap[0] = last;
			this.heapifyDown();
		}

		return max;
	}

	isEmpty() {
		return this.heap.length === 0;
	}

	heapifyUp() {
		let cur = this.heap.length - 1;

		while (cur > 0) {
			const parent = Math.floor((cur - 1) / 2);
			if (this.heap[cur].timestamp > this.heap[parent].timestamp) {
				[this.heap[cur], this.heap[parent]] = [
					this.heap[parent],
					this.heap[cur]
				];
				cur = parent;
			} else {
				break;
			}
		}
	}

	heapifyDown() {
		let cur = 0;

		while (true) {
			const leftChild = 2 * cur + 1;
			const rightChild = 2 * cur + 2;
			let next = null;

			if (
				leftChild < this.heap.length &&
				this.heap[leftChild].timestamp > this.heap[cur].timestamp
			) {
				next = leftChild;
			}

			if (
				rightChild < this.heap.length &&
				this.heap[rightChild].timestamp > this.heap[cur].timestamp
			) {
				next =
					this.heap[rightChild].timestamp > this.heap[leftChild].timestamp
						? rightChild
						: leftChild;
			}

			if (
				next !== null &&
				this.heap[cur].timestamp < this.heap[next].timestamp
			) {
				[this.heap[cur], this.heap[next]] = [this.heap[next], this.heap[cur]];
				cur = next;
			} else {
				break;
			}
		}
	}
}
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1500 | [设计文件分享系统](https://leetcode.com/problems/design-a-file-sharing-system) |  |  [`设计`](/tag/design.md) [`哈希表`](/tag/hash-table.md) [`数据流`](/tag/data-stream.md) `2+` | <font color=#ffb800>Medium</font> |