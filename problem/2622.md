# [2622. 有时间限制的缓存](https://leetcode.com/problems/cache-with-time-limit)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/cache-with-time-limit)

## 题目

<p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>

<p>该类有三个公共方法：</p>

<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>

<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>

<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong> 
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
timeDeays = [0, 0, 50, 50, 150]
<strong>输出：</strong> [null, false, 42, 1, -1]
<strong>解释：</strong>
在 t=0 时，缓存被构造。
在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。
在 t=50 时，请求 key=1 并返回值 42。
在 t=50 时，调用 count() ，缓存中有一个未过期的键。
在 t=100 时，key=1 到期。
在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
timeDelays = [0, 0, 40, 50, 120, 200, 250]
<strong>输出：</strong> [null, false, true, 50, 50, -1]
<strong>解释：</strong>
在 t=0 时，缓存被构造。
在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。
当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。
在 t=50 时，调用 get(1) ，返回 50。
在 t=120 时，调用 get(1) ，返回 50。
在 t=140 时，key=1 过期。
在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。
在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= key, value &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= duration &lt;= 1000</code></li>
	<li><code>1 &lt;= actions.length &lt;= 100</code></li>
	<li><code>actions.length === values.length</code></li>
	<li><code>actions.length === timeDelays.length</code></li>
	<li><code>0 &lt;= timeDelays[i] &lt;= 1450</code></li>
	<li><code>actions[i]</code> 是 "TimeLimitedCache"、"set"、"get" 和 "count" 中的一个。</li>
	<li>第一个操作始终是 "TimeLimitedCache" 而且一定会以 0 毫秒的延迟立即执行</li>
</ul>


## 解题思路

1. **`constructor`**：

   - 使用 `Map` 数据结构来存储键值对，其中每个键对应的值为一个数组 `[value, timer]`，其中 `value` 是存储的值，`timer` 是该键的定时器，用于删除过期键。

2. **`set(key, value, duration)`**：

   - 该方法将给定的键 `key` 和值 `value` 存入缓存，并设置该键值对的有效期 `duration` 毫秒。
   - 如果相同键已经存在且未过期，则返回 `true`，否则返回 `false`。
   - 使用 `setTimeout` 定时函数，在到期时间后自动删除该键值对。
   - 如果键已经存在且定时器没有到期，首先清除之前的定时器，以确保新设置的 `duration` 覆盖旧的时间。

3. **`get(key)`**：

   - 查询缓存中是否存在未过期的键 `key`。
   - 如果键存在且未过期，则返回其对应的值，否则返回 `-1`。

4. **`count()`**：
   - 返回当前缓存中未过期的键值对数量，直接通过 `Map` 对象的 `size` 属性来获取当前键的数量。

#### 复杂度分析

- **时间复杂度**：
  - **`set`**：每次调用 `set`，查找和插入操作的时间复杂度为 `O(1)`，删除旧的定时器和设置新的定时器也为常数时间操作。因此 `set` 的时间复杂度为 `O(1)`。
  - **`get`**：查找键的时间复杂度为 `O(1)`。
  - **`count`**：`Map.size` 的访问是常数时间操作，时间复杂度为 `O(1)`。
- **空间复杂度**：`O(n)`，其中 `n` 为缓存中存储的键值对数量，使用了 `Map` 来存储键值对。

## 代码

```javascript
var TimeLimitedCache = function () {
	this.cache = new Map();
};

/**
 * @param {number} key
 * @param {number} value
 * @param {number} duration time until expiration in ms
 * @return {boolean} if un-expired key already existed
 */
TimeLimitedCache.prototype.set = function (key, value, duration) {
	const timer = setTimeout(() => this.cache.delete(key), duration);
	const exist = this.cache.has(key);
	if (exist) {
		const oldTimer = this.cache.get(key)[1];
		clearTimeout(oldTimer);
	}
	this.cache.set(key, [value, timer]);
	return exist;
};

/**
 * @param {number} key
 * @return {number} value associated with key
 */
TimeLimitedCache.prototype.get = function (key) {
	if (this.cache.has(key)) return this.cache.get(key)[0];
	return -1;
};

/**
 * @return {number} count of non-expired keys
 */
TimeLimitedCache.prototype.count = function () {
	return this.cache.size;
};

/**
 * const timeLimitedCache = new TimeLimitedCache()
 * timeLimitedCache.set(1, 42, 1000); // false
 * timeLimitedCache.get(1) // 42
 * timeLimitedCache.count() // 1
 */
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 2627 | [函数防抖](https://leetcode.com/problems/debounce) | [[✓]](/problem/2627.md) |  | <font color=#ffb800>Medium</font> |
| 2636 | [Promise 对象池](https://leetcode.com/problems/promise-pool) | [[✓]](/problem/2636.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [有时间限制的 Promise 对象](https://leetcode.com/problems/promise-time-limit) | [[✓]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |