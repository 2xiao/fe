# [3318. 计算子数组的 x-sum I](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`滑动窗口`](/tag/sliding-window.md) [`堆（优先队列）`](/tag/heap-priority-queue.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i)

## 题目

<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，以及两个整数 <code>k</code> 和 <code>x</code>。</p>

<p>数组的 <strong>x-sum</strong> 计算按照以下步骤进行：</p>

<ul>
	<li>统计数组中所有元素的出现次数。</li>
	<li>仅保留出现次数最多的前 <code>x</code> 个元素的每次出现。如果两个元素的出现次数相同，则数值<strong> 较大 </strong>的元素被认为出现次数更多。</li>
	<li>计算结果数组的和。</li>
</ul>

<p><strong>注意</strong>，如果数组中的不同元素少于 <code>x</code> 个，则其 <strong>x-sum</strong> 是数组的元素总和。</p>

<p>返回一个长度为 <code>n - k + 1</code> 的整数数组 <code>answer</code>，其中 <code>answer[i]</code> 是 <span data-keyword="subarray-nonempty">子数组</span> <code>nums[i..i + k - 1]</code> 的 <strong>x-sum</strong>。</p>

<p><strong>子数组</strong> 是数组内的一个连续<b> 非空</b> 的元素序列。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block">
<p><strong>输入：</strong><span class="example-io">nums = [1,1,2,2,3,4,2,3], k = 6, x = 2</span></p>

<p><strong>输出：</strong><span class="example-io">[6,10,12]</span></p>

<p><strong>解释：</strong></p>

<ul>
	<li>对于子数组 <code>[1, 1, 2, 2, 3, 4]</code>，只保留元素 1 和 2。因此，<code>answer[0] = 1 + 1 + 2 + 2</code>。</li>
	<li>对于子数组 <code>[1, 2, 2, 3, 4, 2]</code>，只保留元素 2 和 4。因此，<code>answer[1] = 2 + 2 + 2 + 4</code>。注意 4 被保留是因为其数值大于出现其他出现次数相同的元素（3 和 1）。</li>
	<li>对于子数组 <code>[2, 2, 3, 4, 2, 3]</code>，只保留元素 2 和 3。因此，<code>answer[2] = 2 + 2 + 2 + 3 + 3</code>。</li>
</ul>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><strong>输入：</strong><span class="example-io">nums = [3,8,7,8,7,5], k = 2, x = 2</span></p>

<p><strong>输出：</strong><span class="example-io">[11,15,15,15,12]</span></p>

<p><strong>解释：</strong></p>

<p>由于 <code>k == x</code>，<code>answer[i]</code> 等于子数组 <code>nums[i..i + k - 1]</code> 的总和。</p>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
	<li><code>1 &lt;= x &lt;= k &lt;= nums.length</code></li>
</ul>


## 解题思路

- 可以使用滑动窗口的方式来计算每个长度为 `k` 的子数组的 `x 和`。滑动窗口的思想是在计算某个子数组时，通过移动窗口边界来避免重复计算每个元素的频率。
- 使用哈希表（字典）来存储每个元素的频率。每当窗口右移时，更新加入和移除的元素的频率。
- 每次更新完窗口后，根据每个元素的频率进行排序，并获取窗口中出现次数最多的前 `x` 个元素，计算前 `x` 个元素的和。
- 依次计算所有子数组的 `x 和` ，并存入结果数组 `answer` 中，最后返回。

#### 复杂度分析

- **时间复杂度**：`O((n - k + 1) * k log k)`，其中 `n` 是数组 `nums` 的长度，`k` 是滑动窗口的长度。因为需要在长度为 `k` 的滑动窗口中维护频率并排序，以获取前 `x` 个最大频率的元素。
- **空间复杂度**：`O(k)`，需要 `O(k)` 的空间来存储哈希表和数组。

## 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
var findXSum = function (nums, k, x) {
	let n = nums.length;
	let answer = [];
	// 维护元素的频率
	let freq = new Map();

	// 滑动窗口
	for (let i = 0; i < n; i++) {
		// 加入新元素
		freq.set(nums[i], (freq.get(nums[i]) || 0) + 1);

		// 如果窗口超出大小，移除最左边的元素
		if (i >= k) {
			let leftElem = nums[i - k];
			freq.set(leftElem, freq.get(leftElem) - 1);
			if (freq.get(leftElem) === 0) {
				freq.delete(leftElem);
			}
		}

		// 计算当前窗口的 x 和
		if (i >= k - 1) {
			// 排序
			let arr = [...freq.entries()].sort((a, b) => {
				if (a[1] === b[1]) {
					return b[0] - a[0];
				}
				return b[1] - a[1];
			});

			let sum = 0;
			for (let j = 0; j < Math.min(x, arr.length); j++) {
				sum += arr[j][0] * arr[j][1];
			}

			answer.push(sum);
		}
	}

	return answer;
};
```
