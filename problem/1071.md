# [1071. 字符串的最大公因子](https://leetcode.com/problems/greatest-common-divisor-of-strings)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`数学`](/tag/math.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/greatest-common-divisor-of-strings)

## 题目

<p>对于字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>，只有在&nbsp;<code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定&nbsp;“<code>t</code> 能除尽 <code>s</code>”。</p>

<p>给定两个字符串&nbsp;<code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;。返回 <em>最长字符串&nbsp;<code>x</code>，要求满足&nbsp;<code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>str1 = "ABCABC", str2 = "ABC"
<strong>输出：</strong>"ABC"
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>str1 = "ABABAB", str2 = "ABAB"
<strong>输出：</strong>"AB"
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>str1 = "LEET", str2 = "CODE"
<strong>输出：</strong>""
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>
	<li><code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;由大写英文字母组成</li>
</ul>


## 解题思路

这道题本质上就是要求出两个字符串长度的最大公因数（GCD），然后判断长度为 GCD 的前缀字符串是不是公共分隔字符串。

1. **计算最大公约数**：

   首先，计算两个字符串的长度 `len1` 和 `len2`，并找出它们的最大公约数（GCD），该值将决定可能的公共分隔字符串的长度；

   计算 GCD 最常用高效的办法是 **辗转相除法（欧几里得算法）**：

   - **定理**：对于任意两个正整数 `a` 和 `b`（假设 `a > b`），它们的最大公约数等于 `b` 和 `a` 除以 `b` 的余数（`a % b`）的最大公约数。
   - 形式化表示为：`GCD(a, b) = GCD(b, a % b)`
   - 算法的步骤如下：

     1. 如果 `b = 0`，则 `GCD(a, b) = a`。
     2. 否则，递归计算 `GCD(b, a % b)`。

   - 举例来说，假设我们要计算 `GCD(48, 18)`：

     - `GCD(48, 18)`
     - `48 % 18 = 12`
     - 现在计算 `GCD(18, 12)`
     - `18 % 12 = 6`
     - 现在计算 `GCD(12, 6)`
     - `12 % 6 = 0`
     - 现在计算 `GCD(6, 0)`，结果为 `6`
     - 最终，`GCD(48, 18)` 的结果是 `6`

2. **候选字符串**：

   - 生成一个候选字符串 `prefix`，其长度为 `gcd(len1, len2)`，并从 `str1` 的开始部分提取这一长度的子字符串；

3. **验证是否能整除**：
   - 检查 `prefix` 能否通过重复多次构造出 `str1` 和 `str2`；
   - 如果能，则返回 `prefix`；否则返回空字符串；

#### 复杂度分析

- **时间复杂度**：`O(n + m)`，其中 `n` 和 `m` 是 `str1` 和 `str2` 的长度，需要遍历每个字符串来验证。
- **空间复杂度**：`O(1)`，仅使用常量空间用于存储长度和子字符串。

## 代码

```javascript
/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function (str1, str2) {
	// 计算最大公约数的函数
	const gcd = (a, b) => {
		while (b !== 0) {
			const temp = b;
			b = a % b;
			a = temp;
		}
		return a;
	};

	const gcdLen = gcd(str1.length, str2.length);
	const prefix = str1.slice(0, gcdLen);

	// 检查 prefix 是否能重复多次构造出 str1 和 str2
	if (
		prefix.repeat(str1.length / gcdLen) == str1 &&
		prefix.repeat(str2.length / gcdLen) == str2
	) {
		return prefix;
	}

	// 如果不能整除，返回空字符串
	return '';
};
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 1979 | [找出数组的最大公约数](https://leetcode.com/problems/find-greatest-common-divisor-of-array) |  |  [`数组`](/tag/array.md) [`数学`](/tag/math.md) [`数论`](/tag/number-theory.md) | <font color=#15bd66>Easy</font> |
| 2413 | [最小偶倍数](https://leetcode.com/problems/smallest-even-multiple) |  |  [`数学`](/tag/math.md) [`数论`](/tag/number-theory.md) | <font color=#15bd66>Easy</font> |