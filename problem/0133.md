# [133. 克隆图](https://leetcode.com/problems/clone-graph)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) [`哈希表`](/tag/hash-table.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/clone-graph)

## 题目

<p>给你无向&nbsp;<strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank">连通</a>&nbsp;</strong>图中一个节点的引用，请你返回该图的&nbsp;<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank"><strong>深拷贝</strong></a>（克隆）。</p>

<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>

<pre>
class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}</pre>

<p>&nbsp;</p>

<p><strong>测试用例格式：</strong></p>

<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>

<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>

<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将&nbsp;<strong>给定节点的拷贝&nbsp;</strong>作为对克隆图的引用返回。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" style="height: 500px; width: 500px;" /></p>

<pre>
<strong>输入：</strong>adjList = [[2,4],[1,3],[2,4],[1,3]]
<strong>输出：</strong>[[2,4],[1,3],[2,4],[1,3]]
<strong>解释：
</strong>图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" style="height: 148px; width: 163px;" /></p>

<pre>
<strong>输入：</strong>adjList = [[]]
<strong>输出：</strong>[[]]
<strong>解释：</strong>输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>adjList = []
<strong>输出：</strong>[]
<strong>解释：</strong>这个图是空的，它不含任何节点。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>这张图中的节点数在 <code>[0, 100]</code>&nbsp;之间。</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li>每个节点值&nbsp;<code>Node.val</code> 都是唯一的，</li>
	<li>图中没有重复的边，也没有自环。</li>
	<li>图是连通图，你可以从给定节点访问到所有节点。</li>
</ul>


## 解题思路

克隆图的常见解法是使用深度优先搜索（DFS）或广度优先搜索（BFS）。以深度优先搜索为例，可以通过递归实现图的克隆。在递归的过程中，使用 `visited` 哈希表来记录已经访问过的节点，避免重复遍历。

1. 使用一个哈希表 `visited` 来存储原图节点和克隆图节点的映射关系。键为原图节点，值为克隆图节点。
2. 定义一个 DFS 函数，输入为原图节点 `node`，在函数中进行如下操作：
   - 如果 `node` 为空，直接返回 `null`。
   - 如果 `node` 在 `visited` 中，说明已经访问过，直接返回对应的克隆图节点。
   - 否则，创建一个克隆图节点，并将其放入 `visited` 中，键为 `node`，值为 `cloneNode`。
   - 对 `node` 的邻居进行递归调用 DFS，并将结果添加到 `visited.get(node)` 的邻居列表中。
3. 最后返回克隆图的起始节点。

当然也有人写 DFS 时不习惯返回值，这样更清晰易懂一些，详见解法二。

## 代码

::: code-tabs

@tab DFS

```javascript
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function (node) {
	if (!node) return null;
	let visited = new Map();
	const dfs = (node) => {
		if (!node) return null;
		if (visited.has(node)) return visited.get(node);
		visited.set(node, new Node(node.val));
		for (let i of node.neighbors) {
			visited.get(node).neighbors.push(dfs(i));
		}
		return visited.get(node);
	};

	return dfs(node);
};
```

@tab DFS 无返回值版

```javascript
/**
 * @param {_Node} node
 * @return {_Node}
 */
var cloneGraph = function (node) {
	let copy = new Map();

	const dfs = (node) => {
		if (!node) return;
		if (copy.has(node)) return;
		copy.set(node, new Node(node.val));

		for (let item of node.neighbors) {
			dfs(item);
			copy.get(node).neighbors.push(copy.get(item));
		}
	};

	dfs(node);
	return copy.get(node);
};
```

:::

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 138 | [随机链表的复制](https://leetcode.com/problems/copy-list-with-random-pointer) | [[✓]](/problem/0138.md) |  [`哈希表`](/tag/hash-table.md) [`链表`](/tag/linked-list.md) | <font color=#ffb800>Medium</font> |
| 1485 | [克隆含随机指针的二叉树](https://leetcode.com/problems/clone-binary-tree-with-random-pointer) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `2+` | <font color=#ffb800>Medium</font> |
| 1490 | [克隆 N 叉树](https://leetcode.com/problems/clone-n-ary-tree) |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | <font color=#ffb800>Medium</font> |