# [303. 区域和检索 - 数组不可变](https://leetcode.com/problems/range-sum-query-immutable)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`前缀和`](/tag/prefix-sum.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/range-sum-query-immutable)

## 题目

<p>给定一个整数数组 &nbsp;<code>nums</code>，处理以下类型的多个查询:</p>

<ol>
	<li>计算索引&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;（包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中&nbsp;<code>left &lt;= right</code></li>
</ol>

<p>实现 <code>NumArray</code> 类：</p>

<ul>
	<li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li>
	<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;之间的元素的 <strong>总和</strong> ，包含&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;两点（也就是&nbsp;<code>nums[left] + nums[left + 1] + ... + nums[right]</code>&nbsp;)</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
<strong>输出：
</strong>[null, 1, -1, -3]

<strong>解释：</strong>
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li>
	<li>最多调用 <code>10<sup>4</sup></code> 次 <code>sumRange</code><strong> </strong>方法</li>
</ul>


## 解题思路

标准的前缀和问题，核心思路是用一个新的数组 `preSum` 记录 `nums` 的累加和，这样，`sumRange` 函数仅仅需要做一次减法运算，避免了每次进行 `for` 循环调用，最坏时间复杂度为常数 `O(1)`。

#### 复杂度分析

- **时间复杂度**: `sumRange` 函数的时间复杂度为 `O(1)`。
- **空间复杂度**: `O(n)`，其中 `n` 为 `nums` 数组的长度，使用了一个长度为 `n` 的数组来存储中间状态。

## 代码

```javascript
/**
 * @param {number[]} nums
 */
class NumArray {
	constructor(nums) {
		this.preSum = [0];
		for (let i = 1; i <= nums.length; i++) {
			this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
		}
	}

	/**
	 * @param {number} left
	 * @param {number} right
	 * @return {number}
	 */
	sumRange(left, right) {
		return this.preSum[right + 1] - this.preSum[left];
	}
}
```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 |
| :------: | :------ | :------: | :------ | :------ |
| 304 | [二维区域和检索 - 矩阵不可变](https://leetcode.com/problems/range-sum-query-2d-immutable) |  |  [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) `1+` | <font color=#ffb800>Medium</font> |
| 307 | [区域和检索 - 数组可修改](https://leetcode.com/problems/range-sum-query-mutable) | [[✓]](/problem/0307.md) |  [`设计`](/tag/design.md) [`树状数组`](/tag/binary-indexed-tree.md) [`线段树`](/tag/segment-tree.md) `1+` | <font color=#ffb800>Medium</font> |
| 325 | [和等于 k 的最长子数组长度](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k) |  |  [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`前缀和`](/tag/prefix-sum.md) | <font color=#ffb800>Medium</font> |