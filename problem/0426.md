# [426. 将二叉搜索树转化为排序的双向链表](https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`链表`](/tag/linked-list.md) [`二叉树`](/tag/binary-tree.md) [`双向链表`](/tag/doubly-linked-list.md)&emsp; 🔗&ensp;[`LeetCode`](https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list)

## 题目



## 解题思路

二叉搜索树的中序遍历结果是有序的，因此要将一个二叉搜索树就地转化为一个已排序的双向循环链表，可以采用中序遍历的方式，将节点的左右指针分别指向前驱和后继节点。最后，调整头尾节点的前驱和后继指针，形成循环链表。

1. 定义两个指针 `head` 和 `tail`，它们分别表示双向链表的头部和尾部。
2. 定义一个中序遍历的函数 `traverse`，其中对每个节点进行如下处理：
   - 如果 `head` 为空，将当前节点赋值给 `head`。
   - 如果 `tail` 不为空，将 `tail` 的右指针指向当前节点，将当前节点的左指针指向 `tail`。
   - 更新 `tail` 为当前节点。
3. 在 `traverse` 完成中序遍历后，将 `head` 和 `tail` 进行连接，形成双向循环链表。
   - 将 `head` 的左指针指向 `tail`。
   - 将 `tail` 的右指针指向 `head`。

这样，我们就完成了将 BST 转化为已排序的双向循环链表。最后，返回 `head` 作为循环链表的头节点。

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是二叉搜索树的节点数量。因为我们需要访问每个节点一次，完成中序遍历。
- **空间复杂度**：`O(h)`，其中 `h` 是二叉搜索树的高度，表示递归调用栈的深度。

## 代码

```javascript
/**
 * @param {Node} root
 * @return {Node}
 */
var treeToDoublyList = function (root) {
	if (!root) return null;
	let head = null;
	let tail = null;

	const traverse = (root) => {
		if (!root) return null;
		traverse(root.left);

		// 处理当前节点
		if (!head) {
			head = root;
		}
		if (tail) {
			tail.right = root;
			root.left = tail;
		}
		tail = root;

		traverse(root.right);
	};

	// 开始中序遍历
	traverse(root);

	// 将头尾相连形成循环链表
	head.left = tail;
	tail.right = head;
	return head;
};
```
